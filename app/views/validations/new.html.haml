-content_for :title, "Validation for #{@certificate_order.ref}"
-co = @certificate_order
-checkout_in_progress=co.validation_stage_checkout_in_progress?
-form_action = Rails.env=~/production/i ? "https://sws.sslpki.com" : "https://sws-test.sslpki.local:3000"
-if checkout_in_progress
  -i=adjusted_position(5, co)
  =order_progress_indicator(i, co.certificate)
%h3
  Validation #{'Documentation' unless checkout_in_progress} for
  -if other_party_request(@certificate_order)
    Certificate Order ##{@certificate_order.ref}
  -else
    =link_to "Certificate Order ##{@certificate_order.ref}", @certificate_order
  =error_messages_for :validation, @dcv, @other_party_validation_request
-if true #co.certificate.is_ucc?
  .error{style: "display: none;"}
  %h2 Domain Validation
  %h3
    Please select the appropriate validation option for each domain and then click the 'Validate' button.
    Only after you click 'Validate' will the actual validation be performed.
  %table{style: "width: 100%; border: 1px solid black; padding: 1em"}
    %tr
      %th format
      %th csr hash options
    %tr
      %td file
      %td=link_to "click here to download file #{co.csr.md5_hash}.txt", http_dcv_file_csr_path(co.csr)
    %tr
      %td cname
      %td create CNAME in dns and point to #{co.csr.sha1_hash}.comodoca.com
    %tr
      %td md5 hash
      %td.md5_hash=co.csr.md5_hash
    %tr
      %td sha1 hash
      %td.sha1_hash=co.csr.sha1_hash
  =form_tag(form_action+api_certificate_update_v1_4_path(co.ref), method: :put, class: :api_certificate_request) do
    =hidden_field_tag :account_key, current_user.ssl_account.api_credential.account_key
    =hidden_field_tag :secret_key, current_user.ssl_account.api_credential.secret_key
    -all_validated=false
    %table{style: "width: 100%; border: 1px solid black; padding: 1em"}
      %thead
        %td=check_box_tag "select_all", nil, {id: "select_all"}
        %th domain
        %th options
        -#%th description
        %th pre-test
        %th previous attempt
        %th attempted on
        %th status
      -if co.external_order_number
        -cns = co.certificate_content.certificate_names
        -mdc_validation = ComodoApi.mdc_status(co)
        -sdc_validation = ComodoApi.collect_ssl(co)
        -ds = mdc_validation.domain_status
        -count_validated,count_domain=0,0
        -(@certificate_order.certificate.is_ucc? ? cns : [cns.last]).each_with_index do |cn|
          -if @certificate_order.certificate.is_ucc?;
            -if ds && ds[cn.name] #comodo api acts strange for non ucc cert
              -name=ds[cn.name]
              -validated = (name && name["status"]=~/validated/i)
              -count_domain+=1
              -count_validated+=1 if validated
              -dcv = cn.domain_control_validations.last
              -le=cn.domain_control_validations.last_emailed
              -addresses = validated ? [] : (co.certificate_content.certificate_names.count > Validation::COMODO_EMAIL_LOOKUP_THRESHHOLD ? DomainControlValidation.email_address_choices(cn.name) : ComodoApi.domain_control_email_choices(cn.name).email_address_choices)
              -addresses.delete("none")
              -opts = {"validation via email" => addresses, "validation via csr hash" =>  [["csr hash text file using http://","http_csr_hash"], ["csr hash text file using https://","https_csr_hash"], ["add cname entry","cname_csr_hash"]]}
              %tr[cn]
                %td=check_box_tag cn.id, false, nil, class: "check_box"
                %td=cn.name
                %td=validated ? "validation satisfied for #{cn.name}" : select_tag("domains[#{cn.name}][dcv]", grouped_options_for_select(opts, name["method"].downcase.gsub("pre-validated %28","").gsub("%29","").gsub(" ","_")),prompt: 'Please select a validation method', disabled: validated, alt: cn.name)
                -#%td description
                %td.pretest{class: cn.name} n/a
                %td.attempt{class: cn.name}=name["method"].downcase.gsub("%28"," ").gsub("%29"," ") if ds && name
                -#%td{class: cn}=dcv.blank? ? "validation not performed yet" : "#{dcv.action_performed}" #file upload attempted on 12-15-2015
                %td.attempted_on{class: cn.name}=dcv.blank? ? "n/a" : dcv.created_at
                %td.status{class: cn.name}=name["status"].downcase if ds && name
              %tr
                %td
                %td
                %td{colspan: "5"}
                  instructions:
                  %span{alt: "domains[#{cn.name}][dcv]"} #{validated ? "n/a" : "please select a validation method"}
            -all_validated=true if count_domain==count_validated && count_validated>0
          -else
            -last_sent = cn.last_dcv
            -if ds
              -name=ds.to_a[0][1]
              -validated = all_validated = (name && name["status"]=~/validated/i)
            -else
              -validated=(last_sent && last_sent.satisfied?) ? true : false
            -dcv = cn.domain_control_validations.last
            -le=cn.domain_control_validations.last_emailed
            -addresses = validated ? [] : (co.certificate_content.certificate_names.count > Validation::COMODO_EMAIL_LOOKUP_THRESHHOLD ? DomainControlValidation.email_address_choices(cn.name) : ComodoApi.domain_control_email_choices(cn.name).email_address_choices)
            -addresses.delete("none")
            -opts = {"validation via email" => addresses, "validation via csr hash" =>  [["csr hash text file using http://","http_csr_hash"], ["csr hash text file using https://","https_csr_hash"], ["add cname entry","cname_csr_hash"]]}
            %tr[cn]
              %td=check_box_tag cn.id, false, nil, class: "check_box"
              %td
                =cn.name
              %td=validated ? "validation satisfied for #{cn.name}" : select_tag("domains[#{cn.name}][dcv]", grouped_options_for_select(opts, name["method"].downcase.gsub("pre-validated %28","").gsub("%29","").gsub(" ","_")),prompt: 'Please select a validation method', disabled: validated, alt: cn.name)
              -#%td description
              %td.pretest{class: cn.name} n/a
              %td.attempt{class: cn.name}=name["method"].downcase.gsub("%28"," ").gsub("%29"," ") if ds && name
              -#%td{class: cn}=dcv.blank? ? "validation not performed yet" : "#{dcv.action_performed}" #file upload attempted on 12-15-2015
              %td.attempted_on{class: cn.name}=last_sent.blank? ? "n/a" : last_sent.created_at
              %td.status{class: cn.name}=name["status"].downcase if ds && name
            %tr
              %td
              %td
              %td{colspan: "5"}
                instructions:
                %span{alt: "domains[#{cn.name}][dcv]"} #{validated ? "n/a" : "please select a validation method"}
      -else
        -co.certificate_content.certificate_names.each do |cn|
          -dcv = cn.domain_control_validations.last
          -le=cn.domain_control_validations.last_emailed
          -opts = {"validation via email" => DomainControlValidation.email_address_choices(cn.name), "validation via csr hash" =>  [["csr hash text file using http://","http_csr_hash"], ["csr hash text file using https://","https_csr_hash"], ["add cname entry","cname_csr_hash"]]}
          %tr[cn]
            %td=check_box_tag cn.id, false, nil, class: "check_box"
            %td=cn.name
            %td=select_tag "domains[#{cn.name}][dcv]", grouped_options_for_select(opts, le.blank? ? nil : le.email_address), prompt: 'Please select a validation method', alt: cn.name
            -#%td description
            %td.pretest{class: cn.name} n/a
            %td.attempt{class: cn.name} validation not performed yet
            %td.attempted_on{class: cn.name} n/a
            %td.status{class: cn.name} waiting
          %tr
            %td
            %td
            %td{colspan: "5"}
              instructions:
              %span{alt: "domains[#{cn.name}][dcv]"} please select a validation method
    #upload_validations(style='width: 100%; text-align: center;')
      -unless all_validated
        =submit_tag "Validate", :id=>"validate_domains", :disable_with=>"Submitting..."
        .clearfix
          =image_tag('waiting_bar_medium.gif', :id=>'waiting_bar', :style=>'display: none; vertical-align: middle;')
-else
  #stylized.default_form
    =form_tag(upload_certificate_order_validation_path(co.ref),{ :multipart => true}) do
      -if checkout_in_progress
        -unless co.certificate.is_dv?
          =render partial: 'refer_to_others', locals: {co: co, hide_options: !checkout_in_progress}
        =render partial: 'proof_of_dcv', locals: {co: co}
        -unless (co.certificate.is_dv_or_basic? && checkout_in_progress)
          #documents_upload_heading
            .subheading Documentation
            .clearfix
              %label{:for=>"skip_validation"}
                *Validation documents:
                %span.label_desc you can skip this step for now
              .radio_choices
                .radio_w_desc.clearfix
                  =radio_button_tag :has_documents, true
                  %span.has_csr_container I have my documents ready and want to upload them now
                .radio_w_desc.clearfix
                  =radio_button_tag :has_documents, false
                  %span.has_csr_container I want to upload documents later
      -unless (co.certificate.is_dv_or_basic? && checkout_in_progress)
        #documents_upload_section
          #documents_upload_instructions
            %h2 Documents
            -if co.certificate.is_ev?
              %p
                SSL.com will verify the existence of your business, the ownership of the domain(s)
                #{co.all_domains.join(", ")}, and your employment status or authority to
                request the SSL Certificate for #{co.all_domains.join(", ")}. The following documents are required:
                %dl.listing
                  %dd
                    %ul
                      %li
                        %dt Full EV Authorization Form (#{link_to "click here to download form #{image_tag('pdf_icon.gif')}".html_safe, "https://support.ssl.com/index.php?_m=downloads&_a=downloadfile&downloaditemid=4"})
                        %dd This form of the EV Request should be used when more than one individual are acting in the roles of Certificate Requester, Certificate Approver and Contract (Subscriber Agreement) Signer.)
                      %li
                        %dt Simplified EV Authorization Form (#{link_to "click here to download form #{image_tag('pdf_icon.gif')}".html_safe, "https://support.ssl.com/index.php?_m=downloads&_a=downloadfile&downloaditemid=5"})
                        %dd This form should be used if one person is to act in all three roles, Certificate Requester, Certificate Approver and Contract (Subscriber Agreement) Signer.
            -else
              %p
                If documents are required for this order, then SSL.com will verify the existence of your business, the ownership of the domain(s)
                #{co.all_domains.join(", ")}, and your employment status or authority to
                request the SSL Certificate for #{co.all_domains.join(", ")}. Documents required from the registrant listed
                on this whois record for #{co.subject} may include:
              -co.validation.validation_rules.sort{|a,b|a.id<=>b.id}.each do |vr|
                -unless vr.description =~ /domain/
                  %dl.listing
                    -case vr.description
                    -when /organization/
                      %dt
                        Any of the following official government documentation proving your right to do
                        business:
                      %dd
                        %ul
                          -vr.applicable_validation_methods.each do |m|
                            %li=m
                    -when /ev/
                      %dt.ev_instructions
                        In addition to the above documentation, extended validation certificates require an
                        authorization form signed by an authorized representative for #{co.subject}.
                        Please fill out any of the forms below and submit it to complete the extended
                        validation portion of this order:
                      %dd
                        %ul
                          %li
                            %dt Full EV Authorization Form (#{link_to "click here to download form #{image_tag('pdf_icon.gif')}".html_safe, "https://support.ssl.com/index.php?_m=downloads&_a=downloadfile&downloaditemid=4"})
                            %dd This form of the EV Request should be used when more than one individual are acting in the roles of Certificate Requester, Certificate Approver and Contract (Subscriber Agreement) Signer.)
                          %li
                            %dt Simplified EV Authorization Form (#{link_to "click here to download form #{image_tag('pdf_icon.gif')}".html_safe, "https://support.ssl.com/index.php?_m=downloads&_a=downloadfile&downloaditemid=5"})
                            %dd This form should be used if one person is to act in all three roles, Certificate Requester, Certificate Approver and Contract (Subscriber Agreement) Signer.
            %p
              Up to 5 files can be uploaded. Zipped documents can also be uploaded, and
              they will automatically be unpacked. The following file types are accepted:
              #{ValidationHistory.acceptable_file_types}
          =file_field_tag "filedata[]", :id=> "multi_upload"
      #upload_validations(style='width: 100%; text-align: center;')
        -if checkout_in_progress
          %input(type="button" class="shiny_blue_button" id="start_over" value="Cancel")
        =submit_tag "Submit", :id=>"upload_files", :disable_with=>"Submitting..."
        .clearfix
          =image_tag('waiting_bar_medium.gif', :id=>'waiting_bar', :style=>'display: none; vertical-align: middle;')
      #button_container(style='display : none')
        #skip_button=link_to image_tag("skip_bl.gif"), co
=render :partial => 'index_scripts'
%script{:type=>"text/javascript"}
  :plain
    //# PLUGIN INTEGRATION
    jQuery(function($){
      $('#multi_upload').MultiFile({
        max: 5,
        accept: '#{ValidationHistory.multi_upload_types}',
        STRING:{
        remove: '#{image_tag('minus.gif')}'},
        afterFileSelect:function(element,value,master){
       }
      });
      $('#upload_files').click(function(){
        $('#waiting_bar').show();});
    });
