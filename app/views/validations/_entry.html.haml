-@cert_order = co
-cc = co.certificate_content
-skip_registrant = co.certificate.is_client_basic? || co.certificate.is_client_pro?
-unless skip_registrant
  -cn = co.certificate.is_code_signing? or co.certificate.is_smime_or_client? ? co.registrant.company_name : cc.csr.try(:common_name)
-v = co.validation
%tr.expanded(class="#{'hidden' if current_page?(:validations) or current_page?(:search_validations)}")
  %td(colspan="6")
    .certificate_details
      =render :partial=>'/certificate_orders/menu', :locals=>{:co=>co}
      =render :partial=>'/certificate_orders/co', :object=>co
      %table(cellspacing="0")
        %tbody
          %tr
            %td(colspan="6")
              .certificate_details_box
                %ul
                  #validation_requirements_box
                    %li
                      %strong validation requirements
                      -if !co.certificate_content.has_all_contacts? && !co.certificate.is_smime_or_client?
                        %li
                          %span.rule_name contacts
                          %ul
                            %li.rules_methods_block
                              %em status:
                              %ul
                                %li
                                  %span.validation_attention contacts are required but are missing
                      -elsif current_user.try("is_admin?")
                        %li.rules_methods_block(class="admin_approve_#{i}" style='color:red')
                          =form_for v, :html=>{:alt=>"#{i}", :class=>'edit_validation_ruling'} do |f|
                            =hidden_field_tag 'certificate_order', co.id
                            -#=hidden_field_tag 'link_to_generate_cert', generate_cert_certificate_order_path(@ssl_slug, co.ref)
                            %em admin only:
                            -v.validation_rules.each_with_index do |vr, vri|
                              -vrl = v.validation_rulings.detect do |vrl| vrl.validation_rule == vr end
                              %ul
                                %li
                                  for requirement:
                                  %span.rule_name
                                    #{vr.description}
                              %ul
                                %li
                                  #{radio_button_tag "ruling_decision_#{vrl.id}", ValidationRuling::APPROVED, nil, :alt=>"#{vrl.id}"}approve
                                %li
                                  #{radio_button_tag "ruling_decision_#{vrl.id}", ValidationRuling::UNAPPROVED, nil, :alt=>"#{vrl.id}"}unapprove
                                %li
                                  #{radio_button_tag "ruling_decision_#{vrl.id}", ValidationRuling::MORE_REQUIRED, nil, :alt=>"#{vrl.id}"}more required
                              %ul(class="reason_block_#{vrl.id}" style="display: none")
                                %li
                                  %em
                                    reason:
                                  %ul
                                    %li=text_area_tag "ruling_reason_#{vrl.id}"
                            %ul
                              -if co.certificate.requires_locked_registrant?
                                %li.validation_complete
                                  #{check_box_tag "validation_complete", cc.validated? ? false : true, false, :alt=>"#{i}"}#{cc.validated? ? "unvalidate" : "validation complete" }
                                %li.email_customer
                                  #{check_box_tag "email_customer", true, false, :alt=>"#{i}"}notify customer?
                              %li.approve_submit=submit_tag 'submit'
                        -#-if co.certificate.is_code_signing?
                          %ul
                            %li
                              =form_tag certificate_order_tokens_path(@ssl_slug), :id => 'send_certificate_order_token', :method => :post, :class => (status == 'validated' ? '' : 'hidden') do
                                =hidden_field_tag 'certificate_order_ref', co.ref
                                %em
                                  =link_to 'send activation link to ' + to_reminder, nil, id: 'link_to_send_token'
                      -#-elsif current_user.try("is_account_admin?") && co.certificate.is_code_signing? && status == 'validated'
                        =form_tag certificate_order_tokens_path(@ssl_slug), :id => 'send_certificate_order_token', :method => :post do
                          =hidden_field_tag 'certificate_order_ref', co.ref
                          %em team admin only:
                          %ul
                            %li
                              =link_to 'send activation link to ' + to_reminder, nil, id: 'link_to_send_token'
                    -v.validation_rules.each_with_index do |vr, vri|
                      -is_domain_validation = vr.description=~/^domain/
                      %li.validation_section
                        %span.rule_name=vr.description
                        %ul
                          -vrl = v.validation_rulings.detect do |vrl| vrl.validation_rule == vr end
                          -status, status_class = validation_status(vrl)
                          -status = status.gsub("documents", "user reponse") if is_domain_validation
                          %li.rules_methods_block
                            %em
                              status:
                            %ul
                              %li
                                %span(class="validation_status_result_#{vrl.id} #{status_class} #{vr.description.gsub(" ", "_")}_#{i}") #{status}
                            %ul.applied_docs(class="applied_docs_summary_#{i}")
                              -v.validation_histories.applied_to(vr).each do |vh|
                                -name = vh.document_file_name.shorten(20, false)
                                %li.applied_doc.approved_validation_document(alt="#{name}_#{i}_#{vh.id}")
                                  applied: #{name}
                          -unless is_domain_validation
                            %li.rules_methods_block
                              %em status history:
                              %ul(class="status_history_#{vrl.id}" alt="#{vrl.id}")
                                -unless vrl.notes.empty?
                                  -vrl.notes.last(5).each do |note|
                                    %li
                                      %em
                                        #{note.title} by #{note.user.login}:
                                      %ul
                                        %li
                                          #{note.note} - #{note.created_at.strftime("%b %d, %Y")}
                                -else
                                  %li(class="no_validation_decisions_#{vrl.id}")
                                    %em none
                            %li.rules_methods_block
                              %em applicable documents:
                              %ul.applicable_documents
                                -methods=v.validation_histories.applied_to(vr).flatten.map(&:satisfies_validation_methods).flatten.uniq
                                -vr.applicable_validation_methods.each do |vm|
                                  -approved=methods.include?(vm) ? 'approved_validation_document crossout' : ''
                                  %li(class="method_#{i} #{approved} rule_#{vr.id}" alt="method_#{vm}_#{i}")
                                    %span=vm
                                    %ul
                                      -v.validation_histories.applied_to(vr).each do |vh|
                                        -if !vh.satisfies_validation_methods.blank? && vh.satisfies_validation_methods.include?(vm)
                                          -name = vh.document_file_name.shorten(20, false)
                                          %li.applied_doc.tree-connect(alt="#{name}_#{i}_#{vh.id}")
                                            applied: #{name}
                          =render partial: 'validations/dcv', locals: {co: co}
                  -if @cert_order.locked_registrant
                    %li.send_callback_section
                      -#-TODO: After add info_verified state to workflow on certificate content,
                      -#-TODO: below if statement should be commented out and "perform callback" link should be inside if statement.
                      -#- if @cert_order.certificate_content.info_verified?
                      - if @cert_order.phone_verified?
                        - if @cert_order.locked_registrant.country_code.blank?
                          callback verification completed for #{'+1-' + @cert_order.locked_registrant.phone}
                        - else
                          callback verification completed for #{'+' + @cert_order.locked_registrant.country_code + '-' + @cert_order.locked_registrant.phone}
                      - else
                        =link_to 'Perform Callback', nil, id: 'link_to_send_callback', 'data-phone-number-approved' => @cert_order.locked_registrant.phone_number_approved, 'data-super-user' => current_user.is_super_user?, 'data-url' => current_user.is_super_user? ? edit_certificate_order_url(id: @cert_order.ref, registrant: false, approve_phone: true) : request_approve_phone_number_certificate_order_validation_path(@ssl_slug, @cert_order.ref)
              .certificate_details_box
                %ul
                  %li
                    %strong(class="val_docs_list_#{i}" alt="#{v.validation_histories.count}") validation documents
                  -if co.validation.validation_histories.empty?
                    -if co.is_express_validation?
                      %li
                        %em none required
                    -else
                      %li
                        %em none submitted
                      %li
                        =link_to image_tag('upload_med.jpg', :style=>'vertical-align:middle')+"UPLOAD DOCUMENT(S)", document_upload_certificate_order_validation_url(certificate_order_id: co.ref)
                  -else
                    -co.validation.validation_histories.each_with_index do |h, hi|
                      .validation_history
                        %li
                          - if h.document_content_type =~ %r(image)
                            =link_to image_tag('preview.png', :class=>'blue_icon'), h.document_url(:preview), :rel=>'prettyPhoto'
                          =link_to image_tag('download.png', :class=>'blue_icon'), h.document_url
                          %span.doc_filename(alt="#{h.document_file_name}")=link_to h.document_file_name.shorten(20,false), edit_certificate_order_validation_url(certificate_order_id: co.ref)
                          -unless current_user.try("is_admin?") || h.satisfies_validation_methods.blank?
                            -methods=h.satisfies_validation_methods.split(", ")
                            %dl
                              %dt document type:
                              -methods.each do |m|
                                %dd=m
                          -if current_user.try("is_admin?")
                            =form_for h do |f|
                              .validation_admin_controls
                                =hidden_field_tag :validation, co.validation.id
                                .validation_setting
                                  %dt
                                    %em.clearfix satisfies requirements (hold ctrl button while clicking choices to select multiple requirements)
                                  %dd
                                    -o=[Validation::NONE_SELECTED]+co.validation.validation_rules.collect {|r| [r.description, r.id] }.sort{|x,y|x[0]<=>y[0]}
                                    -selected = h.validation_rules.map(&:id).empty? ? [Validation::NONE_SELECTED] : h.validation_rules.map(&:id)
                                    =f.select :validation_rules, options_for_select(o, selected),{}, {:multiple=>true, :size=>3, :alt=>"#{i}_#{h.id}"}
                                .validation_setting
                                  %dt
                                    %em.clearfix document type (hold ctrl button while clicking choices to select multiple requirements)
                                  %dd
                                    -o=[Validation::NONE_SELECTED]+co.validation_methods.collect {|m| [m, m] }.sort
                                    -selected = h.satisfies_validation_methods.blank? ? [Validation::NONE_SELECTED] : h.satisfies_validation_methods
                                    =f.select :satisfies_validation_methods, options_for_select(o, selected),{}, {:multiple=>true, :size=>3, :alt=>"#{i}_#{h.id}"}
                    %li
                      =link_to 'manage', edit_certificate_order_validation_url(certificate_order_id: co.ref)
                      |
                      =link_to 'upload', document_upload_certificate_order_validation_url(certificate_order_id: co.ref)
              .certificate_details_box
                %ul
                  -if cn and !co.certificate.is_code_signing?
                    =render partial: 'certificate_orders/visit', locals: {cn: cn}
                  =render partial: 'shared/small_admin_functions', locals: {co: co}
                -if current_user.try("is_admin?") and co.certificate.is_server?
                  %ul#send_to_ca_box
                    %li
                      %strong
                        process certificate signing request
                    %li=link_to 'send to comodo ca', send_to_ca_certificate_order_validation_url(certificate_order_id: co.ref), remote: true, id: "send_to_ca", "data-type"=>"json"
                    %li
                      #processing_ca
                        =image_tag 'waiting_bar_medium.gif'
                        %span processing...
                      %dl#sent_to_ca_results
                        =render partial: "sent_ca_result", collection: co.ca_certificate_requests, as: :ca_response
                        =render partial: "cert_ca_result", locals: {ca_response: co.ca_retrieve_certificates.first} unless co.ca_retrieve_certificates.blank?
                  %ul
                    %li
                      %strong notes
                    %li.category_border
                      -unless co.notes.blank?
                        =co.notes
                      -else
                        no notes found
          -if co.certificate.is_server? and !cc.ca.blank?
            %tr
              %td(colspan="6")
                .certificate_details_box
                  %ul
                    #validation_requirements_box
                      %li
                        %strong domain validations
                      -co.certificate_content.certificate_names.includes{:domain_control_validations}.each do |cn|
                        -dcv=cn.domain_control_validations.find(&"satisfied?".to_sym)
                        -if dcv
                          -identifier = case dcv.dcv_method
                            -when /email/
                              -dcv.email_address
                            -else
                              -dcv.identifier
                        %li
                          #{cn.name}
                          %ul
                            %li #{dcv ? "validated by #{dcv.dcv_method} on #{dcv.responded_at.strftime("%b %d, %Y %R %Z") if dcv.responded_at} with #{identifier}" : "pending validation"}


#email_modal.email-modal
  #email_modal_content.modal-content
    #email_modal_header.modal-header
      %span#email_modal_close.close
        &times;
      %p
        Send callback link to email addresses (newline and whitespace separated):
    #email_modal_body.modal-body
      = text_area_tag 'callback_emails', nil, :rows => '5'
      #required-field
        * Email Address is required!
      #required-valid
        * All Email Addresses should be valid!
    #email_modal_footer.modal-footer
      = button_tag 'Send', :type => 'button', :class => 'btn btn-grey btn-ok-send-emails', :disabled => true
