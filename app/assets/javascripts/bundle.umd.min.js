!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.csrgen={})}(this,function(e){"use strict";function t(e,t,r){return e instanceof Object==!1?r:t in e?e[t]:r}function r(e,t=0,r=e.byteLength){let s="";for(const n of new Uint8Array(e,t,r)){const e=n.toString(16).toUpperCase();s=s+(1===e.length?"0":"")+e}return s}function s(e,t,r,s){return t instanceof ArrayBuffer==!1?(e.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===t.byteLength?(e.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):s<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-s<0)||(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1)}function n(e,t){let r=0;for(let s=e.length-1;s>=0;s--)r+=e[e.length-1-s]*Math.pow(2,t*s);return r}function a(e,t,r=0){const s=r||-1;let n=e,a=0,i=Math.pow(2,t);for(let r=1;r<8;r++){if(e<i){let e;if(s<0)e=new ArrayBuffer(r),a=r;else{if(s<r)return new ArrayBuffer(0);e=new ArrayBuffer(s),a=s}const i=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);i[a-e-1]=Math.floor(n/r),n-=i[a-e-1]*r}return e}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function i(...e){let t=0,r=0;for(const r of e)t+=r.byteLength;const s=new ArrayBuffer(t),n=new Uint8Array(s);for(const t of e)n.set(new Uint8Array(t),r),r+=t.byteLength;return s}function o(...e){let t=0,r=0;for(const r of e)t+=r.length;const s=new ArrayBuffer(t),n=new Uint8Array(s);for(const t of e)n.set(t,r),r+=t.length;return n}function l(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),s=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==s[e])return!1;return!0}function c(e,t){const r=e.toString(10),s=t-r.length,n=new Array(s);for(let e=0;e<s;e++)n[e]="0";return n.join("").concat(r)}const u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",h="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function m(e,t=!1,r=!1,s=!1){let n=0,a=0,i=0,o="";const l=t?h:u;if(s){let t=0;for(let r=0;r<e.length;r++)if(0!==e.charCodeAt(r)){t=r;break}e=e.slice(t)}for(;n<e.length;){const t=e.charCodeAt(n++);n>=e.length&&(a=1);const s=e.charCodeAt(n++);n>=e.length&&(i=1);const c=e.charCodeAt(n++),u=t>>2,h=(3&t)<<4|s>>4;let m=(15&s)<<2|c>>6,f=63&c;1===a?m=f=64:1===i&&(f=64),o+=r?64===m?`${l.charAt(u)}${l.charAt(h)}`:64===f?`${l.charAt(u)}${l.charAt(h)}${l.charAt(m)}`:`${l.charAt(u)}${l.charAt(h)}${l.charAt(m)}${l.charAt(f)}`:`${l.charAt(u)}${l.charAt(h)}${l.charAt(m)}${l.charAt(f)}`}return o}function f(e,t=!1,r=!1){const s=t?h:u;function n(e){for(let t=0;t<64;t++)if(s.charAt(t)===e)return t;return 64}function a(e){return 64===e?0:e}let i=0,o="";for(;i<e.length;){const t=n(e.charAt(i++)),r=i>=e.length?0:n(e.charAt(i++)),s=i>=e.length?0:n(e.charAt(i++)),l=i>=e.length?0:n(e.charAt(i++)),c=a(t)<<2|a(r)>>4,u=(15&a(r))<<4|a(s)>>2,h=(3&a(s))<<6|a(l);o+=String.fromCharCode(c),64!==s&&(o+=String.fromCharCode(u)),64!==l&&(o+=String.fromCharCode(h))}if(r){let e=-1;for(let t=o.length-1;t>=0;t--)if(0!==o.charCodeAt(t)){e=t;break}-1!==e&&(o=o.slice(0,e+1))}return o}function g(e){let t="";const r=new Uint8Array(e);for(const e of r)t+=String.fromCharCode(e);return t}function d(e){const t=e.length,r=new ArrayBuffer(t),s=new Uint8Array(r);for(let r=0;r<t;r++)s[r]=e.charCodeAt(r);return r}const y=Math.log(2);const v=[new Uint8Array([1])],k="0123456789";class b{constructor(e={}){this.blockLength=t(e,"blockLength",0),this.error=t(e,"error",""),this.warnings=t(e,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in e?e.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:r(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const p=e=>(class extends e{constructor(e={}){super(e),this.isHexOnly=t(e,"isHexOnly",!1),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);return 0===n.length?(this.warnings.push("Zero buffer length"),t):(this.valueHex=e.slice(t,t+r),this.blockLength=r,t+r)}toBER(e=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===e?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isHexOnly=this.isHexOnly,e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e}});class w extends(p(b)){constructor(e={}){super(),"idBlock"in e?(this.isHexOnly=t(e.idBlock,"isHexOnly",!1),this.valueHex=t(e.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=t(e.idBlock,"tagClass",-1),this.tagNumber=t(e.idBlock,"tagNumber",-1),this.isConstructed=t(e.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(e=!1){let t,r,s=0;switch(this.tagClass){case 1:s|=0;break;case 2:s|=64;break;case 3:s|=128;break;case 4:s|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(s|=32),this.tagNumber<31&&!this.isHexOnly){if(t=new ArrayBuffer(1),r=new Uint8Array(t),!e){let e=this.tagNumber;s|=e&=31,r[0]=s}return t}if(!1===this.isHexOnly){const n=a(this.tagNumber,7),i=new Uint8Array(n),o=n.byteLength;if(t=new ArrayBuffer(o+1),(r=new Uint8Array(t))[0]=31|s,!e){for(let e=0;e<o-1;e++)r[e+1]=128|i[e];r[o]=i[o-1]}return t}if(t=new ArrayBuffer(this.valueHex.byteLength+1),(r=new Uint8Array(t))[0]=31|s,!1===e){const e=new Uint8Array(this.valueHex);for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHex.byteLength]=e[e.length-1]}return t}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const a=new Uint8Array(e,t,r);if(0===a.length)return this.error="Zero buffer length",-1;const i=192&a[0];switch(i){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&a[0]),this.isHexOnly=!1;const o=31&a[0];if(31!==o)this.tagNumber=o,this.blockLength=1;else{let e=1;this.valueHex=new ArrayBuffer(255);let t=255,r=new Uint8Array(this.valueHex);for(;128&a[e];){if(r[e-1]=127&a[e],++e>=a.length)return this.error="End of input reached before message was fully decoded",-1;if(e===t){t+=255;const e=new ArrayBuffer(t),s=new Uint8Array(e);for(let e=0;e<r.length;e++)s[e]=r[e];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex)}}this.blockLength=e+1,r[e-1]=127&a[e];const s=new ArrayBuffer(e),i=new Uint8Array(s);for(let t=0;t<e;t++)i[t]=r[t];this.valueHex=new ArrayBuffer(e),(r=new Uint8Array(this.valueHex)).set(i),this.blockLength<=9?this.tagNumber=n(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.tagClass=this.tagClass,e.tagNumber=this.tagNumber,e.isConstructed=this.isConstructed,e}}class B extends b{constructor(e={}){super(),"lenBlock"in e?(this.isIndefiniteForm=t(e.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=t(e.lenBlock,"longFormUsed",!1),this.length=t(e.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const a=new Uint8Array(e,t,r);if(0===a.length)return this.error="Zero buffer length",-1;if(255===a[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===a[0],!0===this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&a[0]),!1===this.longFormUsed)return this.length=a[0],this.blockLength=1,t+this.blockLength;const i=127&a[0];if(i>8)return this.error="Too big integer",-1;if(i+1>a.length)return this.error="End of input reached before message was fully decoded",-1;const o=new Uint8Array(i);for(let e=0;e<i;e++)o[e]=a[e+1];return 0===o[i-1]&&this.warnings.push("Needlessly long encoded length"),this.length=n(o,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=i+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=128),t;if(!0===this.longFormUsed){const s=a(this.length,8);if(s.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength+1),!0===e)return t;const n=new Uint8Array(s);(r=new Uint8Array(t))[0]=128|s.byteLength;for(let e=0;e<s.byteLength;e++)r[e+1]=n[e];return t}return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=this.length),t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isIndefiniteForm=this.isIndefiniteForm,e.longFormUsed=this.longFormUsed,e.length=this.length,e}}class A extends b{constructor(e={}){super(e)}static blockName(){return"valueBlock"}fromBER(e,t,r){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}toBER(e=!1){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}}class S extends b{constructor(e={},t=A){super(e),"name"in e&&(this.name=e.name),"optional"in e&&(this.optional=e.optional),"primitiveSchema"in e&&(this.primitiveSchema=e.primitiveSchema),this.idBlock=new w(e),this.lenBlock=new B(e),this.valueBlock=new t(e)}static blockName(){return"BaseBlock"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e=!1){let t;const r=this.idBlock.toBER(e),s=this.valueBlock.toBER(!0);this.lenBlock.length=s.byteLength;const n=this.lenBlock.toBER(e);let a;if(t=i(t=i(r,n),a=!1===e?this.valueBlock.toBER(e):new ArrayBuffer(this.lenBlock.length)),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===e){const e=new Uint8Array(r);e[0]=0,e[1]=0}t=i(t,r)}return t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.idBlock=this.idBlock.toJSON(),e.lenBlock=this.lenBlock.toJSON(),e.valueBlock=this.valueBlock.toJSON(),"name"in this&&(e.name=this.name),"optional"in this&&(e.optional=this.optional),"primitiveSchema"in this&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}}class C extends A{constructor(e={}){super(e),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=t(e,"isHexOnly",!0)}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.warnings.push("Zero buffer length"),t;this.valueHex=new ArrayBuffer(n.length);const a=new Uint8Array(this.valueHex);for(let e=0;e<n.length;e++)a[e]=n[e];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e.isHexOnly=this.isHexOnly,e}}class x extends S{constructor(e={}){super(e,C),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}class N extends A{constructor(e={}){super(e),this.value=t(e,"value",[]),this.isIndefiniteForm=t(e,"isIndefiniteForm",!1)}fromBER(e,t,r){const n=t,a=r;if(!1===s(this,e,t,r))return-1;const i=new Uint8Array(e,t,r);if(0===i.length)return this.warnings.push("Zero buffer length"),t;function o(e,t){return!0===e?1:t}let l=t;for(;o(this.isIndefiniteForm,r)>0;){const t=pe(e,l,r);if(-1===t.offset)return this.error=t.result.error,this.warnings.concat(t.result.warnings),-1;if(l=t.offset,this.blockLength+=t.result.blockLength,r-=t.result.blockLength,this.value.push(t.result),!0===this.isIndefiniteForm&&t.result.constructor.blockName()===P.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===P.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=e.slice(n,n+a),l}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){t=i(t,this.value[r].toBER(e))}return t}static blockName(){return"ConstructedValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.isIndefiniteForm=this.isIndefiniteForm,e.value=[];for(let t=0;t<this.value.length;t++)e.value.push(this.value[t].toJSON());return e}}class E extends S{constructor(e={}){super(e,N),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}}class H extends A{constructor(e={}){super(e)}fromBER(e,t,r){return t}toBER(e=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class P extends S{constructor(e={}){super(e,H),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}class I extends A{constructor(e={}){if(super(e),this.value=t(e,"value",!1),this.isHexOnly=t(e,"isHexOnly",!1),"valueHex"in e)this.valueHex=e.valueHex.slice(0);else if(this.valueHex=new ArrayBuffer(1),!0===this.value){var r=new Uint8Array(this.valueHex);r[0]=255}}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.value=0!==n[0],this.isHexOnly=!0,this.valueHex=new ArrayBuffer(n.length);const a=new Uint8Array(this.valueHex);for(let e=0;e<n.length;e++)a[e]=n[e];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e.isHexOnly=this.isHexOnly,e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e}}class L extends S{constructor(e={}){super(e,I),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}class O extends E{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}class U extends E{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}class R extends S{constructor(e={}){super(e,b),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r}toBER(e=!1){const t=new ArrayBuffer(2);if(!0===e)return t;const r=new Uint8Array(t);return r[0]=5,r[1]=0,t}}class D extends(p(N)){constructor(e={}){super(e),this.isConstructed=t(e,"isConstructed",!1)}fromBER(e,t,r){let s=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,-1===(s=N.prototype.fromBER.call(this,e,t,r)))return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===P.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==V.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e=!1){if(!0===this.isConstructed)return N.prototype.toBER.call(this,e);let t=new ArrayBuffer(this.valueHex.byteLength);return!0===e?t:0===this.valueHex.byteLength?t:t=this.valueHex.slice(0)}static blockName(){return"OctetStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e}}class V extends S{constructor(e={}){super(e,D),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t):super.fromBER(e,t,r)}static blockName(){return"OctetString"}isEqual(e){return e instanceof V!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class j extends(p(N)){constructor(e={}){super(e),this.unusedBits=t(e,"unusedBits",0),this.isConstructed=t(e,"isConstructed",!1),this.blockLength=this.valueHex.byteLength+1}fromBER(e,t,r){if(0===r)return t;let n=-1;if(!0===this.isConstructed){if(-1===(n=N.prototype.fromBER.call(this,e,t,r)))return n;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===P.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==K.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[e].unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[e].unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return n}if(!1===s(this,e,t,r))return-1;const a=new Uint8Array(e,t,r);if(this.unusedBits=a[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(a.length-1);const i=new Uint8Array(this.valueHex);for(let e=0;e<r-1;e++)i[e]=a[e+1];return this.blockLength=a.length,t+r}toBER(e=!1){if(!0===this.isConstructed)return N.prototype.toBER.call(this,e);if(!0===e)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const t=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),s=new Uint8Array(r);s[0]=this.unusedBits;for(let e=0;e<this.valueHex.byteLength;e++)s[e+1]=t[e];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.unusedBits=this.unusedBits,e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e}}class K extends S{constructor(e={}){super(e,j),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(e,t,r){return 0===r?t:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r))}isEqual(e){return e instanceof K!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class J extends(p(A)){constructor(e={}){super(e),"value"in e&&(this.valueDec=e.value)}set valueHex(e){this._valueHex=e.slice(0),e.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,e.byteLength>0&&(this._valueDec=function(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&0==(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const s=n(r,8),a=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(a);for(let t=0;t<this.valueHex.byteLength;t++)i[t]=e[t];return i[0]&=127,n(i,8)-s}.call(this)))}get valueHex(){return this._valueHex}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this._valueHex=function(e){const t=e<0?-1*e:e;let r=128;for(let s=1;s<8;s++){if(t<=r){if(e<0){const e=a(r-t,8,s);return new Uint8Array(e)[0]|=128,e}let n=a(t,8,s),i=new Uint8Array(n);if(128&i[0]){const e=n.slice(0),t=new Uint8Array(e);n=new ArrayBuffer(n.byteLength+1),i=new Uint8Array(n);for(let r=0;r<e.byteLength;r++)i[r+1]=t[r];i[0]=0}return n}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(e)}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const n=this.fromBER(e,t,r);if(-1===n)return n;const a=new Uint8Array(this._valueHex);if(0===a[0]&&0!=(128&a[1])){const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}else if(0!==s&&this._valueHex.byteLength<s){s-this._valueHex.byteLength>1&&(s=this._valueHex.byteLength+1);const e=new ArrayBuffer(s);new Uint8Array(e).set(a,s-this._valueHex.byteLength),this._valueHex=e.slice(0)}return n}toDER(e=!1){const t=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&t[0]):{const e=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(e);r[0]=0,r.set(t,1),this._valueHex=e.slice(0)}break;case 0===t[0]&&0==(128&t[1]):{const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return-1===s?s:(this.blockLength=r,t+r)}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e}toString(){function e(e,t){const r=new Uint8Array([0]);let s=new Uint8Array(e),n=new Uint8Array(t),a=s.slice(0);const i=a.length-1;let l=n.slice(0);const c=l.length-1;let u=0;let h=0;for(let e=c<i?i:c;e>=0;e--,h++){switch(!0){case h<l.length:u=a[i-h]+l[c-h]+r[0];break;default:u=a[i-h]+r[0]}switch(r[0]=u/10,!0){case h>=a.length:a=o(new Uint8Array([u%10]),a);break;default:a[i-h]=u%10}}return r[0]>0&&(a=o(r,a)),a.slice(0)}function t(e){if(e>=v.length)for(let t=v.length;t<=e;t++){const e=new Uint8Array([0]);let r=v[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const s=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=s[0]/10,r[t]=s[0]%10}e[0]>0&&(r=o(e,r)),v.push(r)}return v[e]}function r(e,t){let r=0,s=new Uint8Array(e),n=new Uint8Array(t),a=s.slice(0);const i=a.length-1;let o=n.slice(0);const l=o.length-1;let c,u=0;for(let e=l;e>=0;e--,u++)switch(c=a[i-u]-o[l-u]-r,!0){case c<0:r=1,a[i-u]=c+10;break;default:r=0,a[i-u]=c}if(r>0)for(let e=i-l+1;e>=0;e--,u++){if(!((c=a[i-u]-r)<0)){r=0,a[i-u]=c;break}r=1,a[i-u]=c+10}return a.slice()}const s=8*this._valueHex.byteLength-1;let n,a=new Uint8Array(8*this._valueHex.byteLength/3),i=0;const l=new Uint8Array(this._valueHex);let c="",u=!1;for(let o=this._valueHex.byteLength-1;o>=0;o--){n=l[o];for(let o=0;o<8;o++){if(1==(1&n))switch(i){case s:a=r(t(i),a),c="-";break;default:a=e(a,t(i))}i++,n>>=1}}for(let e=0;e<a.length;e++)a[e]&&(u=!0),u&&(c+=k.charAt(a[e]));return!1===u&&(c+=k.charAt(0)),c}}class T extends S{constructor(e={}){super(e,J),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(e){return e instanceof T?this.valueBlock.isHexOnly&&e.valueBlock.isHexOnly?l(this.valueBlock.valueHex,e.valueBlock.valueHex):this.valueBlock.isHexOnly===e.valueBlock.isHexOnly&&this.valueBlock.valueDec===e.valueBlock.valueDec:e instanceof ArrayBuffer&&l(this.valueBlock.valueHex,e)}convertToDER(){const e=new T({valueHex:this.valueBlock.valueHex});return e.valueBlock.toDER(),e}convertFromDER(){const e=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,t=new T({valueHex:this.valueBlock.valueHex});return t.valueBlock.fromDER(t.valueBlock.valueHex,0,t.valueBlock.valueHex.byteLength,e),t}}class F extends T{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}class $ extends(p(b)){constructor(e={}){super(e),this.valueDec=t(e,"valueDec",-1),this.isFirstSid=t(e,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(e,t,r){if(0===r)return t;if(!1===s(this,e,t,r))return-1;const a=new Uint8Array(e,t,r);this.valueHex=new ArrayBuffer(r);let i=new Uint8Array(this.valueHex);for(let e=0;e<r&&(i[e]=127&a[e],this.blockLength++,0!=(128&a[e]));e++);const o=new ArrayBuffer(this.blockLength),l=new Uint8Array(o);for(let e=0;e<this.blockLength;e++)l[e]=i[e];return this.valueHex=o.slice(0),i=new Uint8Array(this.valueHex),0!=(128&a[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===i[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=n(i,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|s[e];return r[this.blockLength-1]=s[this.blockLength-1],t}const s=a(this.valueDec,7);if(0===s.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength),!1===e){const e=new Uint8Array(s);r=new Uint8Array(t);for(let t=0;t<s.byteLength-1;t++)r[t]=128|e[t];r[s.byteLength-1]=e[s.byteLength-1]}return t}toString(){let e="";if(!0===this.isHexOnly)e=r(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e.isFirstSid=this.isFirstSid,e}}class M extends A{constructor(e={}){super(e),this.fromString(t(e,"value",""))}fromBER(e,t,r){let s=t;for(;r>0;){const t=new $;if(-1===(s=t.fromBER(e,s,r)))return this.blockLength=0,this.error=t.error,s;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(0===s.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=i(t,s)}return t}fromString(e){this.value=[];let t=0,r=0,s="",n=!1;do{if(s=-1===(r=e.indexOf(".",t))?e.substr(t):e.substr(t,r-t),t=r+1,n){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return this.value=[],!1}const r=parseInt(s,10);if(isNaN(r))return!0;e.valueDec=r+t,n=!1}else{const e=new $;if(e.valueDec=parseInt(s,10),isNaN(e.valueDec))return!0;0===this.value.length&&(e.isFirstSid=!0,n=!0),this.value.push(e)}}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e=`${e}.`),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.value=this.toString(),e.sidArray=[];for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}class _ extends S{constructor(e={}){super(e,M),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}class q extends(p(b)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class W extends S{constructor(e={}){super(e,q),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(e){const t=unescape(encodeURIComponent(e)),r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r);const s=new Uint8Array(this.valueBlock.valueHex);for(let e=0;e<r;e++)s[e]=t.charCodeAt(e);this.valueBlock.value=e}}class G extends(p(b)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class Q extends S{constructor(e={}){super(e,G),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=2){const t=r[e];r[e]=r[e+1],r[e+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(2*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=a(e.charCodeAt(s),8),n=new Uint8Array(t);if(n.length>2)continue;const i=2-n.length;for(let e=n.length-1;e>=0;e--)r[2*s+e+i]=n[e]}this.valueBlock.value=e}}class z extends(p(b)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class Z extends S{constructor(e={}){super(e,z),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(4*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=a(e.charCodeAt(s),8),n=new Uint8Array(t);if(n.length>4)continue;const i=4-n.length;for(let e=n.length-1;e>=0;e--)r[4*s+e+i]=n[e]}this.valueBlock.value=e}}class Y extends(p(b)){constructor(e={}){super(e),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class X extends S{constructor(e={}){super(e,Y),"value"in e&&this.fromString(e.value)}static blockName(){return"SIMPLESTRING"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}class ee extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}class te extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}class re extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}class se extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}class ne extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}class ae extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}class ie extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}class oe extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}class le extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}class ce extends ie{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi,r=t.exec(e);if(null===r)return void(this.error="Wrong input string for convertion");const s=parseInt(r[1],10);this.year=s>=50?1900+s:2e3+s,this.month=parseInt(r[2],10),this.day=parseInt(r[3],10),this.hour=parseInt(r[4],10),this.minute=parseInt(r[5],10),this.second=parseInt(r[6],10)}toString(){const e=new Array(7);return e[0]=c(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=c(this.month,2),e[2]=c(this.day,2),e[3]=c(this.hour,2),e[4]=c(this.minute,2),e[5]=c(this.second,2),e[6]="Z",e.join("")}static blockName(){return"UTCTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e}}class ue extends ie{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,s="",n="",a=0,i=0,o=0;if("Z"===e[e.length-1])s=e.substr(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");s=e}if(r){if(-1!==s.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==s.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let e=1,t=s.indexOf("+"),r="";if(-1===t&&(t=s.indexOf("-"),e=-1),-1!==t){if(r=s.substr(t+1),s=s.substr(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let n=new Number(r.substr(0,2));if(isNaN(n.valueOf()))throw new Error("Wrong input string for convertion");if(i=e*n,4===r.length){if(n=new Number(r.substr(2,2)),isNaN(n.valueOf()))throw new Error("Wrong input string for convertion");o=e*n}}}let l=s.indexOf(".");if(-1===l&&(l=s.indexOf(",")),-1!==l){const e=new Number(`0${s.substr(l)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");a=e.valueOf(),n=s.substr(0,l)}else n=s;switch(!0){case 8===n.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==l)throw new Error("Wrong input string for convertion");break;case 10===n.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*a;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===n.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*a;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===n.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){const e=1e3*a;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for convertion")}const c=t.exec(n);if(null===c)throw new Error("Wrong input string for convertion");for(let e=1;e<c.length;e++)switch(e){case 1:this.year=parseInt(c[e],10);break;case 2:this.month=parseInt(c[e],10);break;case 3:this.day=parseInt(c[e],10);break;case 4:this.hour=parseInt(c[e],10)+i;break;case 5:this.minute=parseInt(c[e],10)+o;break;case 6:this.second=parseInt(c[e],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(){const e=[];return e.push(c(this.year,4)),e.push(c(this.month,2)),e.push(c(this.day,2)),e.push(c(this.hour,2)),e.push(c(this.minute,2)),e.push(c(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(c(this.millisecond,3))),e.push("Z"),e.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e.millisecond=this.millisecond,e}}class he extends W{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}class me extends W{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}class fe extends W{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}class ge extends W{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}class de extends W{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}class ye{constructor(e={}){this.value=t(e,"value",[]),this.optional=t(e,"optional",!1)}}class ve{constructor(e={}){this.name=t(e,"name",""),this.optional=t(e,"optional",!1)}}class ke{constructor(e={}){this.name=t(e,"name",""),this.optional=t(e,"optional",!1),this.value=t(e,"value",new ve),this.local=t(e,"local",!1)}}class be{constructor(e={}){this.data=t(e,"data",new ArrayBuffer(0))}fromBER(e,t,r){this.data=e.slice(t,r)}toBER(e=!1){return this.data}}function pe(e,t,r){const n=t;let a=new S({},Object);if(!1===s(new b,e,t,r))return a.error="Wrong input parameters",{offset:-1,result:a};if(0===new Uint8Array(e,t,r).length)return this.error="Zero buffer length",{offset:-1,result:a};let i=a.idBlock.fromBER(e,t,r);if(a.warnings.concat(a.idBlock.warnings),-1===i)return a.error=a.idBlock.error,{offset:-1,result:a};if(t=i,r-=a.idBlock.blockLength,i=a.lenBlock.fromBER(e,t,r),a.warnings.concat(a.lenBlock.warnings),-1===i)return a.error=a.lenBlock.error,{offset:-1,result:a};if(t=i,r-=a.lenBlock.blockLength,!1===a.idBlock.isConstructed&&!0===a.lenBlock.isIndefiniteForm)return a.error="Indefinite length form used for primitive encoding form",{offset:-1,result:a};let o=S;switch(a.idBlock.tagClass){case 1:if(a.idBlock.tagNumber>=37&&!1===a.idBlock.isHexOnly)return a.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:a};switch(a.idBlock.tagNumber){case 0:if(!0===a.idBlock.isConstructed&&a.lenBlock.length>0)return a.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:a};o=P;break;case 1:o=L;break;case 2:o=T;break;case 3:o=K;break;case 4:o=V;break;case 5:o=R;break;case 6:o=_;break;case 10:o=F;break;case 12:o=W;break;case 14:o=de;break;case 15:return a.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:a};case 16:o=O;break;case 17:o=U;break;case 18:o=ee;break;case 19:o=te;break;case 20:o=re;break;case 21:o=se;break;case 22:o=ne;break;case 23:o=ce;break;case 24:o=ue;break;case 25:o=ae;break;case 26:o=ie;break;case 27:o=oe;break;case 28:o=Z;break;case 29:o=le;break;case 30:o=Q;break;case 31:o=he;break;case 32:o=me;break;case 33:o=fe;break;case 34:o=ge;break;default:{let s;(s=!0===a.idBlock.isConstructed?new E:new x).idBlock=a.idBlock,s.lenBlock=a.lenBlock,s.warnings=a.warnings,i=(a=s).fromBER(e,t,r)}}break;case 2:case 3:case 4:default:o=!0===a.idBlock.isConstructed?E:x}return i=(a=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecode=e.valueBeforeDecode.slice(0),r}(a,o)).fromBER(e,t,!0===a.lenBlock.isIndefiniteForm?r:a.lenBlock.length),a.valueBeforeDecode=e.slice(n,n+a.blockLength),{offset:i,result:a}}function we(e){if(0===e.byteLength){const e=new S({},Object);return e.error="Input buffer has zero length",{offset:-1,result:e}}return pe(e,0,e.byteLength)}function Be(e,t,r){if(r instanceof ye){for(let s=0;s<r.value.length;s++){if(!0===Be(e,t,r.value[s]).verified)return{verified:!0,result:e}}{const e={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty("name")&&(e.name=r.name),e}}if(r instanceof ve)return r.hasOwnProperty("name")&&(e[r.name]=t),{verified:!0,result:e};if(e instanceof Object==!1)return{verified:!1,result:{error:"Wrong root object"}};if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=r.idBlock.toBER(!1);if(0===s.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(s,0,s.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==t.idBlock.tagClass)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==t.idBlock.tagNumber)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==t.idBlock.isConstructed)return{verified:!1,result:e};if("isHexOnly"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==t.idBlock.isHexOnly)return{verified:!1,result:e};if(!0===r.idBlock.isHexOnly){if("valueHex"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=new Uint8Array(r.idBlock.valueHex),n=new Uint8Array(t.idBlock.valueHex);if(s.length!==n.length)return{verified:!1,result:e};for(let t=0;t<s.length;t++)if(s[t]!==n[1])return{verified:!1,result:e}}if(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(e[r.name]=t)),!0===r.idBlock.isConstructed){let s=0,n={verified:!1},a=r.valueBlock.value.length;if(a>0&&r.valueBlock.value[0]instanceof ke&&(a=t.valueBlock.value.length),0===a)return{verified:!0,result:e};if(0===t.valueBlock.value.length&&0!==r.valueBlock.value.length){let t=!0;for(let e=0;e<r.valueBlock.value.length;e++)t=t&&(r.valueBlock.value[e].optional||!1);return!0===t?{verified:!0,result:e}:(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),e.error="Inconsistent object length",{verified:!1,result:e})}for(let i=0;i<a;i++)if(i-s>=t.valueBlock.value.length){if(!1===r.valueBlock.value[i].optional){const t={verified:!1,result:e};return e.error="Inconsistent length between ASN.1 data and schema",r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}}else if(r.valueBlock.value[0]instanceof ke){if(!1===(n=Be(e,t.valueBlock.value[i],r.valueBlock.value[0].value)).verified){if(!0!==r.valueBlock.value[0].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),n;s++}if("name"in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let s={};void 0===(s="local"in r.valueBlock.value[0]&&!0===r.valueBlock.value[0].local?t:e)[r.valueBlock.value[0].name]&&(s[r.valueBlock.value[0].name]=[]),s[r.valueBlock.value[0].name].push(t.valueBlock.value[i])}}else if(!1===(n=Be(e,t.valueBlock.value[i-s],r.valueBlock.value[i])).verified){if(!0!==r.valueBlock.value[i].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),n;s++}if(!1===n.verified){const t={verified:!1,result:e};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}return{verified:!0,result:e}}if("primitiveSchema"in r&&"valueHex"in t.valueBlock){const s=we(t.valueBlock.valueHex);if(-1===s.offset){const t={verified:!1,result:s.result};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}return Be(e,s.result,r.primitiveSchema)}return{verified:!0,result:e}}class Ae{constructor(e={}){this.algorithmId=t(e,"algorithmId",Ae.defaultValues("algorithmId")),"algorithmParams"in e&&(this.algorithmParams=t(e,"algorithmParams",Ae.defaultValues("algorithmParams"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"algorithmId":return"";case"algorithmParams":return new ve;default:throw new Error(`Invalid member name for AlgorithmIdentifier class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"algorithmId":return""===t;case"algorithmParams":return t instanceof ve;default:throw new Error(`Invalid member name for AlgorithmIdentifier class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",optional:r.optional||!1,value:[new _({name:r.algorithmIdentifier||""}),new ve({name:r.algorithmParams||"",optional:!0})]})}fromSchema(e){const t=Be(e,e,Ae.schema({names:{algorithmIdentifier:"algorithm",algorithmParams:"params"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier");this.algorithmId=t.result.algorithm.valueBlock.toString(),"params"in t.result&&(this.algorithmParams=t.result.params)}toSchema(){const e=[];return e.push(new _({value:this.algorithmId})),"algorithmParams"in this&&this.algorithmParams instanceof ve==!1&&e.push(this.algorithmParams),new O({value:e})}toJSON(){const e={algorithmId:this.algorithmId};return"algorithmParams"in this&&this.algorithmParams instanceof ve==!1&&(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof Ae!=!1&&(this.algorithmId===e.algorithmId&&("algorithmParams"in this?"algorithmParams"in e&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!("algorithmParams"in e)))}}class Se{constructor(e={}){this.x=t(e,"x",Se.defaultValues("x")),this.y=t(e,"y",Se.defaultValues("y")),this.namedCurve=t(e,"namedCurve",Se.defaultValues("namedCurve")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"x":case"y":return new ArrayBuffer(0);case"namedCurve":return"";default:throw new Error(`Invalid member name for ECCPublicKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"x":case"y":return l(t,Se.defaultValues(e));case"namedCurve":return""===t;default:throw new Error(`Invalid member name for ECCPublicKey class: ${e}`)}}static schema(e={}){return new be}fromSchema(e){if(e instanceof ArrayBuffer==!1)throw new Error("Object's schema was not verified against input data for ECPublicKey");const t=new Uint8Array(e);if(4!==t[0])throw new Error("Object's schema was not verified against input data for ECPublicKey");let r;switch(this.namedCurve){case"1.2.840.10045.3.1.7":r=32;break;case"1.3.132.0.34":r=48;break;case"1.3.132.0.35":r=66;break;default:throw new Error(`Incorrect curve OID: ${this.namedCurve}`)}if(e.byteLength!==2*r+1)throw new Error("Object's schema was not verified against input data for ECPublicKey");this.x=e.slice(1,r+1),this.y=e.slice(1+r,2*r+1)}toSchema(){return new be({data:i(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}return{crv:e,x:m(g(this.x),!0,!0,!1),y:m(g(this.y),!0,!0,!1)}}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("x"in e))throw new Error('Absent mandatory parameter "x"');{const r=d(f(e.x,!0));if(r.byteLength<t){this.x=new ArrayBuffer(t);const e=new Uint8Array(this.x),s=new Uint8Array(r);e.set(1,s)}else this.x=r.slice(0,t)}if(!("y"in e))throw new Error('Absent mandatory parameter "y"');{const r=d(f(e.y,!0));if(r.byteLength<t){this.y=new ArrayBuffer(t);const e=new Uint8Array(this.y),s=new Uint8Array(r);e.set(1,s)}else this.y=r.slice(0,t)}}}class Ce{constructor(e={}){this.modulus=t(e,"modulus",Ce.defaultValues("modulus")),this.publicExponent=t(e,"publicExponent",Ce.defaultValues("publicExponent")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"modulus":case"publicExponent":return new T;default:throw new Error(`Invalid member name for RSAPublicKey class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new T({name:r.modulus||""}),new T({name:r.publicExponent||""})]})}fromSchema(e){const t=Be(e,e,Ce.schema({names:{modulus:"modulus",publicExponent:"publicExponent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPublicKey");this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new O({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:m(g(this.modulus.valueBlock.valueHex),!0,!0,!0),e:m(g(this.publicExponent.valueBlock.valueHex),!0,!0,!0)}}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');{const t=d(f(e.n,!0));this.modulus=new T({valueHex:t.slice(0,Math.pow(2,function(e){const t=Math.log(e)/y,r=Math.floor(t),s=Math.round(t);return r===s?r:s}(t.byteLength)))})}if(!("e"in e))throw new Error('Absent mandatory parameter "e"');this.publicExponent=new T({valueHex:d(f(e.e,!0)).slice(0,3)})}}class xe{constructor(e={}){this.algorithm=t(e,"algorithm",xe.defaultValues("algorithm")),this.subjectPublicKey=t(e,"subjectPublicKey",xe.defaultValues("subjectPublicKey")),"parsedKey"in e&&(this.parsedKey=t(e,"parsedKey",xe.defaultValues("parsedKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"algorithm":return new Ae;case"subjectPublicKey":return new K;default:throw new Error(`Invalid member name for PublicKeyInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Ae.schema(r.algorithm||{}),new K({name:r.subjectPublicKey||""})]})}fromSchema(e){const t=Be(e,e,xe.schema({names:{algorithm:{names:{blockName:"algorithm"}},subjectPublicKey:"subjectPublicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PUBLIC_KEY_INFO");switch(this.algorithm=new Ae({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey,this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams instanceof _)try{this.parsedKey=new Se({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHex})}catch(e){}break;case"1.2.840.113549.1.1.1":{const e=we(this.subjectPublicKey.valueBlock.valueHex);if(-1!==e.offset)try{this.parsedKey=new Ce({schema:e.result})}catch(e){}}}}toSchema(){return new O({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if("parsedKey"in this==!1)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};const e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const r of Object.keys(t))e[r]=t[r];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new Se({json:e}),this.algorithm=new Ae({algorithmId:"1.2.840.10045.2.1",algorithmParams:new _({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Ce({json:e}),this.algorithm=new Ae({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new R});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.subjectPublicKey=new K({valueHex:this.parsedKey.toSchema().toBER(!1)})}}importKey(e){let t=Promise.resolve();const r=this;if(void 0===e)return Promise.reject("Need to provide publicKey input parameter");const s=je();return void 0===s?Promise.reject("Unable to create WebCrypto object"):t=(t=t.then(()=>s.exportKey("spki",e))).then(e=>{const t=we(e);try{r.fromSchema(t.result)}catch(e){return Promise.reject("Error during initializing object from schema")}},e=>Promise.reject(`Error during exporting public key: ${e}`))}}class Ne{constructor(e={}){this.type=t(e,"type",Ne.defaultValues("type")),this.values=t(e,"values",Ne.defaultValues("values")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return"";case"values":return[];default:throw new Error(`Invalid member name for Attribute class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"type":return""===t;case"values":return 0===t.length;default:throw new Error(`Invalid member name for Attribute class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new _({name:r.type||""}),new U({name:r.setName||"",value:[new ke({name:r.values||"",value:new ve})]})]})}fromSchema(e){const t=Be(e,e,Ne.schema({names:{type:"type",values:"values"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ATTRIBUTE");this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new O({value:[new _({value:this.type}),new U({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,e=>e.toJSON())}}}class Ee{constructor(e={}){this.version=t(e,"version",Ee.defaultValues("version")),this.privateKey=t(e,"privateKey",Ee.defaultValues("privateKey")),"namedCurve"in e&&(this.namedCurve=t(e,"namedCurve",Ee.defaultValues("namedCurve"))),"publicKey"in e&&(this.publicKey=t(e,"publicKey",Ee.defaultValues("publicKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 1;case"privateKey":return new V;case"namedCurve":return"";case"publicKey":return new Se;default:throw new Error(`Invalid member name for ECCPrivateKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return t===Ee.defaultValues(e);case"privateKey":return t.isEqual(Ee.defaultValues(e));case"namedCurve":return""===t;case"publicKey":return Se.compareWithDefault("namedCurve",t.namedCurve)&&Se.compareWithDefault("x",t.x)&&Se.compareWithDefault("y",t.y);default:throw new Error(`Invalid member name for ECCPrivateKey class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new T({name:r.version||""}),new V({name:r.privateKey||""}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new _({name:r.namedCurve||""})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new K({name:r.publicKey||""})]})]})}fromSchema(e){const t=Be(e,e,Ee.schema({names:{version:"version",privateKey:"privateKey",namedCurve:"namedCurve",publicKey:"publicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ECPrivateKey");if(this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,"namedCurve"in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),"publicKey"in t.result){const e={schema:t.result.publicKey.valueBlock.valueHex};"namedCurve"in this&&(e.namedCurve=this.namedCurve),this.publicKey=new Se(e)}}toSchema(){const e=[new T({value:this.version}),this.privateKey];return"namedCurve"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:[new _({value:this.namedCurve})]})),"publicKey"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:1},value:[new K({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new O({value:e})}toJSON(){if("namedCurve"in this==!1||Ee.compareWithDefault("namedCurve",this.namedCurve))throw new Error('Not enough information for making JSON: absent "namedCurve" value');let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}const t={crv:e,d:m(g(this.privateKey.valueBlock.valueHex),!0,!0,!1)};if("publicKey"in this){const e=this.publicKey.toJSON();t.x=e.x,t.y=e.y}return t}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("d"in e))throw new Error('Absent mandatory parameter "d"');{const r=d(f(e.d,!0));if(r.byteLength<t){const e=new ArrayBuffer(t),s=new Uint8Array(e),n=new Uint8Array(r);s.set(1,n),this.privateKey=new V({valueHex:e})}else this.privateKey=new V({valueHex:r.slice(0,t)})}"x"in e&&"y"in e&&(this.publicKey=new Se({json:e}))}}class He{constructor(e={}){this.prime=t(e,"prime",He.defaultValues("prime")),this.exponent=t(e,"exponent",He.defaultValues("exponent")),this.coefficient=t(e,"coefficient",He.defaultValues("coefficient")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"prime":case"exponent":case"coefficient":return new T;default:throw new Error(`Invalid member name for OtherPrimeInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new T({name:r.prime||""}),new T({name:r.exponent||""}),new T({name:r.coefficient||""})]})}fromSchema(e){const t=Be(e,e,He.schema({names:{prime:"prime",exponent:"exponent",coefficient:"coefficient"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherPrimeInfo");this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new O({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:m(g(this.prime.valueBlock.valueHex),!0,!0),d:m(g(this.exponent.valueBlock.valueHex),!0,!0),t:m(g(this.coefficient.valueBlock.valueHex),!0,!0)}}fromJSON(e){if(!("r"in e))throw new Error('Absent mandatory parameter "r"');if(this.prime=new T({valueHex:d(f(e.r,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.exponent=new T({valueHex:d(f(e.d,!0))}),!("t"in e))throw new Error('Absent mandatory parameter "t"');this.coefficient=new T({valueHex:d(f(e.t,!0))})}}class Pe{constructor(e={}){this.version=t(e,"version",Pe.defaultValues("version")),this.modulus=t(e,"modulus",Pe.defaultValues("modulus")),this.publicExponent=t(e,"publicExponent",Pe.defaultValues("publicExponent")),this.privateExponent=t(e,"privateExponent",Pe.defaultValues("privateExponent")),this.prime1=t(e,"prime1",Pe.defaultValues("prime1")),this.prime2=t(e,"prime2",Pe.defaultValues("prime2")),this.exponent1=t(e,"exponent1",Pe.defaultValues("exponent1")),this.exponent2=t(e,"exponent2",Pe.defaultValues("exponent2")),this.coefficient=t(e,"coefficient",Pe.defaultValues("coefficient")),"otherPrimeInfos"in e&&(this.otherPrimeInfos=t(e,"otherPrimeInfos",Pe.defaultValues("otherPrimeInfos"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 0;case"modulus":case"publicExponent":case"privateExponent":case"prime1":case"prime2":case"exponent1":case"exponent2":case"coefficient":return new T;case"otherPrimeInfos":return[];default:throw new Error(`Invalid member name for RSAPrivateKey class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new T({name:r.version||""}),new T({name:r.modulus||""}),new T({name:r.publicExponent||""}),new T({name:r.privateExponent||""}),new T({name:r.prime1||""}),new T({name:r.prime2||""}),new T({name:r.exponent1||""}),new T({name:r.exponent2||""}),new T({name:r.coefficient||""}),new O({optional:!0,value:[new ke({name:r.otherPrimeInfosName||"",value:He.schema(r.otherPrimeInfo||{})})]})]})}fromSchema(e){const t=Be(e,e,Pe.schema({names:{version:"version",modulus:"modulus",publicExponent:"publicExponent",privateExponent:"privateExponent",prime1:"prime1",prime2:"prime2",exponent1:"exponent1",exponent2:"exponent2",coefficient:"coefficient",otherPrimeInfo:{names:{blockName:"otherPrimeInfos"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPrivateKey");this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),"otherPrimeInfos"in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,e=>new He({schema:e})))}toSchema(){const e=[];return e.push(new T({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),"otherPrimeInfos"in this&&e.push(new O({value:Array.from(this.otherPrimeInfos,e=>e.toSchema())})),new O({value:e})}toJSON(){const e={n:m(g(this.modulus.valueBlock.valueHex),!0,!0,!0),e:m(g(this.publicExponent.valueBlock.valueHex),!0,!0,!0),d:m(g(this.privateExponent.valueBlock.valueHex),!0,!0,!0),p:m(g(this.prime1.valueBlock.valueHex),!0,!0,!0),q:m(g(this.prime2.valueBlock.valueHex),!0,!0,!0),dp:m(g(this.exponent1.valueBlock.valueHex),!0,!0,!0),dq:m(g(this.exponent2.valueBlock.valueHex),!0,!0,!0),qi:m(g(this.coefficient.valueBlock.valueHex),!0,!0,!0)};return"otherPrimeInfos"in this&&(e.oth=Array.from(this.otherPrimeInfos,e=>e.toJSON())),e}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');if(this.modulus=new T({valueHex:d(f(e.n,!0,!0))}),!("e"in e))throw new Error('Absent mandatory parameter "e"');if(this.publicExponent=new T({valueHex:d(f(e.e,!0,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.privateExponent=new T({valueHex:d(f(e.d,!0,!0))}),!("p"in e))throw new Error('Absent mandatory parameter "p"');if(this.prime1=new T({valueHex:d(f(e.p,!0,!0))}),!("q"in e))throw new Error('Absent mandatory parameter "q"');if(this.prime2=new T({valueHex:d(f(e.q,!0,!0))}),!("dp"in e))throw new Error('Absent mandatory parameter "dp"');if(this.exponent1=new T({valueHex:d(f(e.dp,!0,!0))}),!("dq"in e))throw new Error('Absent mandatory parameter "dq"');if(this.exponent2=new T({valueHex:d(f(e.dq,!0,!0))}),!("qi"in e))throw new Error('Absent mandatory parameter "qi"');this.coefficient=new T({valueHex:d(f(e.qi,!0,!0))}),"oth"in e&&(this.otherPrimeInfos=Array.from(e.oth,e=>new He({json:e})))}}class Ie{constructor(e={}){this.version=t(e,"version",Ie.defaultValues("version")),this.privateKeyAlgorithm=t(e,"privateKeyAlgorithm",Ie.defaultValues("privateKeyAlgorithm")),this.privateKey=t(e,"privateKey",Ie.defaultValues("privateKey")),"attributes"in e&&(this.attributes=t(e,"attributes",Ie.defaultValues("attributes"))),"parsedKey"in e&&(this.parsedKey=t(e,"parsedKey",Ie.defaultValues("parsedKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 0;case"privateKeyAlgorithm":return new Ae;case"privateKey":return new V;case"attributes":return[];default:throw new Error(`Invalid member name for PrivateKeyInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new T({name:r.version||""}),Ae.schema(r.privateKeyAlgorithm||{}),new V({name:r.privateKey||""}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ke({name:r.attributes||"",value:Ne.schema()})]})]})}fromSchema(e){const t=Be(e,e,Ie.schema({names:{version:"version",privateKeyAlgorithm:{names:{blockName:"privateKeyAlgorithm"}},privateKey:"privateKey",attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PKCS8");switch(this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new Ae({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,"attributes"in t.result&&(this.attributes=Array.from(t.result.attributes,e=>new Ne({schema:e}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{const e=we(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new Pe({schema:e.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof _){const e=we(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new Ee({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:e.result}))}}}toSchema(){const e=[new T({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return"attributes"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new O({value:e})}toJSON(){if("parsedKey"in this==!1){const e={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return"attributes"in this&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}const e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const r of Object.keys(t))e[r]=t[r];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new Ee({json:e}),this.privateKeyAlgorithm=new Ae({algorithmId:"1.2.840.10045.2.1",algorithmParams:new _({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Pe({json:e}),this.privateKeyAlgorithm=new Ae({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new R});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.privateKey=new V({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}class Le{constructor(e={}){if(this.contentType=t(e,"contentType",Le.defaultValues("contentType")),this.contentEncryptionAlgorithm=t(e,"contentEncryptionAlgorithm",Le.defaultValues("contentEncryptionAlgorithm")),"encryptedContent"in e&&(this.encryptedContent=e.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed)){const e=new V({idBlock:{isConstructed:!0},isConstructed:!0});let t=0,r=this.encryptedContent.valueBlock.valueHex.byteLength;for(;r>0;){const s=new Uint8Array(this.encryptedContent.valueBlock.valueHex,t,t+1024>this.encryptedContent.valueBlock.valueHex.byteLength?this.encryptedContent.valueBlock.valueHex.byteLength-t:1024),n=new ArrayBuffer(s.length),a=new Uint8Array(n);for(let e=0;e<a.length;e++)a[e]=s[e];e.valueBlock.value.push(new V({valueHex:n})),r-=s.length,t+=s.length}this.encryptedContent=e}"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"contentType":return"";case"contentEncryptionAlgorithm":return new Ae;case"encryptedContent":return new V;default:throw new Error(`Invalid member name for EncryptedContentInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"contentType":return""===t;case"contentEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"encryptedContent":return t.isEqual(Le.defaultValues(e));default:throw new Error(`Invalid member name for EncryptedContentInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new _({name:r.contentType||""}),Ae.schema(r.contentEncryptionAlgorithm||{}),new ye({value:[new E({name:r.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0},value:[new ke({value:new V})]}),new x({name:r.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){const t=Be(e,e,Le.schema({names:{contentType:"contentType",contentEncryptionAlgorithm:{names:{blockName:"contentEncryptionAlgorithm"}},encryptedContent:"encryptedContent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EncryptedContentInfo");this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new Ae({schema:t.result.contentEncryptionAlgorithm}),"encryptedContent"in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){const e={isIndefiniteForm:!1},t=[];if(t.push(new _({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),"encryptedContent"in this){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;const r=this.encryptedContent;r.idBlock.tagClass=3,r.idBlock.tagNumber=0,r.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(r)}return new O({lenBlock:e,value:t})}toJSON(){const e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return"encryptedContent"in this&&(e.encryptedContent=this.encryptedContent.toJSON()),e}}class Oe{constructor(e={}){this.hashAlgorithm=t(e,"hashAlgorithm",Oe.defaultValues("hashAlgorithm")),this.maskGenAlgorithm=t(e,"maskGenAlgorithm",Oe.defaultValues("maskGenAlgorithm")),this.saltLength=t(e,"saltLength",Oe.defaultValues("saltLength")),this.trailerField=t(e,"trailerField",Oe.defaultValues("trailerField")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new Ae({algorithmId:"1.3.14.3.2.26",algorithmParams:new R});case"maskGenAlgorithm":return new Ae({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new Ae({algorithmId:"1.3.14.3.2.26",algorithmParams:new R}).toSchema()});case"saltLength":return 20;case"trailerField":return 1;default:throw new Error(`Invalid member name for RSASSAPSSParams class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new E({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[Ae.schema(r.hashAlgorithm||{})]}),new E({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[Ae.schema(r.maskGenAlgorithm||{})]}),new E({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new T({name:r.saltLength||""})]}),new E({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new T({name:r.trailerField||""})]})]})}fromSchema(e){const t=Be(e,e,Oe.schema({names:{hashAlgorithm:{names:{blockName:"hashAlgorithm"}},maskGenAlgorithm:{names:{blockName:"maskGenAlgorithm"}},saltLength:"saltLength",trailerField:"trailerField"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSASSA_PSS_params");"hashAlgorithm"in t.result&&(this.hashAlgorithm=new Ae({schema:t.result.hashAlgorithm})),"maskGenAlgorithm"in t.result&&(this.maskGenAlgorithm=new Ae({schema:t.result.maskGenAlgorithm})),"saltLength"in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),"trailerField"in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){const e=[];return this.hashAlgorithm.isEqual(Oe.defaultValues("hashAlgorithm"))||e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(Oe.defaultValues("maskGenAlgorithm"))||e.push(new E({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==Oe.defaultValues("saltLength")&&e.push(new E({idBlock:{tagClass:3,tagNumber:2},value:[new T({value:this.saltLength})]})),this.trailerField!==Oe.defaultValues("trailerField")&&e.push(new E({idBlock:{tagClass:3,tagNumber:3},value:[new T({value:this.trailerField})]})),new O({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(Oe.defaultValues("hashAlgorithm"))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(Oe.defaultValues("maskGenAlgorithm"))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==Oe.defaultValues("saltLength")&&(e.saltLength=this.saltLength),this.trailerField!==Oe.defaultValues("trailerField")&&(e.trailerField=this.trailerField),e}}class Ue{constructor(e={}){this.salt=t(e,"salt",Ue.defaultValues("salt")),this.iterationCount=t(e,"iterationCount",Ue.defaultValues("iterationCount")),"keyLength"in e&&(this.keyLength=t(e,"keyLength",Ue.defaultValues("keyLength"))),"prf"in e&&(this.prf=t(e,"prf",Ue.defaultValues("prf"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"salt":return{};case"iterationCount":return-1;case"keyLength":return 0;case"prf":return new Ae({algorithmId:"1.3.14.3.2.26",algorithmParams:new R});default:throw new Error(`Invalid member name for PBKDF2Params class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ye({value:[new V({name:r.saltPrimitive||""}),Ae.schema(r.saltConstructed||{})]}),new T({name:r.iterationCount||""}),new T({name:r.keyLength||"",optional:!0}),Ae.schema(r.prf||{names:{optional:!0}})]})}fromSchema(e){const t=Be(e,e,Ue.schema({names:{saltPrimitive:"salt",saltConstructed:{names:{blockName:"salt"}},iterationCount:"iterationCount",keyLength:"keyLength",prf:{names:{blockName:"prf",optional:!0}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBKDF2_params");this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,"keyLength"in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),"prf"in t.result&&(this.prf=new Ae({schema:t.result.prf}))}toSchema(){const e=[];return e.push(this.salt),e.push(new T({value:this.iterationCount})),"keyLength"in this&&Ue.defaultValues("keyLength")!==this.keyLength&&e.push(new T({value:this.keyLength})),"prf"in this&&!1===Ue.defaultValues("prf").isEqual(this.prf)&&e.push(this.prf.toSchema()),new O({value:e})}toJSON(){const e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return"keyLength"in this&&Ue.defaultValues("keyLength")!==this.keyLength&&(e.keyLength=this.keyLength),"prf"in this&&!1===Ue.defaultValues("prf").isEqual(this.prf)&&(e.prf=this.prf.toJSON()),e}}class Re{constructor(e={}){this.keyDerivationFunc=t(e,"keyDerivationFunc",Re.defaultValues("keyDerivationFunc")),this.encryptionScheme=t(e,"encryptionScheme",Re.defaultValues("encryptionScheme")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyDerivationFunc":case"encryptionScheme":return new Ae;default:throw new Error(`Invalid member name for PBES2Params class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Ae.schema(r.keyDerivationFunc||{}),Ae.schema(r.encryptionScheme||{})]})}fromSchema(e){const t=Be(e,e,Re.schema({names:{keyDerivationFunc:{names:{blockName:"keyDerivationFunc"}},encryptionScheme:{names:{blockName:"encryptionScheme"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBES2_params");this.keyDerivationFunc=new Ae({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new Ae({schema:t.result.encryptionScheme})}toSchema(){return new O({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}function De(e,t,r,s,n,a){let i,o;const l=[];switch(t.toUpperCase()){case"SHA-1":i=20,o=64;break;case"SHA-256":i=32,o=64;break;case"SHA-384":i=48,o=128;break;case"SHA-512":i=64,o=128;break;default:throw new Error("Unsupported hashing algorithm")}const c=new Uint8Array(s),u=new ArrayBuffer(2*s.byteLength+2),h=new Uint8Array(u);for(let e=0;e<c.length;e++)h[2*e]=0,h[2*e+1]=c[e];h[h.length-2]=0,h[h.length-1]=0,s=u.slice(0);const m=new ArrayBuffer(o),f=new Uint8Array(m);for(let e=0;e<m.byteLength;e++)f[e]=3;const g=n.byteLength,d=o*Math.ceil(g/o),y=new ArrayBuffer(d),v=new Uint8Array(y),k=new Uint8Array(n);for(let e=0;e<d;e++)v[e]=k[e%g];const b=s.byteLength,p=o*Math.ceil(b/o),w=new ArrayBuffer(p),B=new Uint8Array(w),A=new Uint8Array(s);for(let e=0;e<p;e++)B[e]=A[e%b];const S=y.byteLength+w.byteLength;let C=new ArrayBuffer(S),x=new Uint8Array(C);x.set(v),x.set(B,v.length);const N=Math.ceil((r>>3)/i);let E=Promise.resolve(C);for(let r=0;r<=N;r++){E=E.then(e=>{const t=new ArrayBuffer(m.byteLength+e.byteLength),r=new Uint8Array(t);return r.set(f),r.set(x,f.length),t});for(let r=0;r<a;r++)E=E.then(r=>e.digest({name:t},new Uint8Array(r)));E=E.then(e=>{const t=new ArrayBuffer(o),r=new Uint8Array(t);for(let s=0;s<t.byteLength;s++)r[s]=e[s%e.length];const s=Math.ceil(g/o)+Math.ceil(b/o),n=[];let a=0,i=o;for(let e=0;e<s;e++){const e=Array.from(new Uint8Array(C.slice(a,a+i)));(a+=o)+o>C.byteLength&&(i=C.byteLength-a);let s=511;for(let n=t.byteLength-1;n>=0;n--)s>>=8,s+=r[n]+e[n],e[n]=255&s;n.push(...e)}return C=new ArrayBuffer(n.length),(x=new Uint8Array(C)).set(n),l.push(...new Uint8Array(e)),C})}return E=E.then(()=>{const e=new ArrayBuffer(r>>3);return new Uint8Array(e).set(new Uint8Array(l).slice(0,r>>3)),e})}let Ve={name:"none",crypto:null,subtle:null};!function(){if("undefined"!=typeof self&&"crypto"in self){let e="webcrypto";const r=self.crypto;let s=null;if("webkitSubtle"in self.crypto){try{s=self.crypto.webkitSubtle}catch(e){s=self.crypto.subtle}e="safari"}"subtle"in self.crypto&&(s=self.crypto.subtle),Ve={name:e,crypto:r,subtle:new class{constructor(e={}){this.crypto=t(e,"crypto",{}),this.subtle=t(e,"subtle",{}),this.name=t(e,"name","")}importKey(e,t,r,s,n){let a={};switch(t instanceof Uint8Array&&(t=t.buffer),e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,r,s,n);case"spki":{const e=we(t);if(-1===e.offset)return Promise.reject("Incorrect keyData");const i=new xe;try{i.fromSchema(e.result)}catch(e){return Promise.reject("Incorrect keyData")}switch(r.name.toUpperCase()){case"RSA-PSS":switch(r.hash.name.toUpperCase()){case"SHA-1":a.alg="PS1";break;case"SHA-256":a.alg="PS256";break;case"SHA-384":a.alg="PS384";break;case"SHA-512":a.alg="PS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(n=["verify"],a.kty="RSA",a.ext=s,a.key_ops=n,"1.2.840.113549.1.1.1"!==i.algorithm.algorithmId)return Promise.reject(`Incorrect public key algorithm: ${i.algorithm.algorithmId}`);if("alg"in a==0)switch(r.hash.name.toUpperCase()){case"SHA-1":a.alg="RS1";break;case"SHA-256":a.alg="RS256";break;case"SHA-384":a.alg="RS384";break;case"SHA-512":a.alg="RS512";break;default:return Promise.reject(`Incorrect public key algorithm: ${i.algorithm.algorithmId}`)}const e=i.toJSON();for(const t of Object.keys(e))a[t]=e[t]}break;case"ECDSA":n=["verify"];case"ECDH":{if(a={kty:"EC",ext:s,key_ops:n},"1.2.840.10045.2.1"!==i.algorithm.algorithmId)return Promise.reject(`Incorrect public key algorithm: ${i.algorithm.algorithmId}`);const e=i.toJSON();for(const t of Object.keys(e))a[t]=e[t]}break;case"RSA-OAEP":{if(a.kty="RSA",a.ext=s,a.key_ops=n,"safari"===this.name.toLowerCase())a.alg="RSA-OAEP";else switch(r.hash.name.toUpperCase()){case"SHA-1":a.alg="RSA-OAEP-1";break;case"SHA-256":a.alg="RSA-OAEP-256";break;case"SHA-384":a.alg="RSA-OAEP-384";break;case"SHA-512":a.alg="RSA-OAEP-512";break;default:return Promise.reject(`Incorrect public key algorithm: ${i.algorithm.algorithmId}`)}const e=i.toJSON();for(const t of Object.keys(e))a[t]=e[t]}break;default:return Promise.reject(`Incorrect algorithm name: ${r.name.toUpperCase()}`)}}break;case"pkcs8":{const e=new Ie,i=we(t);if(-1===i.offset)return Promise.reject("Incorrect keyData");try{e.fromSchema(i.result)}catch(e){return Promise.reject("Incorrect keyData")}switch(r.name.toUpperCase()){case"RSA-PSS":switch(r.hash.name.toUpperCase()){case"SHA-1":a.alg="PS1";break;case"SHA-256":a.alg="PS256";break;case"SHA-384":a.alg="PS384";break;case"SHA-512":a.alg="PS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(n=["sign"],a.kty="RSA",a.ext=s,a.key_ops=n,"1.2.840.113549.1.1.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject(`Incorrect private key algorithm: ${e.privateKeyAlgorithm.algorithmId}`);if("alg"in a==0)switch(r.hash.name.toUpperCase()){case"SHA-1":a.alg="RS1";break;case"SHA-256":a.alg="RS256";break;case"SHA-384":a.alg="RS384";break;case"SHA-512":a.alg="RS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}const t=e.toJSON();for(const e of Object.keys(t))a[e]=t[e]}break;case"ECDSA":n=["sign"];case"ECDH":{if(a={kty:"EC",ext:s,key_ops:n},"1.2.840.10045.2.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject(`Incorrect algorithm: ${e.privateKeyAlgorithm.algorithmId}`);const t=e.toJSON();for(const e of Object.keys(t))a[e]=t[e]}break;case"RSA-OAEP":{if(a.kty="RSA",a.ext=s,a.key_ops=n,"safari"===this.name.toLowerCase())a.alg="RSA-OAEP";else switch(r.hash.name.toUpperCase()){case"SHA-1":a.alg="RSA-OAEP-1";break;case"SHA-256":a.alg="RSA-OAEP-256";break;case"SHA-384":a.alg="RSA-OAEP-384";break;case"SHA-512":a.alg="RSA-OAEP-512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}const t=e.toJSON();for(const e of Object.keys(t))a[e]=t[e]}break;default:return Promise.reject(`Incorrect algorithm name: ${r.name.toUpperCase()}`)}}break;case"jwk":a=t;break;default:return Promise.reject(`Incorrect format: ${e}`)}return"safari"===this.name.toLowerCase()?Promise.resolve().then(()=>this.subtle.importKey("jwk",d(JSON.stringify(a)),r,s,n)).then(e=>e,e=>this.subtle.importKey("jwk",a,r,s,n)):this.subtle.importKey("jwk",a,r,s,n)}exportKey(e,t){let r=this.subtle.exportKey("jwk",t);switch("safari"===this.name.toLowerCase()&&(r=r.then(e=>e instanceof ArrayBuffer?JSON.parse(g(e)):e)),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":r=r.then(e=>{const t=new xe;try{t.fromJSON(e)}catch(e){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"pkcs8":r=r.then(e=>{const t=new Ie;try{t.fromJSON(e)}catch(e){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"jwk":break;default:return Promise.reject(`Incorrect format: ${e}`)}return r}convert(e,t,r,s,n,a){switch(e.toLowerCase()){case"raw":switch(t.toLowerCase()){case"raw":return Promise.resolve(r);case"spki":return Promise.resolve().then(()=>this.importKey("raw",r,s,n,a)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("raw",r,s,n,a)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve().then(()=>this.importKey("raw",r,s,n,a)).then(e=>this.exportKey("jwk",e));default:return Promise.reject(`Incorrect outputFormat: ${t}`)}case"spki":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("spki",r,s,n,a)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve(r);case"pkcs8":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"jwk":return Promise.resolve().then(()=>this.importKey("spki",r,s,n,a)).then(e=>this.exportKey("jwk",e));default:return Promise.reject(`Incorrect outputFormat: ${t}`)}case"pkcs8":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("pkcs8",r,s,n,a)).then(e=>this.exportKey("raw",e));case"spki":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"pkcs8":return Promise.resolve(r);case"jwk":return Promise.resolve().then(()=>this.importKey("pkcs8",r,s,n,a)).then(e=>this.exportKey("jwk",e));default:return Promise.reject(`Incorrect outputFormat: ${t}`)}case"jwk":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("jwk",r,s,n,a)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve().then(()=>this.importKey("jwk",r,s,n,a)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("jwk",r,s,n,a)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve(r);default:return Promise.reject(`Incorrect outputFormat: ${t}`)}default:return Promise.reject(`Incorrect inputFormat: ${e}`)}}encrypt(...e){return this.subtle.encrypt(...e)}decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}verify(...e){return this.subtle.verify(...e)}digest(...e){return this.subtle.digest(...e)}generateKey(...e){return this.subtle.generateKey(...e)}deriveKey(...e){return this.subtle.deriveKey(...e)}deriveBits(...e){return this.subtle.deriveBits(...e)}wrapKey(...e){return this.subtle.wrapKey(...e)}unwrapKey(...e){return this.subtle.unwrapKey(...e)}getRandomValues(e){if("getRandomValues"in this.crypto==0)throw new Error("No support for getRandomValues");return this.crypto.getRandomValues(e)}getAlgorithmByOID(e){switch(e){case"1.2.840.113549.1.1.1":case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}return{}}getOIDByAlgorithm(e){let t="";switch(e.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.1.1.5";break;case"SHA-256":t="1.2.840.113549.1.1.11";break;case"SHA-384":t="1.2.840.113549.1.1.12";break;case"SHA-512":t="1.2.840.113549.1.1.13"}break;case"RSA-PSS":t="1.2.840.113549.1.1.10";break;case"RSA-OAEP":t="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.10045.4.1";break;case"SHA-256":t="1.2.840.10045.4.3.2";break;case"SHA-384":t="1.2.840.10045.4.3.3";break;case"SHA-512":t="1.2.840.10045.4.3.4"}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":t="1.3.133.16.840.63.0.2";break;case"SHA-256":t="1.3.132.1.11.1";break;case"SHA-384":t="1.3.132.1.11.2";break;case"SHA-512":t="1.3.132.1.11.3"}break;case"AES-CTR":break;case"AES-CBC":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.2";break;case 192:t="2.16.840.1.101.3.4.1.22";break;case 256:t="2.16.840.1.101.3.4.1.42"}break;case"AES-CMAC":break;case"AES-GCM":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.6";break;case 192:t="2.16.840.1.101.3.4.1.26";break;case 256:t="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.4";break;case 192:t="2.16.840.1.101.3.4.1.24";break;case 256:t="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.5";break;case 192:t="2.16.840.1.101.3.4.1.25";break;case 256:t="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.2.7";break;case"SHA-256":t="1.2.840.113549.2.9";break;case"SHA-384":t="1.2.840.113549.2.10";break;case"SHA-512":t="1.2.840.113549.2.11"}break;case"DH":t="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":t="1.3.14.3.2.26";break;case"SHA-256":t="2.16.840.1.101.3.4.2.1";break;case"SHA-384":t="2.16.840.1.101.3.4.2.2";break;case"SHA-512":t="2.16.840.1.101.3.4.2.3";break;case"CONCAT":case"HKDF":break;case"PBKDF2":t="1.2.840.113549.1.5.12";break;case"P-256":t="1.2.840.10045.3.1.7";break;case"P-384":t="1.3.132.0.34";break;case"P-521":t="1.3.132.0.35"}return t}getAlgorithmParameters(e,t){let r={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":r={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":r={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":r={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":r={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;case"exportkey":default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":r={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":r={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":r={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":r={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":switch(t.toLowerCase()){case"derivekey":r={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"HKDF"},usages:[]}}break;case"PBKDF2":switch(t.toLowerCase()){case"derivekey":r={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"PBKDF2"},usages:[]}}}return r}getHashAlgorithm(e){let t="";switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{const r=new Oe({schema:e.algorithmParams});if("hashAlgorithm"in r){const e=this.getAlgorithmByOID(r.hashAlgorithm.algorithmId);if("name"in e==0)return"";t=e.name}else t="SHA-1"}catch(e){}}return t}encryptEncryptedContentInfo(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("contentEncryptionAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "contentEncryptionAlgorithm"');if("hmacHashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hmacHashAlgorithm"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("contentToEncrypt"in e==0)return Promise.reject('Absent mandatory parameter "contentToEncrypt"');if("contentType"in e==0)return Promise.reject('Absent mandatory parameter "contentType"');const t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm);if(""===t)return Promise.reject('Wrong "contentEncryptionAlgorithm" value');const r=this.getOIDByAlgorithm({name:"PBKDF2"});if(""===r)return Promise.reject("Can not find OID for PBKDF2");const s=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}});if(""===s)return Promise.reject(`Incorrect value for "hmacHashAlgorithm": ${e.hmacHashAlgorithm}`);let n=Promise.resolve();const a=new ArrayBuffer(16),i=new Uint8Array(a);this.getRandomValues(i);const o=new ArrayBuffer(64),l=new Uint8Array(o);this.getRandomValues(l);const c=new Uint8Array(e.contentToEncrypt),u=new Ue({salt:new V({valueHex:o}),iterationCount:e.iterationCount,prf:new Ae({algorithmId:s,algorithmParams:new R})});return n=(n=(n=(n=n.then(()=>{const t=new Uint8Array(e.password);return this.importKey("raw",t,"PBKDF2",!1,["deriveKey"])},e=>Promise.reject(e))).then(t=>this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:l,iterations:e.iterationCount},t,e.contentEncryptionAlgorithm,!1,["encrypt"]),e=>Promise.reject(e))).then(t=>this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:i},t,c),e=>Promise.reject(e))).then(s=>{const n=new Re({keyDerivationFunc:new Ae({algorithmId:r,algorithmParams:u.toSchema()}),encryptionScheme:new Ae({algorithmId:t,algorithmParams:new V({valueHex:a})})});return new Le({contentType:e.contentType,contentEncryptionAlgorithm:new Ae({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:n.toSchema()}),encryptedContent:new V({valueHex:s})})},e=>Promise.reject(e))}decryptEncryptedContentInfo(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("encryptedContentInfo"in e==0)return Promise.reject('Absent mandatory parameter "encryptedContentInfo"');if("1.2.840.113549.1.5.13"!==e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)return Promise.reject(`Unknown "contentEncryptionAlgorithm": ${e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);let t,r=Promise.resolve();try{t=new Re({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(e){return Promise.reject('Incorrectly encoded "pbes2Parameters"')}let s;try{s=new Ue({schema:t.keyDerivationFunc.algorithmParams})}catch(e){return Promise.reject('Incorrectly encoded "pbkdf2Params"')}const n=this.getAlgorithmByOID(t.encryptionScheme.algorithmId);if("name"in n==0)return Promise.reject(`Incorrect OID for "contentEncryptionAlgorithm": ${t.encryptionScheme.algorithmId}`);const a=t.encryptionScheme.algorithmParams.valueBlock.valueHex,o=new Uint8Array(a),l=s.salt.valueBlock.valueHex,c=new Uint8Array(l),u=s.iterationCount;let h="SHA-1";if("prf"in s){const e=this.getAlgorithmByOID(s.prf.algorithmId);if("name"in e==0)return Promise.reject("Incorrect OID for HMAC hash algorithm");h=e.hash.name}return r=(r=(r=r.then(()=>this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),e=>Promise.reject(e))).then(e=>this.deriveKey({name:"PBKDF2",hash:{name:h},salt:c,iterations:u},e,n,!1,["decrypt"]),e=>Promise.reject(e))).then(t=>{let r=new ArrayBuffer(0);if(!1===e.encryptedContentInfo.encryptedContent.idBlock.isConstructed)r=e.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else for(const t of e.encryptedContentInfo.encryptedContent.valueBlock.value)r=i(r,t.valueBlock.valueHex);return this.decrypt({name:n.name,iv:o},t,r)},e=>Promise.reject(e))}stampDataWithPassword(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToStamp"in e==0)return Promise.reject('Absent mandatory parameter "contentToStamp"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let r=Promise.resolve();const s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return r=(r=(r=r.then(()=>De(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount))).then(e=>this.importKey("raw",new Uint8Array(e),s,!1,["sign"]))).then(t=>this.sign(s,t,new Uint8Array(e.contentToStamp)),e=>Promise.reject(e))}verifyDataStampedWithPassword(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToVerify"in e==0)return Promise.reject('Absent mandatory parameter "contentToVerify"');if("signatureToVerify"in e==0)return Promise.reject('Absent mandatory parameter "signatureToVerify"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let r=Promise.resolve();const s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return r=(r=(r=r.then(()=>De(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount))).then(e=>this.importKey("raw",new Uint8Array(e),s,!1,["verify"]))).then(t=>this.verify(s,t,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify)),e=>Promise.reject(e))}getSignatureParameters(e,t="SHA-1"){const r=this.getOIDByAlgorithm({name:t});if(""===r)return Promise.reject(`Unsupported hash algorithm: ${t}`);const s=new Ae,n=this.getAlgorithmParameters(e.algorithm.name,"sign");switch(n.algorithm.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":s.algorithmId=this.getOIDByAlgorithm(n.algorithm);break;case"RSA-PSS":{switch(t.toUpperCase()){case"SHA-256":n.algorithm.saltLength=32;break;case"SHA-384":n.algorithm.saltLength=48;break;case"SHA-512":n.algorithm.saltLength=64}const e={};if("SHA-1"!==t.toUpperCase()){const r=this.getOIDByAlgorithm({name:t});if(""===r)return Promise.reject(`Unsupported hash algorithm: ${t}`);e.hashAlgorithm=new Ae({algorithmId:r,algorithmParams:new R}),e.maskGenAlgorithm=new Ae({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:e.hashAlgorithm.toSchema()})}20!==n.algorithm.saltLength&&(e.saltLength=n.algorithm.saltLength);const r=new Oe(e);s.algorithmId="1.2.840.113549.1.1.10",s.algorithmParams=r.toSchema()}break;default:return Promise.reject(`Unsupported signature algorithm: ${e.algorithm.name}`)}return Promise.resolve().then(()=>({signatureAlgorithm:s,parameters:n}))}signWithPrivateKey(e,t,r){return this.sign(r.algorithm,t,new Uint8Array(e)).then(e=>("ECDSA"===r.algorithm.name&&(e=function(e){if(e.byteLength%2!=0)return new ArrayBuffer(0);const t=e.byteLength/2,r=new ArrayBuffer(t);new Uint8Array(r).set(new Uint8Array(e,0,t));const s=new T({valueHex:r}),n=new ArrayBuffer(t);new Uint8Array(n).set(new Uint8Array(e,t,t));const a=new T({valueHex:n});return new O({value:[s.convertToDER(),a.convertToDER()]}).toBER(!1)}(e)),e),e=>Promise.reject(`Signing error: ${e}`))}verifyWithPublicKey(e,t,r,s){let n=Promise.resolve();const a=this.getHashAlgorithm(s);return""===a?Promise.reject(`Unsupported signature algorithm: ${s.algorithmId}`):n=(n=n.then(()=>{const e=this.getAlgorithmByOID(s.algorithmId);if("name"in e==="")return Promise.reject(`Unsupported public key algorithm: ${s.algorithmId}`);const t=this.getAlgorithmParameters(e.name,"importkey");if("hash"in t.algorithm&&(t.algorithm.hash.name=a),"ECDSA"===e.name){let e=!1;if("algorithmParams"in r.algorithm==1&&"idBlock"in r.algorithm.algorithmParams&&1===r.algorithm.algorithmParams.idBlock.tagClass&&6===r.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)return Promise.reject("Incorrect type for ECDSA public key parameters");const s=this.getAlgorithmByOID(r.algorithm.algorithmParams.valueBlock.toString());if("name"in s==0)return Promise.reject(`Unsupported named curve algorithm: ${r.algorithm.algorithmParams.valueBlock.toString()}`);t.algorithm.namedCurve=s.name}const n=r.toSchema().toBER(!1),i=new Uint8Array(n);return this.importKey("spki",i,t.algorithm,!0,t.usages)})).then(r=>{const n=this.getAlgorithmParameters(r.algorithm.name,"verify");"hash"in n.algorithm&&(n.algorithm.hash.name=a);let i=t.valueBlock.valueHex;if("ECDSA"===r.algorithm.name&&(i=Te(we(i).result)),"RSA-PSS"===r.algorithm.name){let e;try{e=new Oe({schema:s.algorithmParams})}catch(e){return Promise.reject(e)}n.algorithm.saltLength="saltLength"in e?e.saltLength:20;let t="SHA-1";if("hashAlgorithm"in e){const r=this.getAlgorithmByOID(e.hashAlgorithm.algorithmId);if("name"in r==0)return Promise.reject(`Unrecognized hash algorithm: ${e.hashAlgorithm.algorithmId}`);t=r.name}n.algorithm.hash.name=t}return this.verify(n.algorithm,r,new Uint8Array(i),new Uint8Array(e))})}}({name:e,crypto:self.crypto,subtle:s})}}}();function je(){if(null!==Ve.subtle)return Ve.subtle}function Ke(e,t){return Ve.subtle.getAlgorithmParameters(e,t)}function Je(e){let t=!1,r="";const s=e.trim();for(let e=0;e<s.length;e++)32===s.charCodeAt(e)?!1===t&&(t=!0):(t&&(r+=" ",t=!1),r+=s[e]);return r.toLowerCase()}function Te(e){if(e instanceof O==!1)return new ArrayBuffer(0);if(2!==e.valueBlock.value.length)return new ArrayBuffer(0);if(e.valueBlock.value[0]instanceof T==!1)return new ArrayBuffer(0);if(e.valueBlock.value[1]instanceof T==!1)return new ArrayBuffer(0);const t=e.valueBlock.value[0].convertFromDER(),r=e.valueBlock.value[1].convertFromDER();switch(!0){case t.valueBlock.valueHex.byteLength<r.valueBlock.valueHex.byteLength:{if(r.valueBlock.valueHex.byteLength-t.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=r.valueBlock.valueHex.byteLength,s=new Uint8Array(t.valueBlock.valueHex),n=new ArrayBuffer(e),a=new Uint8Array(n);return a.set(s,1),a[0]=0,i(n,r.valueBlock.valueHex)}case t.valueBlock.valueHex.byteLength>r.valueBlock.valueHex.byteLength:{if(t.valueBlock.valueHex.byteLength-r.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=t.valueBlock.valueHex.byteLength,s=new Uint8Array(r.valueBlock.valueHex),n=new ArrayBuffer(e),a=new Uint8Array(n);return a.set(s,1),a[0]=0,i(t.valueBlock.valueHex,n)}default:if(t.valueBlock.valueHex.byteLength%2){const e=t.valueBlock.valueHex.byteLength+1,s=new Uint8Array(t.valueBlock.valueHex),n=new ArrayBuffer(e),a=new Uint8Array(n);a.set(s,1),a[0]=0;const o=new Uint8Array(r.valueBlock.valueHex),l=new ArrayBuffer(e),c=new Uint8Array(l);return c.set(o,1),c[0]=0,i(n,l)}}return i(t.valueBlock.valueHex,r.valueBlock.valueHex)}function Fe(e){return Ve.subtle.getAlgorithmByOID(e)}function $e(e){return Ve.subtle.getHashAlgorithm(e)}class Me{constructor(e={}){this.type=t(e,"type",Me.defaultValues("type")),this.value=t(e,"value",Me.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return"";case"value":return{};default:throw new Error(`Invalid member name for AttributeTypeAndValue class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new _({name:r.type||""}),new ve({name:r.value||""})]})}fromSchema(e){const t=Be(e,e,Me.schema({names:{type:"type",value:"typeValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ATTR_TYPE_AND_VALUE");this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new O({value:[new _({value:this.type}),this.value]})}toJSON(){const e={type:this.type};return 0!==Object.keys(this.value).length?e.value=this.value.toJSON():e.value=this.value,e}isEqual(e){if(e instanceof Me){if(this.type!==e.type)return!1;if(this.value instanceof W&&e.value instanceof W||this.value instanceof Q&&e.value instanceof Q||this.value instanceof Z&&e.value instanceof Z||this.value instanceof ee&&e.value instanceof ee||this.value instanceof te&&e.value instanceof te||this.value instanceof re&&e.value instanceof re||this.value instanceof se&&e.value instanceof se||this.value instanceof ne&&e.value instanceof ne||this.value instanceof ae&&e.value instanceof ae||this.value instanceof ie&&e.value instanceof ie||this.value instanceof oe&&e.value instanceof oe||this.value instanceof le&&e.value instanceof le){const t=Je(this.value.valueBlock.value),r=Je(e.value.valueBlock.value);if(0!==t.localeCompare(r))return!1}else if(!1===l(this.value.valueBeforeDecode,e.value.valueBeforeDecode))return!1;return!0}return e instanceof ArrayBuffer&&l(this.value.valueBeforeDecode,e)}}class _e{constructor(e={}){this.typesAndValues=t(e,"typesAndValues",_e.defaultValues("typesAndValues")),this.valueBeforeDecode=t(e,"valueBeforeDecode",_e.defaultValues("valueBeforeDecode")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"typesAndValues":return[];case"valueBeforeDecode":return new ArrayBuffer(0);default:throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"typesAndValues":return 0===t.length;case"valueBeforeDecode":return 0===t.byteLength;default:throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ke({name:r.repeatedSequence||"",value:new U({value:[new ke({name:r.repeatedSet||"",value:Me.schema(r.typeAndValue||{})})]})})]})}fromSchema(e){const t=Be(e,e,_e.schema({names:{blockName:"RDN",repeatedSet:"typesAndValues"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RDN");"typesAndValues"in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,e=>new Me({schema:e}))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecode}toSchema(){if(0===this.valueBeforeDecode.byteLength)return new O({value:[new U({value:Array.from(this.typesAndValues,e=>e.toSchema())})]});const e=we(this.valueBeforeDecode);return e.result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,e=>e.toJSON())}}isEqual(e){if(e instanceof _e){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(const[t,r]of this.typesAndValues.entries())if(!1===r.isEqual(e.typesAndValues[t]))return!1;return!0}return e instanceof ArrayBuffer&&l(this.valueBeforeDecode,e)}}class qe{constructor(e={}){this.type=t(e,"type",qe.defaultValues("type")),this.value=t(e,"value",qe.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return 9;case"value":return{};default:throw new Error(`Invalid member name for GeneralName class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"type":return t===qe.defaultValues(e);case"value":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for GeneralName class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new ye({value:[new E({idBlock:{tagClass:3,tagNumber:0},name:r.blockName||"",value:[new _,new E({idBlock:{tagClass:3,tagNumber:0},value:[new ve]})]}),new x({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:1}}),new x({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:2}}),new E({idBlock:{tagClass:3,tagNumber:3},name:r.blockName||"",value:[function(e={},r=!1){const s=t(e,"names",{});return new O({optional:r,value:[new E({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:s.country_name||"",value:[new ye({value:[new ee,new te]})]}),new E({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:s.administration_domain_name||"",value:[new ye({value:[new ee,new te]})]}),new x({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:s.network_address||"",isHexOnly:!0}),new x({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:s.terminal_identifier||"",isHexOnly:!0}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:s.private_domain_name||"",value:[new ye({value:[new ee,new te]})]}),new x({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:s.organization_name||"",isHexOnly:!0}),new x({optional:!0,name:s.numeric_user_identifier||"",idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new E({optional:!0,name:s.personal_name||"",idBlock:{tagClass:3,tagNumber:5},value:[new x({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new x({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new x({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new x({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new E({optional:!0,name:s.organizational_unit_names||"",idBlock:{tagClass:3,tagNumber:6},value:[new ke({value:new te})]})]})}(r.builtInStandardAttributes||{},!1),function(e=!1){return new O({optional:e,value:[new te,new te]})}(!0),function(e=!1){return new U({optional:e,value:[new x({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ve]})]})}(!0)]}),new E({idBlock:{tagClass:3,tagNumber:4},name:r.blockName||"",value:[_e.schema(r.directoryName||{})]}),new E({idBlock:{tagClass:3,tagNumber:5},name:r.blockName||"",value:[new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ye({value:[new re,new te,new Z,new W,new Q]})]}),new E({idBlock:{tagClass:3,tagNumber:1},value:[new ye({value:[new re,new te,new Z,new W,new Q]})]})]}),new x({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:6}}),new x({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:7}}),new x({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){const t=Be(e,e,qe.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GENERAL_NAME");switch(this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:this.value=t.result.blockName;break;case 1:case 2:case 6:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=22;const r=e.toBER(!1);this.value=we(r).result.valueBlock.value}break;case 3:this.value=t.result.blockName;break;case 4:this.value=new _e({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new V({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=6;const r=e.toBER(!1);this.value=we(r).result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new E({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{const e=new ne({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new E({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{const e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{const e=new _({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return qe.schema()}}toJSON(){const e={type:this.type};return"string"==typeof this.value?e.value=this.value:e.value=this.value.toJSON(),e}}class We{constructor(e={}){this.accessMethod=t(e,"accessMethod",We.defaultValues("accessMethod")),this.accessLocation=t(e,"accessLocation",We.defaultValues("accessLocation")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"accessMethod":return"";case"accessLocation":return new qe;default:throw new Error(`Invalid member name for AccessDescription class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new _({name:r.accessMethod||""}),qe.schema(r.accessLocation||{})]})}fromSchema(e){const t=Be(e,e,We.schema({names:{accessMethod:"accessMethod",accessLocation:{names:{blockName:"accessLocation"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AccessDescription");this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new qe({schema:t.result.accessLocation})}toSchema(){return new O({value:[new _({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}class Ge{constructor(e={}){this.altNames=t(e,"altNames",Ge.defaultValues("altNames")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"altNames":return[];default:throw new Error(`Invalid member name for AltName class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ke({name:r.altNames||"",value:qe.schema()})]})}fromSchema(e){const t=Be(e,e,Ge.schema({names:{altNames:"altNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AltName");"altNames"in t.result&&(this.altNames=Array.from(t.result.altNames,e=>new qe({schema:e})))}toSchema(){return new O({value:Array.from(this.altNames,e=>e.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,e=>e.toJSON())}}}class Qe{constructor(e={}){this.attributes=t(e,"attributes",Qe.defaultValues("attributes")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"attributes":return[];default:throw new Error(`Invalid member name for SubjectDirectoryAttributes class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ke({name:r.attributes||"",value:Ne.schema()})]})}fromSchema(e){const t=Be(e,e,Qe.schema({names:{attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SubjectDirectoryAttributes");this.attributes=Array.from(t.result.attributes,e=>new Ne({schema:e}))}toSchema(){return new O({value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,e=>e.toJSON())}}}class ze{constructor(e={}){"notBefore"in e&&(this.notBefore=t(e,"notBefore",ze.defaultValues("notBefore"))),"notAfter"in e&&(this.notAfter=t(e,"notAfter",ze.defaultValues("notAfter"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"notBefore":case"notAfter":return new Date;default:throw new Error(`Invalid member name for PrivateKeyUsagePeriod class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new x({name:r.notBefore||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new x({name:r.notAfter||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){const t=Be(e,e,ze.schema({names:{notBefore:"notBefore",notAfter:"notAfter"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyUsagePeriod");if("notBefore"in t.result){const e=new ue;e.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=e.toDate()}if("notAfter"in t.result){const e=new ue({valueHex:t.result.notAfter.valueBlock.valueHex});e.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=e.toDate()}}toSchema(){const e=[];return"notBefore"in this&&e.push(new x({idBlock:{tagClass:3,tagNumber:0},valueHex:new ue({valueDate:this.notBefore}).valueBlock.valueHex})),"notAfter"in this&&e.push(new x({idBlock:{tagClass:3,tagNumber:1},valueHex:new ue({valueDate:this.notAfter}).valueBlock.valueHex})),new O({value:e})}toJSON(){const e={};return"notBefore"in this&&(e.notBefore=this.notBefore),"notAfter"in this&&(e.notAfter=this.notAfter),e}}class Ze{constructor(e={}){this.cA=t(e,"cA",!1),"pathLenConstraint"in e&&(this.pathLenConstraint=t(e,"pathLenConstraint",0)),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"cA":return!1;default:throw new Error(`Invalid member name for BasicConstraints class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new L({optional:!0,name:r.cA||""}),new T({optional:!0,name:r.pathLenConstraint||""})]})}fromSchema(e){const t=Be(e,e,Ze.schema({names:{cA:"cA",pathLenConstraint:"pathLenConstraint"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for BasicConstraints");"cA"in t.result&&(this.cA=t.result.cA.valueBlock.value),"pathLenConstraint"in t.result&&(t.result.pathLenConstraint.valueBlock.isHexOnly?this.pathLenConstraint=t.result.pathLenConstraint:this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){const e=[];return this.cA!==Ze.defaultValues("cA")&&e.push(new L({value:this.cA})),"pathLenConstraint"in this&&(this.pathLenConstraint instanceof T?e.push(this.pathLenConstraint):e.push(new T({value:this.pathLenConstraint}))),new O({value:e})}toJSON(){const e={};return this.cA!==Ze.defaultValues("cA")&&(e.cA=this.cA),"pathLenConstraint"in this&&(this.pathLenConstraint instanceof T?e.pathLenConstraint=this.pathLenConstraint.toJSON():e.pathLenConstraint=this.pathLenConstraint),e}}class Ye{constructor(e={}){"distributionPoint"in e&&(this.distributionPoint=t(e,"distributionPoint",Ye.defaultValues("distributionPoint"))),this.onlyContainsUserCerts=t(e,"onlyContainsUserCerts",Ye.defaultValues("onlyContainsUserCerts")),this.onlyContainsCACerts=t(e,"onlyContainsCACerts",Ye.defaultValues("onlyContainsCACerts")),"onlySomeReasons"in e&&(this.onlySomeReasons=t(e,"onlySomeReasons",Ye.defaultValues("onlySomeReasons"))),this.indirectCRL=t(e,"indirectCRL",Ye.defaultValues("indirectCRL")),this.onlyContainsAttributeCerts=t(e,"onlyContainsAttributeCerts",Ye.defaultValues("onlyContainsAttributeCerts")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"onlyContainsUserCerts":case"onlyContainsCACerts":return!1;case"onlySomeReasons":return 0;case"indirectCRL":case"onlyContainsAttributeCerts":return!1;default:throw new Error(`Invalid member name for IssuingDistributionPoint class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ye({value:[new E({name:r.distributionPoint||"",idBlock:{tagClass:3,tagNumber:0},value:[new ke({name:r.distributionPointNames||"",value:qe.schema()})]}),new E({name:r.distributionPoint||"",idBlock:{tagClass:3,tagNumber:1},value:_e.schema().valueBlock.value})]})]}),new x({name:r.onlyContainsUserCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new x({name:r.onlyContainsCACerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new x({name:r.onlySomeReasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new x({name:r.indirectCRL||"",optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new x({name:r.onlyContainsAttributeCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){const t=Be(e,e,Ye.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",onlyContainsUserCerts:"onlyContainsUserCerts",onlyContainsCACerts:"onlyContainsCACerts",onlySomeReasons:"onlySomeReasons",indirectCRL:"indirectCRL",onlyContainsAttributeCerts:"onlyContainsAttributeCerts"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for IssuingDistributionPoint");if("distributionPoint"in t.result)switch(!0){case 0===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new qe({schema:e}));break;case 1===t.result.distributionPoint.idBlock.tagNumber:t.result.distributionPoint.idBlock.tagClass=1,t.result.distributionPoint.idBlock.tagNumber=16,this.distributionPoint=new _e({schema:t.result.distributionPoint});break;default:throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if("onlyContainsUserCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==e[0]}if("onlyContainsCACerts"in t.result){const e=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==e[0]}if("onlySomeReasons"in t.result){const e=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=e[0]}if("indirectCRL"in t.result){const e=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==e[0]}if("onlyContainsAttributeCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==e[0]}}toSchema(){const e=[];if("distributionPoint"in this){let t;this.distributionPoint instanceof Array?t=new E({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):((t=this.distributionPoint.toSchema()).idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(t)}if(this.onlyContainsUserCerts!==Ye.defaultValues("onlyContainsUserCerts")&&e.push(new x({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==Ye.defaultValues("onlyContainsCACerts")&&e.push(new x({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),"onlySomeReasons"in this){const t=new ArrayBuffer(1);new Uint8Array(t)[0]=this.onlySomeReasons,e.push(new x({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==Ye.defaultValues("indirectCRL")&&e.push(new x({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==Ye.defaultValues("onlyContainsAttributeCerts")&&e.push(new x({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new O({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==Ye.defaultValues("onlyContainsUserCerts")&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==Ye.defaultValues("onlyContainsCACerts")&&(e.onlyContainsCACerts=this.onlyContainsCACerts),"onlySomeReasons"in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==Ye.defaultValues("indirectCRL")&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==Ye.defaultValues("onlyContainsAttributeCerts")&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}}class Xe{constructor(e={}){this.names=t(e,"names",Xe.defaultValues("names")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"names":return[];default:throw new Error(`Invalid member name for GeneralNames class: ${e}`)}}static schema(e={},r=!1){const s=t(e,"names",{});return new O({optional:r,name:s.blockName||"",value:[new ke({name:s.generalNames||"",value:qe.schema()})]})}fromSchema(e){const t=Be(e,e,Xe.schema({names:{blockName:"names",generalNames:"generalNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralNames");this.names=Array.from(t.result.generalNames,e=>new qe({schema:e}))}toSchema(){return new O({value:Array.from(this.names,e=>e.toSchema())})}toJSON(){return{names:Array.from(this.names,e=>e.toJSON())}}}class et{constructor(e={}){this.base=t(e,"base",et.defaultValues("base")),this.minimum=t(e,"minimum",et.defaultValues("minimum")),"maximum"in e&&(this.maximum=t(e,"maximum",et.defaultValues("maximum"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"base":return new qe;case"minimum":case"maximum":return 0;default:throw new Error(`Invalid member name for GeneralSubtree class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[qe.schema(r.base||{}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new T({name:r.minimum||""})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new T({name:r.maximum||""})]})]})}fromSchema(e){const t=Be(e,e,et.schema({names:{base:{names:{blockName:"base"}},minimum:"minimum",maximum:"maximum"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ");this.base=new qe({schema:t.result.base}),"minimum"in t.result&&(t.result.minimum.valueBlock.isHexOnly?this.minimum=t.result.minimum:this.minimum=t.result.minimum.valueBlock.valueDec),"maximum"in t.result&&(t.result.maximum.valueBlock.isHexOnly?this.maximum=t.result.maximum:this.maximum=t.result.maximum.valueBlock.valueDec)}toSchema(){const e=[];if(e.push(this.base.toSchema()),0!==this.minimum){let t=0;t=this.minimum instanceof T?this.minimum:new T({value:this.minimum}),e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if("maximum"in this){let t=0;t=this.maximum instanceof T?this.maximum:new T({value:this.maximum}),e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new O({value:e})}toJSON(){const e={base:this.base.toJSON()};return 0!==this.minimum&&("number"==typeof this.minimum?e.minimum=this.minimum:e.minimum=this.minimum.toJSON()),"maximum"in this&&("number"==typeof this.maximum?e.maximum=this.maximum:e.maximum=this.maximum.toJSON()),e}}class tt{constructor(e={}){"permittedSubtrees"in e&&(this.permittedSubtrees=t(e,"permittedSubtrees",tt.defaultValues("permittedSubtrees"))),"excludedSubtrees"in e&&(this.excludedSubtrees=t(e,"excludedSubtrees",tt.defaultValues("excludedSubtrees"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"permittedSubtrees":case"excludedSubtrees":return[];default:throw new Error(`Invalid member name for NameConstraints class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ke({name:r.permittedSubtrees||"",value:et.schema()})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ke({name:r.excludedSubtrees||"",value:et.schema()})]})]})}fromSchema(e){const t=Be(e,e,tt.schema({names:{permittedSubtrees:"permittedSubtrees",excludedSubtrees:"excludedSubtrees"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for NameConstraints");"permittedSubtrees"in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,e=>new et({schema:e}))),"excludedSubtrees"in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,e=>new et({schema:e})))}toSchema(){const e=[];return"permittedSubtrees"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new O({value:Array.from(this.permittedSubtrees,e=>e.toSchema())})]})),"excludedSubtrees"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new O({value:Array.from(this.excludedSubtrees,e=>e.toSchema())})]})),new O({value:e})}toJSON(){const e={};return"permittedSubtrees"in this&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,e=>e.toJSON())),"excludedSubtrees"in this&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,e=>e.toJSON())),e}}class rt{constructor(e={}){"distributionPoint"in e&&(this.distributionPoint=t(e,"distributionPoint",rt.defaultValues("distributionPoint"))),"reasons"in e&&(this.reasons=t(e,"reasons",rt.defaultValues("reasons"))),"cRLIssuer"in e&&(this.cRLIssuer=t(e,"cRLIssuer",rt.defaultValues("cRLIssuer"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"reasons":return new K;case"cRLIssuer":return[];default:throw new Error(`Invalid member name for DistributionPoint class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ye({value:[new E({name:r.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ke({name:r.distributionPointNames||"",value:qe.schema()})]}),new E({name:r.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:_e.schema().valueBlock.value})]})]}),new x({name:r.reasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new E({name:r.cRLIssuer||"",optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new ke({name:r.cRLIssuerNames||"",value:qe.schema()})]})]})}fromSchema(e){const t=Be(e,e,rt.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",reasons:"reasons",cRLIssuer:"cRLIssuer",cRLIssuerNames:"cRLIssuerNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for DistributionPoint");"distributionPoint"in t.result&&(0===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new qe({schema:e}))),1===t.result.distributionPoint.idBlock.tagNumber&&(t.result.distributionPoint.idBlock.tagClass=1,t.result.distributionPoint.idBlock.tagNumber=16,this.distributionPoint=new _e({schema:t.result.distributionPoint}))),"reasons"in t.result&&(this.reasons=new K({valueHex:t.result.reasons.valueBlock.valueHex})),"cRLIssuer"in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,e=>new qe({schema:e})))}toSchema(){const e=[];if("distributionPoint"in this){let t;t=this.distributionPoint instanceof Array?new E({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):new E({idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return"reasons"in this&&e.push(new x({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHex})),"cRLIssuer"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,e=>e.toSchema())})),new O({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),"reasons"in this&&(e.reasons=this.reasons.toJSON()),"cRLIssuer"in this&&(e.cRLIssuer=Array.from(this.cRLIssuer,e=>e.toJSON())),e}}class st{constructor(e={}){this.distributionPoints=t(e,"distributionPoints",st.defaultValues("distributionPoints")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoints":return[];default:throw new Error(`Invalid member name for CRLDistributionPoints class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ke({name:r.distributionPoints||"",value:rt.schema()})]})}fromSchema(e){const t=Be(e,e,st.schema({names:{distributionPoints:"distributionPoints"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CRLDistributionPoints");this.distributionPoints=Array.from(t.result.distributionPoints,e=>new rt({schema:e}))}toSchema(){return new O({value:Array.from(this.distributionPoints,e=>e.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,e=>e.toJSON())}}}class nt{constructor(e={}){this.policyQualifierId=t(e,"policyQualifierId",nt.defaultValues("policyQualifierId")),this.qualifier=t(e,"qualifier",nt.defaultValues("qualifier")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"policyQualifierId":return"";case"qualifier":return new ve;default:throw new Error(`Invalid member name for PolicyQualifierInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new _({name:r.policyQualifierId||""}),new ve({name:r.qualifier||""})]})}fromSchema(e){const t=Be(e,e,nt.schema({names:{policyQualifierId:"policyQualifierId",qualifier:"qualifier"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyQualifierInfo");this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new O({value:[new _({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}class at{constructor(e={}){this.policyIdentifier=t(e,"policyIdentifier",at.defaultValues("policyIdentifier")),"policyQualifiers"in e&&(this.policyQualifiers=t(e,"policyQualifiers",at.defaultValues("policyQualifiers"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"policyIdentifier":return"";case"policyQualifiers":return[];default:throw new Error(`Invalid member name for PolicyInformation class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new _({name:r.policyIdentifier||""}),new O({optional:!0,value:[new ke({name:r.policyQualifiers||"",value:nt.schema()})]})]})}fromSchema(e){const t=Be(e,e,at.schema({names:{policyIdentifier:"policyIdentifier",policyQualifiers:"policyQualifiers"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyInformation");this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),"policyQualifiers"in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,e=>new nt({schema:e})))}toSchema(){const e=[];return e.push(new _({value:this.policyIdentifier})),"policyQualifiers"in this&&e.push(new O({value:Array.from(this.policyQualifiers,e=>e.toSchema())})),new O({value:e})}toJSON(){const e={policyIdentifier:this.policyIdentifier};return"policyQualifiers"in this&&(e.policyQualifiers=Array.from(this.policyQualifiers,e=>e.toJSON())),e}}class it{constructor(e={}){this.certificatePolicies=t(e,"certificatePolicies",it.defaultValues("certificatePolicies")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certificatePolicies":return[];default:throw new Error(`Invalid member name for CertificatePolicies class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ke({name:r.certificatePolicies||"",value:at.schema()})]})}fromSchema(e){const t=Be(e,e,it.schema({names:{certificatePolicies:"certificatePolicies"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificatePolicies");this.certificatePolicies=Array.from(t.result.certificatePolicies,e=>new at({schema:e}))}toSchema(){return new O({value:Array.from(this.certificatePolicies,e=>e.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,e=>e.toJSON())}}}class ot{constructor(e={}){this.issuerDomainPolicy=t(e,"issuerDomainPolicy",ot.defaultValues("issuerDomainPolicy")),this.subjectDomainPolicy=t(e,"subjectDomainPolicy",ot.defaultValues("subjectDomainPolicy")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"issuerDomainPolicy":case"subjectDomainPolicy":return"";default:throw new Error(`Invalid member name for PolicyMapping class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new _({name:r.issuerDomainPolicy||""}),new _({name:r.subjectDomainPolicy||""})]})}fromSchema(e){const t=Be(e,e,ot.schema({names:{issuerDomainPolicy:"issuerDomainPolicy",subjectDomainPolicy:"subjectDomainPolicy"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMapping");this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new O({value:[new _({value:this.issuerDomainPolicy}),new _({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}class lt{constructor(e={}){this.mappings=t(e,"mappings",lt.defaultValues("mappings")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"mappings":return[];default:throw new Error(`Invalid member name for PolicyMappings class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ke({name:r.mappings||"",value:ot.schema()})]})}fromSchema(e){const t=Be(e,e,lt.schema({names:{mappings:"mappings"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMappings");this.mappings=Array.from(t.result.mappings,e=>new ot({schema:e}))}toSchema(){return new O({value:Array.from(this.mappings,e=>e.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,e=>e.toJSON())}}}class ct{constructor(e={}){"keyIdentifier"in e&&(this.keyIdentifier=t(e,"keyIdentifier",ct.defaultValues("keyIdentifier"))),"authorityCertIssuer"in e&&(this.authorityCertIssuer=t(e,"authorityCertIssuer",ct.defaultValues("authorityCertIssuer"))),"authorityCertSerialNumber"in e&&(this.authorityCertSerialNumber=t(e,"authorityCertSerialNumber",ct.defaultValues("authorityCertSerialNumber"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyIdentifier":return new V;case"authorityCertIssuer":return[];case"authorityCertSerialNumber":return new T;default:throw new Error(`Invalid member name for AuthorityKeyIdentifier class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new x({name:r.keyIdentifier||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ke({name:r.authorityCertIssuer||"",value:qe.schema()})]}),new x({name:r.authorityCertSerialNumber||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){const t=Be(e,e,ct.schema({names:{keyIdentifier:"keyIdentifier",authorityCertIssuer:"authorityCertIssuer",authorityCertSerialNumber:"authorityCertSerialNumber"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AuthorityKeyIdentifier");"keyIdentifier"in t.result&&(this.keyIdentifier=new V({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,e=>new qe({schema:e}))),"authorityCertSerialNumber"in t.result&&(this.authorityCertSerialNumber=new T({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){const e=[];if("keyIdentifier"in this){const t=this.keyIdentifier;t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if("authorityCertIssuer"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,e=>e.toSchema())})),"authorityCertSerialNumber"in this){const t=this.authorityCertSerialNumber;t.idBlock.tagClass=3,t.idBlock.tagNumber=2,e.push(t)}return new O({value:e})}toJSON(){const e={};return"keyIdentifier"in this&&(e.keyIdentifier=this.keyIdentifier.toJSON()),"authorityCertIssuer"in this&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,e=>e.toJSON())),"authorityCertSerialNumber"in this&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}}class ut{constructor(e={}){"requireExplicitPolicy"in e&&(this.requireExplicitPolicy=t(e,"requireExplicitPolicy",ut.defaultValues("requireExplicitPolicy"))),"inhibitPolicyMapping"in e&&(this.inhibitPolicyMapping=t(e,"inhibitPolicyMapping",ut.defaultValues("inhibitPolicyMapping"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"requireExplicitPolicy":case"inhibitPolicyMapping":return 0;default:throw new Error(`Invalid member name for PolicyConstraints class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new x({name:r.requireExplicitPolicy||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new x({name:r.inhibitPolicyMapping||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){const t=Be(e,e,ut.schema({names:{requireExplicitPolicy:"requireExplicitPolicy",inhibitPolicyMapping:"inhibitPolicyMapping"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyConstraints");if("requireExplicitPolicy"in t.result){const e=t.result.requireExplicitPolicy;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=we(e.toBER(!1));this.requireExplicitPolicy=r.result.valueBlock.valueDec}if("inhibitPolicyMapping"in t.result){const e=t.result.inhibitPolicyMapping;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=we(e.toBER(!1));this.inhibitPolicyMapping=r.result.valueBlock.valueDec}}toSchema(){const e=[];if("requireExplicitPolicy"in this){const t=new T({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if("inhibitPolicyMapping"in this){const t=new T({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new O({value:e})}toJSON(){const e={};return"requireExplicitPolicy"in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),"inhibitPolicyMapping"in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}}class ht{constructor(e={}){this.keyPurposes=t(e,"keyPurposes",ht.defaultValues("keyPurposes")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyPurposes":return[];default:throw new Error(`Invalid member name for ExtKeyUsage class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ke({name:r.keyPurposes||"",value:new _})]})}fromSchema(e){const t=Be(e,e,ht.schema({names:{keyPurposes:"keyPurposes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ExtKeyUsage");this.keyPurposes=Array.from(t.result.keyPurposes,e=>e.valueBlock.toString())}toSchema(){return new O({value:Array.from(this.keyPurposes,e=>new _({value:e}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}class mt{constructor(e={}){this.accessDescriptions=t(e,"accessDescriptions",mt.defaultValues("accessDescriptions")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"accessDescriptions":return[];default:throw new Error(`Invalid member name for InfoAccess class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ke({name:r.accessDescriptions||"",value:We.schema()})]})}fromSchema(e){const t=Be(e,e,mt.schema({names:{accessDescriptions:"accessDescriptions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for InfoAccess");this.accessDescriptions=Array.from(t.result.accessDescriptions,e=>new We({schema:e}))}toSchema(){return new O({value:Array.from(this.accessDescriptions,e=>e.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,e=>e.toJSON())}}}class ft{constructor(e={}){this.extnID=t(e,"extnID",ft.defaultValues("extnID")),this.critical=t(e,"critical",ft.defaultValues("critical")),this.extnValue="extnValue"in e?new V({valueHex:e.extnValue}):ft.defaultValues("extnValue"),"parsedValue"in e&&(this.parsedValue=t(e,"parsedValue",ft.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"extnID":return"";case"critical":return!1;case"extnValue":return new V;case"parsedValue":return{};default:throw new Error(`Invalid member name for Extension class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new _({name:r.extnID||""}),new L({name:r.critical||"",optional:!0}),new V({name:r.extnValue||""})]})}fromSchema(e){let t=Be(e,e,ft.schema({names:{extnID:"extnID",critical:"critical",extnValue:"extnValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EXTENSION");if(this.extnID=t.result.extnID.valueBlock.toString(),"critical"in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue,-1!==(t=we(this.extnValue.valueBlock.valueHex)).offset)switch(this.extnID){case"2.5.29.9":this.parsedValue=new Qe({schema:t.result});break;case"2.5.29.14":case"2.5.29.15":this.parsedValue=t.result;break;case"2.5.29.16":this.parsedValue=new ze({schema:t.result});break;case"2.5.29.17":case"2.5.29.18":this.parsedValue=new Ge({schema:t.result});break;case"2.5.29.19":this.parsedValue=new Ze({schema:t.result});break;case"2.5.29.20":case"2.5.29.27":case"2.5.29.21":case"2.5.29.24":this.parsedValue=t.result;break;case"2.5.29.28":this.parsedValue=new Ye({schema:t.result});break;case"2.5.29.29":this.parsedValue=new Xe({schema:t.result});break;case"2.5.29.30":this.parsedValue=new tt({schema:t.result});break;case"2.5.29.31":case"2.5.29.46":this.parsedValue=new st({schema:t.result});break;case"2.5.29.32":this.parsedValue=new it({schema:t.result});break;case"2.5.29.33":this.parsedValue=new lt({schema:t.result});break;case"2.5.29.35":this.parsedValue=new ct({schema:t.result});break;case"2.5.29.36":this.parsedValue=new ut({schema:t.result});break;case"2.5.29.37":this.parsedValue=new ht({schema:t.result});break;case"2.5.29.54":this.parsedValue=t.result;break;case"1.3.6.1.5.5.7.1.1":case"1.3.6.1.5.5.7.1.11":this.parsedValue=new mt({schema:t.result})}}toSchema(){const e=[];return e.push(new _({value:this.extnID})),this.critical!==ft.defaultValues("critical")&&e.push(new L({value:this.critical})),e.push(this.extnValue),new O({value:e})}toJSON(){const e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==ft.defaultValues("critical")&&(e.critical=this.critical),"parsedValue"in this&&(e.parsedValue=this.parsedValue.toJSON()),e}}class gt{constructor(e={}){this.extensions=t(e,"extensions",gt.defaultValues("extensions")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"extensions":return[];default:throw new Error(`Invalid member name for Extensions class: ${e}`)}}static schema(e={},r=!1){const s=t(e,"names",{});return new O({optional:r,name:s.blockName||"",value:[new ke({name:s.extensions||"",value:ft.schema(s.extension||{})})]})}fromSchema(e){const t=Be(e,e,gt.schema({names:{extensions:"extensions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EXTENSIONS");this.extensions=Array.from(t.result.extensions,e=>new ft({schema:e}))}toSchema(){return new O({value:Array.from(this.extensions,e=>e.toSchema())})}toJSON(){return{extensions:Array.from(this.extensions,e=>e.toJSON())}}}class dt{constructor(e={}){this.tbs=t(e,"tbs",dt.defaultValues("tbs")),this.version=t(e,"version",dt.defaultValues("version")),this.subject=t(e,"subject",dt.defaultValues("subject")),this.subjectPublicKeyInfo=t(e,"subjectPublicKeyInfo",dt.defaultValues("subjectPublicKeyInfo")),"attributes"in e&&(this.attributes=t(e,"attributes",dt.defaultValues("attributes"))),this.signatureAlgorithm=t(e,"signatureAlgorithm",dt.defaultValues("signatureAlgorithm")),this.signatureValue=t(e,"signatureValue",dt.defaultValues("signatureValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"version":return 0;case"subject":return new _e;case"subjectPublicKeyInfo":return new xe;case"attributes":return[];case"signatureAlgorithm":return new Ae;case"signatureValue":return new K;default:throw new Error(`Invalid member name for CertificationRequest class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({value:[function(e={}){const r=t(e,"names",{});return new O({name:r.CertificationRequestInfo||"CertificationRequestInfo",value:[new T({name:r.CertificationRequestInfoVersion||"CertificationRequestInfo.version"}),_e.schema(r.subject||{names:{blockName:"CertificationRequestInfo.subject"}}),xe.schema({names:{blockName:"CertificationRequestInfo.subjectPublicKeyInfo"}}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ke({optional:!0,name:r.CertificationRequestInfoAttributes||"CertificationRequestInfo.attributes",value:Ne.schema(r.attributes||{})})]})]})}(r.certificationRequestInfo||{}),new O({name:r.signatureAlgorithm||"signatureAlgorithm",value:[new _,new ve({optional:!0})]}),new K({name:r.signatureValue||"signatureValue"})]})}fromSchema(e){const t=Be(e,e,dt.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PKCS10");this.tbs=t.result.CertificationRequestInfo.valueBeforeDecode,this.version=t.result["CertificationRequestInfo.version"].valueBlock.valueDec,this.subject=new _e({schema:t.result["CertificationRequestInfo.subject"]}),this.subjectPublicKeyInfo=new xe({schema:t.result["CertificationRequestInfo.subjectPublicKeyInfo"]}),"CertificationRequestInfo.attributes"in t.result&&(this.attributes=Array.from(t.result["CertificationRequestInfo.attributes"],e=>new Ne({schema:e}))),this.signatureAlgorithm=new Ae({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[new T({value:this.version}),this.subject.toSchema(),this.subjectPublicKeyInfo.toSchema()];return"attributes"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new O({value:e})}toSchema(e=!1){let t;if(!1===e){if(0===this.tbs.length)return dt.schema();t=we(this.tbs).result}else t=this.encodeTBS();return new O({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:r(this.tbs,0,this.tbs.byteLength),version:this.version,subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return"attributes"in this&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let r,s=Promise.resolve();const n=Ve;return s=(s=(s=(s=(s=s.then(()=>n.subtle.getSignatureParameters(e,t))).then(e=>{r=e.parameters,this.signatureAlgorithm=e.signatureAlgorithm})).then(()=>{this.tbs=this.encodeTBS().toBER(!1)})).then(()=>n.subtle.signWithPrivateKey(this.tbs,e,r))).then(e=>{this.signatureValue=new K({valueHex:e})})}verify(){let e=Promise.resolve();const t=this.subjectPublicKeyInfo,r=this.signatureValue,s=this.tbs,n=je();if(void 0===n)return Promise.reject("Unable to create WebCrypto object");const a=$e(this.signatureAlgorithm);return""===a?Promise.reject(`Unsupported signature algorithm: ${this.signatureAlgorithm.algorithmId}`):e=(e=e.then(()=>{let e;const r=Fe(e="1.2.840.113549.1.1.10"===this.signatureAlgorithm.algorithmId?this.signatureAlgorithm.algorithmId:this.subjectPublicKeyInfo.algorithm.algorithmId);if("name"in r==!1)return Promise.reject(`Unsupported public key algorithm: ${e}`);const s=Ke(r.name,"importkey");if("hash"in s.algorithm&&(s.algorithm.hash.name=a),"ECDSA"===r.name){let e=!1;if("algorithmParams"in t.algorithm==!0&&"idBlock"in t.algorithm.algorithmParams&&1===t.algorithm.algorithmParams.idBlock.tagClass&&6===t.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)return Promise.reject("Incorrect type for ECDSA public key parameters");const r=Fe(t.algorithm.algorithmParams.valueBlock.toString());if("name"in r==!1)return Promise.reject(`Unsupported named curve algorithm: ${t.algorithm.algorithmParams.valueBlock.toString()}`);s.algorithm.namedCurve=r.name}const i=t.toSchema().toBER(!1),o=new Uint8Array(i);return n.importKey("spki",o,s.algorithm,!0,s.usages)})).then(e=>{const t=Ke(e.algorithm.name,"verify");"hash"in t.algorithm&&(t.algorithm.hash.name=a);let i=r.valueBlock.valueHex;if("ECDSA"===e.algorithm.name){i=Te(we(i).result)}if("RSA-PSS"===e.algorithm.name){let e;try{e=new Oe({schema:this.signatureAlgorithm.algorithmParams})}catch(e){return Promise.reject(e)}t.algorithm.saltLength="saltLength"in e?e.saltLength:20;let r="SHA-1";if("hashAlgorithm"in e){const t=Fe(e.hashAlgorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Unrecognized hash algorithm: ${e.hashAlgorithm.algorithmId}`);r=t.name}t.algorithm.hash.name=r}return n.verify(t.algorithm,e,new Uint8Array(i),new Uint8Array(s))})}getPublicKey(e=null){const t=je();if(void 0===t)return Promise.reject("Unable to create WebCrypto object");if(null===e){e={};const t=$e(this.signatureAlgorithm);if(""===t)return Promise.reject(`Unsupported signature algorithm: ${this.signatureAlgorithm.algorithmId}`);const r=Fe(this.subjectPublicKeyInfo.algorithm.algorithmId);if("name"in r==!1)return Promise.reject(`Unsupported public key algorithm: ${this.subjectPublicKeyInfo.algorithm.algorithmId}`);if(e.algorithm=Ke(r.name,"importkey"),"hash"in e.algorithm.algorithm&&(e.algorithm.algorithm.hash.name=t),"ECDSA"===r.name){let t=!1;if("algorithmParams"in this.subjectPublicKeyInfo.algorithm==!0&&"idBlock"in this.subjectPublicKeyInfo.algorithm.algorithmParams&&1===this.subjectPublicKeyInfo.algorithm.algorithmParams.idBlock.tagClass&&6===this.subjectPublicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)return Promise.reject("Incorrect type for ECDSA public key parameters");const r=Fe(this.subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString());if("name"in r==!1)return Promise.reject(`Unsupported named curve algorithm: ${this.subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);e.algorithm.algorithm.namedCurve=r.name}}const r=this.subjectPublicKeyInfo.toSchema(),s=r.toBER(!1),n=new Uint8Array(s);return t.importKey("spki",n,e.algorithm.algorithm,!0,e.algorithm.usages)}}function yt(e,t,r){return e instanceof Object==!1?r:t in e?e[t]:r}function vt(e,t=0,r=e.byteLength){let s="";for(const n of new Uint8Array(e,t,r)){const e=n.toString(16).toUpperCase();s=s+(1===e.length?"0":"")+e}return s}function kt(e,t,r,s){return t instanceof ArrayBuffer==!1?(e.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===t.byteLength?(e.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):s<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-s<0)||(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1)}function bt(e,t){let r=0;for(let s=e.length-1;s>=0;s--)r+=e[e.length-1-s]*Math.pow(2,t*s);return r}function pt(e,t,r=0){const s=r||-1;let n=e,a=0,i=Math.pow(2,t);for(let r=1;r<8;r++){if(e<i){let e;if(s<0)e=new ArrayBuffer(r),a=r;else{if(s<r)return new ArrayBuffer(0);e=new ArrayBuffer(s),a=s}const i=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);i[a-e-1]=Math.floor(n/r),n-=i[a-e-1]*r}return e}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function wt(...e){let t=0,r=0;for(const r of e)t+=r.byteLength;const s=new ArrayBuffer(t),n=new Uint8Array(s);for(const t of e)n.set(new Uint8Array(t),r),r+=t.byteLength;return s}function Bt(...e){let t=0,r=0;for(const r of e)t+=r.length;const s=new ArrayBuffer(t),n=new Uint8Array(s);for(const t of e)n.set(t,r),r+=t.length;return n}function At(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),s=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==s[e])return!1;return!0}function St(e,t){const r=e.toString(10),s=t-r.length,n=new Array(s);for(let e=0;e<s;e++)n[e]="0";return n.join("").concat(r)}const Ct="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",xt="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";const Nt=[new Uint8Array([1])],Et="0123456789";class Ht{constructor(e={}){this.blockLength=yt(e,"blockLength",0),this.error=yt(e,"error",""),this.warnings=yt(e,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in e?e.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:vt(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const Pt=e=>(class extends e{constructor(e={}){super(e),this.isHexOnly=yt(e,"isHexOnly",!1),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(e,t,r){if(!1===kt(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);return 0===s.length?(this.warnings.push("Zero buffer length"),t):(this.valueHex=e.slice(t,t+r),this.blockLength=r,t+r)}toBER(e=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===e?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isHexOnly=this.isHexOnly,e.valueHex=vt(this.valueHex,0,this.valueHex.byteLength),e}});class It extends(Pt(Ht)){constructor(e={}){super(),"idBlock"in e?(this.isHexOnly=yt(e.idBlock,"isHexOnly",!1),this.valueHex=yt(e.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=yt(e.idBlock,"tagClass",-1),this.tagNumber=yt(e.idBlock,"tagNumber",-1),this.isConstructed=yt(e.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(e=!1){let t,r,s=0;switch(this.tagClass){case 1:s|=0;break;case 2:s|=64;break;case 3:s|=128;break;case 4:s|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(s|=32),this.tagNumber<31&&!this.isHexOnly){if(t=new ArrayBuffer(1),r=new Uint8Array(t),!e){let e=this.tagNumber;s|=e&=31,r[0]=s}return t}if(!1===this.isHexOnly){const n=pt(this.tagNumber,7),a=new Uint8Array(n),i=n.byteLength;if(t=new ArrayBuffer(i+1),(r=new Uint8Array(t))[0]=31|s,!e){for(let e=0;e<i-1;e++)r[e+1]=128|a[e];r[i]=a[i-1]}return t}if(t=new ArrayBuffer(this.valueHex.byteLength+1),(r=new Uint8Array(t))[0]=31|s,!1===e){const e=new Uint8Array(this.valueHex);for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHex.byteLength]=e[e.length-1]}return t}fromBER(e,t,r){if(!1===kt(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);if(0===s.length)return this.error="Zero buffer length",-1;const n=192&s[0];switch(n){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&s[0]),this.isHexOnly=!1;const a=31&s[0];if(31!==a)this.tagNumber=a,this.blockLength=1;else{let e=1;this.valueHex=new ArrayBuffer(255);let t=255,r=new Uint8Array(this.valueHex);for(;128&s[e];){if(r[e-1]=127&s[e],++e>=s.length)return this.error="End of input reached before message was fully decoded",-1;if(e===t){t+=255;const e=new ArrayBuffer(t),s=new Uint8Array(e);for(let e=0;e<r.length;e++)s[e]=r[e];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex)}}this.blockLength=e+1,r[e-1]=127&s[e];const n=new ArrayBuffer(e),a=new Uint8Array(n);for(let t=0;t<e;t++)a[t]=r[t];this.valueHex=new ArrayBuffer(e),(r=new Uint8Array(this.valueHex)).set(a),this.blockLength<=9?this.tagNumber=bt(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.tagClass=this.tagClass,e.tagNumber=this.tagNumber,e.isConstructed=this.isConstructed,e}}class Lt extends Ht{constructor(e={}){super(),"lenBlock"in e?(this.isIndefiniteForm=yt(e.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=yt(e.lenBlock,"longFormUsed",!1),this.length=yt(e.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(e,t,r){if(!1===kt(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);if(0===s.length)return this.error="Zero buffer length",-1;if(255===s[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===s[0],!0===this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&s[0]),!1===this.longFormUsed)return this.length=s[0],this.blockLength=1,t+this.blockLength;const n=127&s[0];if(n>8)return this.error="Too big integer",-1;if(n+1>s.length)return this.error="End of input reached before message was fully decoded",-1;const a=new Uint8Array(n);for(let e=0;e<n;e++)a[e]=s[e+1];return 0===a[n-1]&&this.warnings.push("Needlessly long encoded length"),this.length=bt(a,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=n+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=128),t;if(!0===this.longFormUsed){const s=pt(this.length,8);if(s.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength+1),!0===e)return t;const n=new Uint8Array(s);(r=new Uint8Array(t))[0]=128|s.byteLength;for(let e=0;e<s.byteLength;e++)r[e+1]=n[e];return t}return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=this.length),t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isIndefiniteForm=this.isIndefiniteForm,e.longFormUsed=this.longFormUsed,e.length=this.length,e}}class Ot extends Ht{constructor(e={}){super(e)}static blockName(){return"valueBlock"}fromBER(e,t,r){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}toBER(e=!1){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}}class Ut extends Ht{constructor(e={},t=Ot){super(e),"name"in e&&(this.name=e.name),"optional"in e&&(this.optional=e.optional),"primitiveSchema"in e&&(this.primitiveSchema=e.primitiveSchema),this.idBlock=new It(e),this.lenBlock=new Lt(e),this.valueBlock=new t(e)}static blockName(){return"BaseBlock"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e=!1){let t;const r=this.idBlock.toBER(e),s=this.valueBlock.toBER(!0);this.lenBlock.length=s.byteLength;const n=this.lenBlock.toBER(e);let a;if(t=wt(t=wt(r,n),a=!1===e?this.valueBlock.toBER(e):new ArrayBuffer(this.lenBlock.length)),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===e){const e=new Uint8Array(r);e[0]=0,e[1]=0}t=wt(t,r)}return t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.idBlock=this.idBlock.toJSON(),e.lenBlock=this.lenBlock.toJSON(),e.valueBlock=this.valueBlock.toJSON(),"name"in this&&(e.name=this.name),"optional"in this&&(e.optional=this.optional),"primitiveSchema"in this&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}}class Rt extends Ot{constructor(e={}){super(e),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=yt(e,"isHexOnly",!0)}fromBER(e,t,r){if(!1===kt(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);if(0===s.length)return this.warnings.push("Zero buffer length"),t;this.valueHex=new ArrayBuffer(s.length);const n=new Uint8Array(this.valueHex);for(let e=0;e<s.length;e++)n[e]=s[e];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueHex=vt(this.valueHex,0,this.valueHex.byteLength),e.isHexOnly=this.isHexOnly,e}}class Dt extends Ut{constructor(e={}){super(e,Rt),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}class Vt extends Ot{constructor(e={}){super(e),this.value=yt(e,"value",[]),this.isIndefiniteForm=yt(e,"isIndefiniteForm",!1)}fromBER(e,t,r){const s=t,n=r;if(!1===kt(this,e,t,r))return-1;const a=new Uint8Array(e,t,r);if(0===a.length)return this.warnings.push("Zero buffer length"),t;function i(e,t){return!0===e?1:t}let o=t;for(;i(this.isIndefiniteForm,r)>0;){const t=xr(e,o,r);if(-1===t.offset)return this.error=t.result.error,this.warnings.concat(t.result.warnings),-1;if(o=t.offset,this.blockLength+=t.result.blockLength,r-=t.result.blockLength,this.value.push(t.result),!0===this.isIndefiniteForm&&t.result.constructor.blockName()===Jt.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===Jt.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=e.slice(s,s+n),o}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){t=wt(t,this.value[r].toBER(e))}return t}static blockName(){return"ConstructedValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.isIndefiniteForm=this.isIndefiniteForm,e.value=[];for(let t=0;t<this.value.length;t++)e.value.push(this.value[t].toJSON());return e}}class jt extends Ut{constructor(e={}){super(e,Vt),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}}class Kt extends Ot{constructor(e={}){super(e)}fromBER(e,t,r){return t}toBER(e=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class Jt extends Ut{constructor(e={}){super(e,Kt),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}class Tt extends Ot{constructor(e={}){if(super(e),this.value=yt(e,"value",!1),this.isHexOnly=yt(e,"isHexOnly",!1),"valueHex"in e)this.valueHex=e.valueHex.slice(0);else if(this.valueHex=new ArrayBuffer(1),!0===this.value){var t=new Uint8Array(this.valueHex);t[0]=255}}fromBER(e,t,r){if(!1===kt(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.value=0!==s[0],this.isHexOnly=!0,this.valueHex=new ArrayBuffer(s.length);const n=new Uint8Array(this.valueHex);for(let e=0;e<s.length;e++)n[e]=s[e];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e.isHexOnly=this.isHexOnly,e.valueHex=vt(this.valueHex,0,this.valueHex.byteLength),e}}class Ft extends Ut{constructor(e={}){super(e,Tt),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}class $t extends jt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}class Mt extends jt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}class _t extends Ut{constructor(e={}){super(e,Ht),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r}toBER(e=!1){const t=new ArrayBuffer(2);if(!0===e)return t;const r=new Uint8Array(t);return r[0]=5,r[1]=0,t}}class qt extends(Pt(Vt)){constructor(e={}){super(e),this.isConstructed=yt(e,"isConstructed",!1)}fromBER(e,t,r){let s=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,-1===(s=Vt.prototype.fromBER.call(this,e,t,r)))return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===Jt.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==Wt.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e=!1){if(!0===this.isConstructed)return Vt.prototype.toBER.call(this,e);let t=new ArrayBuffer(this.valueHex.byteLength);return!0===e?t:0===this.valueHex.byteLength?t:t=this.valueHex.slice(0)}static blockName(){return"OctetStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=vt(this.valueHex,0,this.valueHex.byteLength),e}}class Wt extends Ut{constructor(e={}){super(e,qt),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t):super.fromBER(e,t,r)}static blockName(){return"OctetString"}isEqual(e){return e instanceof Wt!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class Gt extends(Pt(Vt)){constructor(e={}){super(e),this.unusedBits=yt(e,"unusedBits",0),this.isConstructed=yt(e,"isConstructed",!1),this.blockLength=this.valueHex.byteLength+1}fromBER(e,t,r){if(0===r)return t;let s=-1;if(!0===this.isConstructed){if(-1===(s=Vt.prototype.fromBER.call(this,e,t,r)))return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===Jt.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==Qt.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[e].unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[e].unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return s}if(!1===kt(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(this.unusedBits=n[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(n.length-1);const a=new Uint8Array(this.valueHex);for(let e=0;e<r-1;e++)a[e]=n[e+1];return this.blockLength=n.length,t+r}toBER(e=!1){if(!0===this.isConstructed)return Vt.prototype.toBER.call(this,e);if(!0===e)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const t=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),s=new Uint8Array(r);s[0]=this.unusedBits;for(let e=0;e<this.valueHex.byteLength;e++)s[e+1]=t[e];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.unusedBits=this.unusedBits,e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=vt(this.valueHex,0,this.valueHex.byteLength),e}}class Qt extends Ut{constructor(e={}){super(e,Gt),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(e,t,r){return 0===r?t:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r))}isEqual(e){return e instanceof Qt!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class zt extends(Pt(Ot)){constructor(e={}){super(e),"value"in e&&(this.valueDec=e.value)}set valueHex(e){this._valueHex=e.slice(0),e.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,e.byteLength>0&&(this._valueDec=function(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&0==(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const s=bt(r,8),n=new ArrayBuffer(this.valueHex.byteLength),a=new Uint8Array(n);for(let t=0;t<this.valueHex.byteLength;t++)a[t]=e[t];return a[0]&=127,bt(a,8)-s}.call(this)))}get valueHex(){return this._valueHex}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this._valueHex=function(e){const t=e<0?-1*e:e;let r=128;for(let s=1;s<8;s++){if(t<=r){if(e<0){const e=pt(r-t,8,s);return new Uint8Array(e)[0]|=128,e}let n=pt(t,8,s),a=new Uint8Array(n);if(128&a[0]){const e=n.slice(0),t=new Uint8Array(e);n=new ArrayBuffer(n.byteLength+1),a=new Uint8Array(n);for(let r=0;r<e.byteLength;r++)a[r+1]=t[r];a[0]=0}return n}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(e)}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const n=this.fromBER(e,t,r);if(-1===n)return n;const a=new Uint8Array(this._valueHex);if(0===a[0]&&0!=(128&a[1])){const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}else if(0!==s&&this._valueHex.byteLength<s){s-this._valueHex.byteLength>1&&(s=this._valueHex.byteLength+1);const e=new ArrayBuffer(s);new Uint8Array(e).set(a,s-this._valueHex.byteLength),this._valueHex=e.slice(0)}return n}toDER(e=!1){const t=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&t[0]):{const e=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(e);r[0]=0,r.set(t,1),this._valueHex=e.slice(0)}break;case 0===t[0]&&0==(128&t[1]):{const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return-1===s?s:(this.blockLength=r,t+r)}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e}toString(){function e(e,t){const r=new Uint8Array([0]);let s=new Uint8Array(e),n=new Uint8Array(t),a=s.slice(0);const i=a.length-1;let o=n.slice(0);const l=o.length-1;let c=0;let u=0;for(let e=l<i?i:l;e>=0;e--,u++){switch(!0){case u<o.length:c=a[i-u]+o[l-u]+r[0];break;default:c=a[i-u]+r[0]}switch(r[0]=c/10,!0){case u>=a.length:a=Bt(new Uint8Array([c%10]),a);break;default:a[i-u]=c%10}}return r[0]>0&&(a=Bt(r,a)),a.slice(0)}function t(e){if(e>=Nt.length)for(let t=Nt.length;t<=e;t++){const e=new Uint8Array([0]);let r=Nt[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const s=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=s[0]/10,r[t]=s[0]%10}e[0]>0&&(r=Bt(e,r)),Nt.push(r)}return Nt[e]}function r(e,t){let r=0,s=new Uint8Array(e),n=new Uint8Array(t),a=s.slice(0);const i=a.length-1;let o=n.slice(0);const l=o.length-1;let c,u=0;for(let e=l;e>=0;e--,u++)switch(c=a[i-u]-o[l-u]-r,!0){case c<0:r=1,a[i-u]=c+10;break;default:r=0,a[i-u]=c}if(r>0)for(let e=i-l+1;e>=0;e--,u++){if(!((c=a[i-u]-r)<0)){r=0,a[i-u]=c;break}r=1,a[i-u]=c+10}return a.slice()}const s=8*this._valueHex.byteLength-1;let n,a=new Uint8Array(8*this._valueHex.byteLength/3),i=0;const o=new Uint8Array(this._valueHex);let l="",c=!1;for(let c=this._valueHex.byteLength-1;c>=0;c--){n=o[c];for(let o=0;o<8;o++){if(1==(1&n))switch(i){case s:a=r(t(i),a),l="-";break;default:a=e(a,t(i))}i++,n>>=1}}for(let e=0;e<a.length;e++)a[e]&&(c=!0),c&&(l+=Et.charAt(a[e]));return!1===c&&(l+=Et.charAt(0)),l}}class Zt extends Ut{constructor(e={}){super(e,zt),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(e){return e instanceof Zt?this.valueBlock.isHexOnly&&e.valueBlock.isHexOnly?At(this.valueBlock.valueHex,e.valueBlock.valueHex):this.valueBlock.isHexOnly===e.valueBlock.isHexOnly&&this.valueBlock.valueDec===e.valueBlock.valueDec:e instanceof ArrayBuffer&&At(this.valueBlock.valueHex,e)}convertToDER(){const e=new Zt({valueHex:this.valueBlock.valueHex});return e.valueBlock.toDER(),e}convertFromDER(){const e=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,t=new Zt({valueHex:this.valueBlock.valueHex});return t.valueBlock.fromDER(t.valueBlock.valueHex,0,t.valueBlock.valueHex.byteLength,e),t}}class Yt extends Zt{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}class Xt extends(Pt(Ht)){constructor(e={}){super(e),this.valueDec=yt(e,"valueDec",-1),this.isFirstSid=yt(e,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(e,t,r){if(0===r)return t;if(!1===kt(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);this.valueHex=new ArrayBuffer(r);let n=new Uint8Array(this.valueHex);for(let e=0;e<r&&(n[e]=127&s[e],this.blockLength++,0!=(128&s[e]));e++);const a=new ArrayBuffer(this.blockLength),i=new Uint8Array(a);for(let e=0;e<this.blockLength;e++)i[e]=n[e];return this.valueHex=a.slice(0),n=new Uint8Array(this.valueHex),0!=(128&s[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===n[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=bt(n,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|s[e];return r[this.blockLength-1]=s[this.blockLength-1],t}const s=pt(this.valueDec,7);if(0===s.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength),!1===e){const e=new Uint8Array(s);r=new Uint8Array(t);for(let t=0;t<s.byteLength-1;t++)r[t]=128|e[t];r[s.byteLength-1]=e[s.byteLength-1]}return t}toString(){let e="";if(!0===this.isHexOnly)e=vt(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e.isFirstSid=this.isFirstSid,e}}class er extends Ot{constructor(e={}){super(e),this.fromString(yt(e,"value",""))}fromBER(e,t,r){let s=t;for(;r>0;){const t=new Xt;if(-1===(s=t.fromBER(e,s,r)))return this.blockLength=0,this.error=t.error,s;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(0===s.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=wt(t,s)}return t}fromString(e){this.value=[];let t=0,r=0,s="",n=!1;do{if(s=-1===(r=e.indexOf(".",t))?e.substr(t):e.substr(t,r-t),t=r+1,n){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return this.value=[],!1}const r=parseInt(s,10);if(isNaN(r))return!0;e.valueDec=r+t,n=!1}else{const e=new Xt;if(e.valueDec=parseInt(s,10),isNaN(e.valueDec))return!0;0===this.value.length&&(e.isFirstSid=!0,n=!0),this.value.push(e)}}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e=`${e}.`),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.value=this.toString(),e.sidArray=[];for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}class tr extends Ut{constructor(e={}){super(e,er),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}class rr extends(Pt(Ht)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class sr extends Ut{constructor(e={}){super(e,rr),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(e){const t=unescape(encodeURIComponent(e)),r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r);const s=new Uint8Array(this.valueBlock.valueHex);for(let e=0;e<r;e++)s[e]=t.charCodeAt(e);this.valueBlock.value=e}}class nr extends(Pt(Ht)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class ar extends Ut{constructor(e={}){super(e,nr),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=2){const t=r[e];r[e]=r[e+1],r[e+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(2*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=pt(e.charCodeAt(s),8),n=new Uint8Array(t);if(n.length>2)continue;const a=2-n.length;for(let e=n.length-1;e>=0;e--)r[2*s+e+a]=n[e]}this.valueBlock.value=e}}class ir extends(Pt(Ht)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class or extends Ut{constructor(e={}){super(e,ir),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(4*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=pt(e.charCodeAt(s),8),n=new Uint8Array(t);if(n.length>4)continue;const a=4-n.length;for(let e=n.length-1;e>=0;e--)r[4*s+e+a]=n[e]}this.valueBlock.value=e}}class lr extends(Pt(Ht)){constructor(e={}){super(e),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class cr extends Ut{constructor(e={}){super(e,lr),"value"in e&&this.fromString(e.value)}static blockName(){return"SIMPLESTRING"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}class ur extends cr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}class hr extends cr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}class mr extends cr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}class fr extends cr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}class gr extends cr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}class dr extends cr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}class yr extends cr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}class vr extends cr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}class kr extends cr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}class br extends yr{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi,r=t.exec(e);if(null===r)return void(this.error="Wrong input string for convertion");const s=parseInt(r[1],10);this.year=s>=50?1900+s:2e3+s,this.month=parseInt(r[2],10),this.day=parseInt(r[3],10),this.hour=parseInt(r[4],10),this.minute=parseInt(r[5],10),this.second=parseInt(r[6],10)}toString(){const e=new Array(7);return e[0]=St(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=St(this.month,2),e[2]=St(this.day,2),e[3]=St(this.hour,2),e[4]=St(this.minute,2),e[5]=St(this.second,2),e[6]="Z",e.join("")}static blockName(){return"UTCTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e}}class pr extends yr{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,s="",n="",a=0,i=0,o=0;if("Z"===e[e.length-1])s=e.substr(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");s=e}if(r){if(-1!==s.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==s.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let e=1,t=s.indexOf("+"),r="";if(-1===t&&(t=s.indexOf("-"),e=-1),-1!==t){if(r=s.substr(t+1),s=s.substr(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let n=new Number(r.substr(0,2));if(isNaN(n.valueOf()))throw new Error("Wrong input string for convertion");if(i=e*n,4===r.length){if(n=new Number(r.substr(2,2)),isNaN(n.valueOf()))throw new Error("Wrong input string for convertion");o=e*n}}}let l=s.indexOf(".");if(-1===l&&(l=s.indexOf(",")),-1!==l){const e=new Number(`0${s.substr(l)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");a=e.valueOf(),n=s.substr(0,l)}else n=s;switch(!0){case 8===n.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==l)throw new Error("Wrong input string for convertion");break;case 10===n.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*a;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===n.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*a;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===n.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){const e=1e3*a;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for convertion")}const c=t.exec(n);if(null===c)throw new Error("Wrong input string for convertion");for(let e=1;e<c.length;e++)switch(e){case 1:this.year=parseInt(c[e],10);break;case 2:this.month=parseInt(c[e],10);break;case 3:this.day=parseInt(c[e],10);break;case 4:this.hour=parseInt(c[e],10)+i;break;case 5:this.minute=parseInt(c[e],10)+o;break;case 6:this.second=parseInt(c[e],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(){const e=[];return e.push(St(this.year,4)),e.push(St(this.month,2)),e.push(St(this.day,2)),e.push(St(this.hour,2)),e.push(St(this.minute,2)),e.push(St(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(St(this.millisecond,3))),e.push("Z"),e.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e.millisecond=this.millisecond,e}}class wr extends sr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}class Br extends sr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}class Ar extends sr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}class Sr extends sr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}class Cr extends sr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}function xr(e,t,r){const s=t;let n=new Ut({},Object);if(!1===kt(new Ht,e,t,r))return n.error="Wrong input parameters",{offset:-1,result:n};if(0===new Uint8Array(e,t,r).length)return this.error="Zero buffer length",{offset:-1,result:n};let a=n.idBlock.fromBER(e,t,r);if(n.warnings.concat(n.idBlock.warnings),-1===a)return n.error=n.idBlock.error,{offset:-1,result:n};if(t=a,r-=n.idBlock.blockLength,a=n.lenBlock.fromBER(e,t,r),n.warnings.concat(n.lenBlock.warnings),-1===a)return n.error=n.lenBlock.error,{offset:-1,result:n};if(t=a,r-=n.lenBlock.blockLength,!1===n.idBlock.isConstructed&&!0===n.lenBlock.isIndefiniteForm)return n.error="Indefinite length form used for primitive encoding form",{offset:-1,result:n};let i=Ut;switch(n.idBlock.tagClass){case 1:if(n.idBlock.tagNumber>=37&&!1===n.idBlock.isHexOnly)return n.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:n};switch(n.idBlock.tagNumber){case 0:if(!0===n.idBlock.isConstructed&&n.lenBlock.length>0)return n.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:n};i=Jt;break;case 1:i=Ft;break;case 2:i=Zt;break;case 3:i=Qt;break;case 4:i=Wt;break;case 5:i=_t;break;case 6:i=tr;break;case 10:i=Yt;break;case 12:i=sr;break;case 14:i=Cr;break;case 15:return n.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:n};case 16:i=$t;break;case 17:i=Mt;break;case 18:i=ur;break;case 19:i=hr;break;case 20:i=mr;break;case 21:i=fr;break;case 22:i=gr;break;case 23:i=br;break;case 24:i=pr;break;case 25:i=dr;break;case 26:i=yr;break;case 27:i=vr;break;case 28:i=or;break;case 29:i=kr;break;case 30:i=ar;break;case 31:i=wr;break;case 32:i=Br;break;case 33:i=Ar;break;case 34:i=Sr;break;default:{let s;(s=!0===n.idBlock.isConstructed?new jt:new Dt).idBlock=n.idBlock,s.lenBlock=n.lenBlock,s.warnings=n.warnings,a=(n=s).fromBER(e,t,r)}}break;case 2:case 3:case 4:default:i=!0===n.idBlock.isConstructed?jt:Dt}return a=(n=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecode=e.valueBeforeDecode.slice(0),r}(n,i)).fromBER(e,t,!0===n.lenBlock.isIndefiniteForm?r:n.lenBlock.length),n.valueBeforeDecode=e.slice(s,s+n.blockLength),{offset:a,result:n}}var Nr=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(e[s]=r[s])}return e},Er=function(){return function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,t){var r=[],s=!0,n=!1,a=void 0;try{for(var i,o=e[Symbol.iterator]();!(s=(i=o.next()).done)&&(r.push(i.value),!t||r.length!==t);s=!0);}catch(e){n=!0,a=e}finally{try{!s&&o.return&&o.return()}finally{if(n)throw a}}return r}(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();function Hr(e,t){for(var r="-----BEGIN "+t+"-----\r\n",s=function(e,t=!1,r=!1,s=!1){let n=0,a=0,i=0,o="";const l=t?xt:Ct;if(s){let t=0;for(let r=0;r<e.length;r++)if(0!==e.charCodeAt(r)){t=r;break}e=e.slice(t)}for(;n<e.length;){const t=e.charCodeAt(n++);n>=e.length&&(a=1);const s=e.charCodeAt(n++);n>=e.length&&(i=1);const c=e.charCodeAt(n++),u=t>>2,h=(3&t)<<4|s>>4;let m=(15&s)<<2|c>>6,f=63&c;1===a?m=f=64:1===i&&(f=64),o+=r?64===m?`${l.charAt(u)}${l.charAt(h)}`:64===f?`${l.charAt(u)}${l.charAt(h)}${l.charAt(m)}`:`${l.charAt(u)}${l.charAt(h)}${l.charAt(m)}${l.charAt(f)}`:`${l.charAt(u)}${l.charAt(h)}${l.charAt(m)}${l.charAt(f)}`}return o}(function(e){let t="";const r=new Uint8Array(e);for(const e of r)t+=String.fromCharCode(e);return t}(e)),n=0,a=0;n<s.length;n+=1,a+=1)a>63&&(r+="\r\n",a=0),r+=s[n];return r+="\r\n-----END "+t+"-----\r\n"}var Pr={commonname:{oid:"2.5.4.3",abbreviation:"CN",ValueType:sr},country:{oid:"2.5.4.6",abbreviation:"C",ValueType:hr},locality:{oid:"2.5.4.7",abbreviation:"L",ValueType:hr},state:{oid:"2.5.4.8",abbreviation:"S",ValueType:hr},address:{oid:"2.5.4.9",ValueType:hr},organization:{oid:"2.5.4.10",abbreviation:"O",ValueType:hr},organizationalunit:{oid:"2.5.4.11",abbreviation:"OU",ValueType:hr},zipcode:{oid:"2.5.4.17",ValueType:hr},email:{oid:"1.2.840.113549.1.9.1",ValueType:hr}};Object.values(Pr).forEach(function(e){var t=e.abbreviation,r=function(e,t){var r={};for(var s in e)t.indexOf(s)>=0||Object.prototype.hasOwnProperty.call(e,s)&&(r[s]=e[s]);return r}(e,["abbreviation"]);void 0!==t&&(Pr[t]=Nr({},r))});function Ir(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;if(void 0===crypto)return s("Cannot load WebCrypto, this browser might not be supported");var n=Nr({hashAlgorithm:"SHA-1",signAlgorithm:"RSASSA-PKCS1-V1_5",keySize:2048},t),a=new dt({version:0,attributes:[]});Object.entries(e).forEach(function(e){var t=Er(e,2),r=t[0],s=t[1];if(void 0!==s){var n=Pr[r],i=n.oid,o=n.ValueType;if(void 0!==i&&void 0!==o)return c=i,u=o,void 0!==(l=s)&&a.subject.typesAndValues.push(new Me({type:c,value:new u({value:l})}))}var l,c,u;return!1});var i=void 0,o=void 0;return Promise.resolve().then(function(){var e=Ke(n.signAlgorithm,"generateKey");switch(void 0!==e.algorithm.hash&&(e.algorithm.hash=n.hashAlgorithm),n.signAlgorithm){case"ECDSA":e.algorithm.namedCurve="P-"+n.keySize;break;default:e.algorithm.modulusBits=parseInt(n.keySize,10),e.algorithm.modulusLength=parseInt(n.keySize,10)}return crypto.subtle.generateKey(e.algorithm,!0,e.usages)}).then(function(e){return i=e.publicKey,o=e.privateKey,a.subjectPublicKeyInfo.importKey(i)},function(e){return s("Error during key generation: "+e)}).then(function(){return crypto.subtle.digest({name:"SHA-1"},a.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)}).then(function(e){return a.attributes.push(new Ne({type:"1.2.840.113549.1.9.14",values:[new gt({extensions:[new ft({extnID:"2.5.29.14",critical:!1,extnValue:new Wt({valueHex:e}).toBER(!1)})]}).toSchema()]})),a.sign(o,n.hashAlgorithm)}).then(function(){return crypto.subtle.exportKey("pkcs8",o)}).then(function(e){var t=Hr(e,"PRIVATE KEY"),s=Hr(a.toSchema().toBER(!1),"CERTIFICATE REQUEST");return r(s,t)})}e.generateCSR=Ir,Object.defineProperty(e,"__esModule",{value:!0}),window.generateCSR=Ir});
