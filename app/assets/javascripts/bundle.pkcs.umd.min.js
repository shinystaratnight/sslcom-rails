!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.pkcs12download={})}(this,function(e){"use strict";function t(e,t,r){return e instanceof Object==!1?r:t in e?e[t]:r}function r(e,t=0,r=e.byteLength){let s="";for(const a of new Uint8Array(e,t,r)){const e=a.toString(16).toUpperCase();s=s+(1===e.length?"0":"")+e}return s}function s(e,t,r,s){return t instanceof ArrayBuffer==!1?(e.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===t.byteLength?(e.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):s<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-s<0)||(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1)}function a(e,t){let r=0;for(let s=e.length-1;s>=0;s--)r+=e[e.length-1-s]*Math.pow(2,t*s);return r}function n(e,t,r=0){const s=r||-1;let a=e,n=0,i=Math.pow(2,t);for(let r=1;r<8;r++){if(e<i){let e;if(s<0)e=new ArrayBuffer(r),n=r;else{if(s<r)return new ArrayBuffer(0);e=new ArrayBuffer(s),n=s}const i=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);i[n-e-1]=Math.floor(a/r),a-=i[n-e-1]*r}return e}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function i(...e){let t=0,r=0;for(const r of e)t+=r.byteLength;const s=new ArrayBuffer(t),a=new Uint8Array(s);for(const t of e)a.set(new Uint8Array(t),r),r+=t.byteLength;return s}function o(...e){let t=0,r=0;for(const r of e)t+=r.length;const s=new ArrayBuffer(t),a=new Uint8Array(s);for(const t of e)a.set(t,r),r+=t.length;return a}function l(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),s=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==s[e])return!1;return!0}function c(e,t){const r=e.toString(10),s=t-r.length,a=new Array(s);for(let e=0;e<s;e++)a[e]="0";return a.join("").concat(r)}const u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",h="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function m(e,t=!1,r=!1,s=!1){let a=0,n=0,i=0,o="";const l=t?h:u;if(s){let t=0;for(let r=0;r<e.length;r++)if(0!==e.charCodeAt(r)){t=r;break}e=e.slice(t)}for(;a<e.length;){const t=e.charCodeAt(a++);a>=e.length&&(n=1);const s=e.charCodeAt(a++);a>=e.length&&(i=1);const c=e.charCodeAt(a++),u=t>>2,h=(3&t)<<4|s>>4;let m=(15&s)<<2|c>>6,f=63&c;1===n?m=f=64:1===i&&(f=64),o+=r?64===m?`${l.charAt(u)}${l.charAt(h)}`:64===f?`${l.charAt(u)}${l.charAt(h)}${l.charAt(m)}`:`${l.charAt(u)}${l.charAt(h)}${l.charAt(m)}${l.charAt(f)}`:`${l.charAt(u)}${l.charAt(h)}${l.charAt(m)}${l.charAt(f)}`}return o}function f(e,t=!1,r=!1){const s=t?h:u;function a(e){for(let t=0;t<64;t++)if(s.charAt(t)===e)return t;return 64}function n(e){return 64===e?0:e}let i=0,o="";for(;i<e.length;){const t=a(e.charAt(i++)),r=i>=e.length?0:a(e.charAt(i++)),s=i>=e.length?0:a(e.charAt(i++)),l=i>=e.length?0:a(e.charAt(i++)),c=n(t)<<2|n(r)>>4,u=(15&n(r))<<4|n(s)>>2,h=(3&n(s))<<6|n(l);o+=String.fromCharCode(c),64!==s&&(o+=String.fromCharCode(u)),64!==l&&(o+=String.fromCharCode(h))}if(r){let e=-1;for(let t=o.length-1;t>=0;t--)if(0!==o.charCodeAt(t)){e=t;break}-1!==e&&(o=o.slice(0,e+1))}return o}function d(e){let t="";const r=new Uint8Array(e);for(const e of r)t+=String.fromCharCode(e);return t}function g(e){const t=e.length,r=new ArrayBuffer(t),s=new Uint8Array(r);for(let r=0;r<t;r++)s[r]=e.charCodeAt(r);return r}const p=Math.log(2);const y=[new Uint8Array([1])],v="0123456789";class b{constructor(e={}){this.blockLength=t(e,"blockLength",0),this.error=t(e,"error",""),this.warnings=t(e,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in e?e.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:r(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const w=e=>(class extends e{constructor(e={}){super(e),this.isHexOnly=t(e,"isHexOnly",!1),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const a=new Uint8Array(e,t,r);return 0===a.length?(this.warnings.push("Zero buffer length"),t):(this.valueHex=e.slice(t,t+r),this.blockLength=r,t+r)}toBER(e=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===e?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isHexOnly=this.isHexOnly,e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e}});class k extends(w(b)){constructor(e={}){super(),"idBlock"in e?(this.isHexOnly=t(e.idBlock,"isHexOnly",!1),this.valueHex=t(e.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=t(e.idBlock,"tagClass",-1),this.tagNumber=t(e.idBlock,"tagNumber",-1),this.isConstructed=t(e.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(e=!1){let t,r,s=0;switch(this.tagClass){case 1:s|=0;break;case 2:s|=64;break;case 3:s|=128;break;case 4:s|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(s|=32),this.tagNumber<31&&!this.isHexOnly){if(t=new ArrayBuffer(1),r=new Uint8Array(t),!e){let e=this.tagNumber;s|=e&=31,r[0]=s}return t}if(!1===this.isHexOnly){const a=n(this.tagNumber,7),i=new Uint8Array(a),o=a.byteLength;if(t=new ArrayBuffer(o+1),(r=new Uint8Array(t))[0]=31|s,!e){for(let e=0;e<o-1;e++)r[e+1]=128|i[e];r[o]=i[o-1]}return t}if(t=new ArrayBuffer(this.valueHex.byteLength+1),(r=new Uint8Array(t))[0]=31|s,!1===e){const e=new Uint8Array(this.valueHex);for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHex.byteLength]=e[e.length-1]}return t}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.error="Zero buffer length",-1;const i=192&n[0];switch(i){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&n[0]),this.isHexOnly=!1;const o=31&n[0];if(31!==o)this.tagNumber=o,this.blockLength=1;else{let e=1;this.valueHex=new ArrayBuffer(255);let t=255,r=new Uint8Array(this.valueHex);for(;128&n[e];){if(r[e-1]=127&n[e],++e>=n.length)return this.error="End of input reached before message was fully decoded",-1;if(e===t){t+=255;const e=new ArrayBuffer(t),s=new Uint8Array(e);for(let e=0;e<r.length;e++)s[e]=r[e];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex)}}this.blockLength=e+1,r[e-1]=127&n[e];const s=new ArrayBuffer(e),i=new Uint8Array(s);for(let t=0;t<e;t++)i[t]=r[t];this.valueHex=new ArrayBuffer(e),(r=new Uint8Array(this.valueHex)).set(i),this.blockLength<=9?this.tagNumber=a(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.tagClass=this.tagClass,e.tagNumber=this.tagNumber,e.isConstructed=this.isConstructed,e}}class A extends b{constructor(e={}){super(),"lenBlock"in e?(this.isIndefiniteForm=t(e.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=t(e.lenBlock,"longFormUsed",!1),this.length=t(e.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.error="Zero buffer length",-1;if(255===n[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===n[0],!0===this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&n[0]),!1===this.longFormUsed)return this.length=n[0],this.blockLength=1,t+this.blockLength;const i=127&n[0];if(i>8)return this.error="Too big integer",-1;if(i+1>n.length)return this.error="End of input reached before message was fully decoded",-1;const o=new Uint8Array(i);for(let e=0;e<i;e++)o[e]=n[e+1];return 0===o[i-1]&&this.warnings.push("Needlessly long encoded length"),this.length=a(o,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=i+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=128),t;if(!0===this.longFormUsed){const s=n(this.length,8);if(s.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength+1),!0===e)return t;const a=new Uint8Array(s);(r=new Uint8Array(t))[0]=128|s.byteLength;for(let e=0;e<s.byteLength;e++)r[e+1]=a[e];return t}return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=this.length),t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isIndefiniteForm=this.isIndefiniteForm,e.longFormUsed=this.longFormUsed,e.length=this.length,e}}class B extends b{constructor(e={}){super(e)}static blockName(){return"valueBlock"}fromBER(e,t,r){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}toBER(e=!1){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}}class S extends b{constructor(e={},t=B){super(e),"name"in e&&(this.name=e.name),"optional"in e&&(this.optional=e.optional),"primitiveSchema"in e&&(this.primitiveSchema=e.primitiveSchema),this.idBlock=new k(e),this.lenBlock=new A(e),this.valueBlock=new t(e)}static blockName(){return"BaseBlock"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e=!1){let t;const r=this.idBlock.toBER(e),s=this.valueBlock.toBER(!0);this.lenBlock.length=s.byteLength;const a=this.lenBlock.toBER(e);let n;if(t=i(t=i(r,a),n=!1===e?this.valueBlock.toBER(e):new ArrayBuffer(this.lenBlock.length)),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===e){const e=new Uint8Array(r);e[0]=0,e[1]=0}t=i(t,r)}return t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.idBlock=this.idBlock.toJSON(),e.lenBlock=this.lenBlock.toJSON(),e.valueBlock=this.valueBlock.toJSON(),"name"in this&&(e.name=this.name),"optional"in this&&(e.optional=this.optional),"primitiveSchema"in this&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}}class C extends B{constructor(e={}){super(e),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=t(e,"isHexOnly",!0)}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const a=new Uint8Array(e,t,r);if(0===a.length)return this.warnings.push("Zero buffer length"),t;this.valueHex=new ArrayBuffer(a.length);const n=new Uint8Array(this.valueHex);for(let e=0;e<a.length;e++)n[e]=a[e];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e.isHexOnly=this.isHexOnly,e}}class I extends S{constructor(e={}){super(e,C),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}class N extends B{constructor(e={}){super(e),this.value=t(e,"value",[]),this.isIndefiniteForm=t(e,"isIndefiniteForm",!1)}fromBER(e,t,r){const a=t,n=r;if(!1===s(this,e,t,r))return-1;const i=new Uint8Array(e,t,r);if(0===i.length)return this.warnings.push("Zero buffer length"),t;function o(e,t){return!0===e?1:t}let l=t;for(;o(this.isIndefiniteForm,r)>0;){const t=we(e,l,r);if(-1===t.offset)return this.error=t.result.error,this.warnings.concat(t.result.warnings),-1;if(l=t.offset,this.blockLength+=t.result.blockLength,r-=t.result.blockLength,this.value.push(t.result),!0===this.isIndefiniteForm&&t.result.constructor.blockName()===P.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===P.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=e.slice(a,a+n),l}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){t=i(t,this.value[r].toBER(e))}return t}static blockName(){return"ConstructedValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.isIndefiniteForm=this.isIndefiniteForm,e.value=[];for(let t=0;t<this.value.length;t++)e.value.push(this.value[t].toJSON());return e}}class E extends S{constructor(e={}){super(e,N),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}}class x extends B{constructor(e={}){super(e)}fromBER(e,t,r){return t}toBER(e=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class P extends S{constructor(e={}){super(e,x),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}class D extends B{constructor(e={}){if(super(e),this.value=t(e,"value",!1),this.isHexOnly=t(e,"isHexOnly",!1),"valueHex"in e)this.valueHex=e.valueHex.slice(0);else if(this.valueHex=new ArrayBuffer(1),!0===this.value){var r=new Uint8Array(this.valueHex);r[0]=255}}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const a=new Uint8Array(e,t,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.value=0!==a[0],this.isHexOnly=!0,this.valueHex=new ArrayBuffer(a.length);const n=new Uint8Array(this.valueHex);for(let e=0;e<a.length;e++)n[e]=a[e];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e.isHexOnly=this.isHexOnly,e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e}}class V extends S{constructor(e={}){super(e,D),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}class O extends E{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}class j extends E{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}class H extends S{constructor(e={}){super(e,b),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r}toBER(e=!1){const t=new ArrayBuffer(2);if(!0===e)return t;const r=new Uint8Array(t);return r[0]=5,r[1]=0,t}}class U extends(w(N)){constructor(e={}){super(e),this.isConstructed=t(e,"isConstructed",!1)}fromBER(e,t,r){let s=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,-1===(s=N.prototype.fromBER.call(this,e,t,r)))return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===P.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==L.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e=!1){if(!0===this.isConstructed)return N.prototype.toBER.call(this,e);let t=new ArrayBuffer(this.valueHex.byteLength);return!0===e?t:0===this.valueHex.byteLength?t:t=this.valueHex.slice(0)}static blockName(){return"OctetStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e}}class L extends S{constructor(e={}){super(e,U),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t):super.fromBER(e,t,r)}static blockName(){return"OctetString"}isEqual(e){return e instanceof L!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class K extends(w(N)){constructor(e={}){super(e),this.unusedBits=t(e,"unusedBits",0),this.isConstructed=t(e,"isConstructed",!1),this.blockLength=this.valueHex.byteLength+1}fromBER(e,t,r){if(0===r)return t;let a=-1;if(!0===this.isConstructed){if(-1===(a=N.prototype.fromBER.call(this,e,t,r)))return a;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===P.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==R.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[e].unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[e].unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return a}if(!1===s(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(this.unusedBits=n[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(n.length-1);const i=new Uint8Array(this.valueHex);for(let e=0;e<r-1;e++)i[e]=n[e+1];return this.blockLength=n.length,t+r}toBER(e=!1){if(!0===this.isConstructed)return N.prototype.toBER.call(this,e);if(!0===e)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const t=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),s=new Uint8Array(r);s[0]=this.unusedBits;for(let e=0;e<this.valueHex.byteLength;e++)s[e+1]=t[e];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.unusedBits=this.unusedBits,e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e}}class R extends S{constructor(e={}){super(e,K),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(e,t,r){return 0===r?t:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r))}isEqual(e){return e instanceof R!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class T extends(w(B)){constructor(e={}){super(e),"value"in e&&(this.valueDec=e.value)}set valueHex(e){this._valueHex=e.slice(0),e.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,e.byteLength>0&&(this._valueDec=function(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&0==(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const s=a(r,8),n=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(n);for(let t=0;t<this.valueHex.byteLength;t++)i[t]=e[t];return i[0]&=127,a(i,8)-s}.call(this)))}get valueHex(){return this._valueHex}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this._valueHex=function(e){const t=e<0?-1*e:e;let r=128;for(let s=1;s<8;s++){if(t<=r){if(e<0){const e=n(r-t,8,s);return new Uint8Array(e)[0]|=128,e}let a=n(t,8,s),i=new Uint8Array(a);if(128&i[0]){const e=a.slice(0),t=new Uint8Array(e);a=new ArrayBuffer(a.byteLength+1),i=new Uint8Array(a);for(let r=0;r<e.byteLength;r++)i[r+1]=t[r];i[0]=0}return a}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(e)}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const a=this.fromBER(e,t,r);if(-1===a)return a;const n=new Uint8Array(this._valueHex);if(0===n[0]&&0!=(128&n[1])){const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}else if(0!==s&&this._valueHex.byteLength<s){s-this._valueHex.byteLength>1&&(s=this._valueHex.byteLength+1);const e=new ArrayBuffer(s);new Uint8Array(e).set(n,s-this._valueHex.byteLength),this._valueHex=e.slice(0)}return a}toDER(e=!1){const t=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&t[0]):{const e=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(e);r[0]=0,r.set(t,1),this._valueHex=e.slice(0)}break;case 0===t[0]&&0==(128&t[1]):{const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return-1===s?s:(this.blockLength=r,t+r)}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e}toString(){function e(e,t){const r=new Uint8Array([0]);let s=new Uint8Array(e),a=new Uint8Array(t),n=s.slice(0);const i=n.length-1;let l=a.slice(0);const c=l.length-1;let u=0;let h=0;for(let e=c<i?i:c;e>=0;e--,h++){switch(!0){case h<l.length:u=n[i-h]+l[c-h]+r[0];break;default:u=n[i-h]+r[0]}switch(r[0]=u/10,!0){case h>=n.length:n=o(new Uint8Array([u%10]),n);break;default:n[i-h]=u%10}}return r[0]>0&&(n=o(r,n)),n.slice(0)}function t(e){if(e>=y.length)for(let t=y.length;t<=e;t++){const e=new Uint8Array([0]);let r=y[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const s=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=s[0]/10,r[t]=s[0]%10}e[0]>0&&(r=o(e,r)),y.push(r)}return y[e]}function r(e,t){let r=0,s=new Uint8Array(e),a=new Uint8Array(t),n=s.slice(0);const i=n.length-1;let o=a.slice(0);const l=o.length-1;let c,u=0;for(let e=l;e>=0;e--,u++)switch(c=n[i-u]-o[l-u]-r,!0){case c<0:r=1,n[i-u]=c+10;break;default:r=0,n[i-u]=c}if(r>0)for(let e=i-l+1;e>=0;e--,u++){if(!((c=n[i-u]-r)<0)){r=0,n[i-u]=c;break}r=1,n[i-u]=c+10}return n.slice()}const s=8*this._valueHex.byteLength-1;let a,n=new Uint8Array(8*this._valueHex.byteLength/3),i=0;const l=new Uint8Array(this._valueHex);let c="",u=!1;for(let o=this._valueHex.byteLength-1;o>=0;o--){a=l[o];for(let o=0;o<8;o++){if(1==(1&a))switch(i){case s:n=r(t(i),n),c="-";break;default:n=e(n,t(i))}i++,a>>=1}}for(let e=0;e<n.length;e++)n[e]&&(u=!0),u&&(c+=v.charAt(n[e]));return!1===u&&(c+=v.charAt(0)),c}}class J extends S{constructor(e={}){super(e,T),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(e){return e instanceof J?this.valueBlock.isHexOnly&&e.valueBlock.isHexOnly?l(this.valueBlock.valueHex,e.valueBlock.valueHex):this.valueBlock.isHexOnly===e.valueBlock.isHexOnly&&this.valueBlock.valueDec===e.valueBlock.valueDec:e instanceof ArrayBuffer&&l(this.valueBlock.valueHex,e)}convertToDER(){const e=new J({valueHex:this.valueBlock.valueHex});return e.valueBlock.toDER(),e}convertFromDER(){const e=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,t=new J({valueHex:this.valueBlock.valueHex});return t.valueBlock.fromDER(t.valueBlock.valueHex,0,t.valueBlock.valueHex.byteLength,e),t}}class $ extends J{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}class F extends(w(b)){constructor(e={}){super(e),this.valueDec=t(e,"valueDec",-1),this.isFirstSid=t(e,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(e,t,r){if(0===r)return t;if(!1===s(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);this.valueHex=new ArrayBuffer(r);let i=new Uint8Array(this.valueHex);for(let e=0;e<r&&(i[e]=127&n[e],this.blockLength++,0!=(128&n[e]));e++);const o=new ArrayBuffer(this.blockLength),l=new Uint8Array(o);for(let e=0;e<this.blockLength;e++)l[e]=i[e];return this.valueHex=o.slice(0),i=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===i[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=a(i,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|s[e];return r[this.blockLength-1]=s[this.blockLength-1],t}const s=n(this.valueDec,7);if(0===s.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength),!1===e){const e=new Uint8Array(s);r=new Uint8Array(t);for(let t=0;t<s.byteLength-1;t++)r[t]=128|e[t];r[s.byteLength-1]=e[s.byteLength-1]}return t}toString(){let e="";if(!0===this.isHexOnly)e=r(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e.isFirstSid=this.isFirstSid,e}}class M extends B{constructor(e={}){super(e),this.fromString(t(e,"value",""))}fromBER(e,t,r){let s=t;for(;r>0;){const t=new F;if(-1===(s=t.fromBER(e,s,r)))return this.blockLength=0,this.error=t.error,s;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(0===s.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=i(t,s)}return t}fromString(e){this.value=[];let t=0,r=0,s="",a=!1;do{if(s=-1===(r=e.indexOf(".",t))?e.substr(t):e.substr(t,r-t),t=r+1,a){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return this.value=[],!1}const r=parseInt(s,10);if(isNaN(r))return!0;e.valueDec=r+t,a=!1}else{const e=new F;if(e.valueDec=parseInt(s,10),isNaN(e.valueDec))return!0;0===this.value.length&&(e.isFirstSid=!0,a=!0),this.value.push(e)}}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e=`${e}.`),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.value=this.toString(),e.sidArray=[];for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}class W extends S{constructor(e={}){super(e,M),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}class q extends(w(b)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class _ extends S{constructor(e={}){super(e,q),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(e){const t=unescape(encodeURIComponent(e)),r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r);const s=new Uint8Array(this.valueBlock.valueHex);for(let e=0;e<r;e++)s[e]=t.charCodeAt(e);this.valueBlock.value=e}}class G extends(w(b)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class Q extends S{constructor(e={}){super(e,G),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=2){const t=r[e];r[e]=r[e+1],r[e+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(2*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=n(e.charCodeAt(s),8),a=new Uint8Array(t);if(a.length>2)continue;const i=2-a.length;for(let e=a.length-1;e>=0;e--)r[2*s+e+i]=a[e]}this.valueBlock.value=e}}class z extends(w(b)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class Z extends S{constructor(e={}){super(e,z),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(4*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=n(e.charCodeAt(s),8),a=new Uint8Array(t);if(a.length>4)continue;const i=4-a.length;for(let e=a.length-1;e>=0;e--)r[4*s+e+i]=a[e]}this.valueBlock.value=e}}class Y extends(w(b)){constructor(e={}){super(e),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class X extends S{constructor(e={}){super(e,Y),"value"in e&&this.fromString(e.value)}static blockName(){return"SIMPLESTRING"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}class ee extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}class te extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}class re extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}class se extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}class ae extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}class ne extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}class ie extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}class oe extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}class le extends X{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}class ce extends ie{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi,r=t.exec(e);if(null===r)return void(this.error="Wrong input string for convertion");const s=parseInt(r[1],10);this.year=s>=50?1900+s:2e3+s,this.month=parseInt(r[2],10),this.day=parseInt(r[3],10),this.hour=parseInt(r[4],10),this.minute=parseInt(r[5],10),this.second=parseInt(r[6],10)}toString(){const e=new Array(7);return e[0]=c(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=c(this.month,2),e[2]=c(this.day,2),e[3]=c(this.hour,2),e[4]=c(this.minute,2),e[5]=c(this.second,2),e[6]="Z",e.join("")}static blockName(){return"UTCTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e}}class ue extends ie{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,s="",a="",n=0,i=0,o=0;if("Z"===e[e.length-1])s=e.substr(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");s=e}if(r){if(-1!==s.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==s.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let e=1,t=s.indexOf("+"),r="";if(-1===t&&(t=s.indexOf("-"),e=-1),-1!==t){if(r=s.substr(t+1),s=s.substr(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let a=new Number(r.substr(0,2));if(isNaN(a.valueOf()))throw new Error("Wrong input string for convertion");if(i=e*a,4===r.length){if(a=new Number(r.substr(2,2)),isNaN(a.valueOf()))throw new Error("Wrong input string for convertion");o=e*a}}}let l=s.indexOf(".");if(-1===l&&(l=s.indexOf(",")),-1!==l){const e=new Number(`0${s.substr(l)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");n=e.valueOf(),a=s.substr(0,l)}else a=s;switch(!0){case 8===a.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==l)throw new Error("Wrong input string for convertion");break;case 10===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*n;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*n;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){const e=1e3*n;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for convertion")}const c=t.exec(a);if(null===c)throw new Error("Wrong input string for convertion");for(let e=1;e<c.length;e++)switch(e){case 1:this.year=parseInt(c[e],10);break;case 2:this.month=parseInt(c[e],10);break;case 3:this.day=parseInt(c[e],10);break;case 4:this.hour=parseInt(c[e],10)+i;break;case 5:this.minute=parseInt(c[e],10)+o;break;case 6:this.second=parseInt(c[e],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(){const e=[];return e.push(c(this.year,4)),e.push(c(this.month,2)),e.push(c(this.day,2)),e.push(c(this.hour,2)),e.push(c(this.minute,2)),e.push(c(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(c(this.millisecond,3))),e.push("Z"),e.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e.millisecond=this.millisecond,e}}class he extends _{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}class me extends _{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}class fe extends _{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}class de extends _{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}class ge extends _{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}class pe{constructor(e={}){this.value=t(e,"value",[]),this.optional=t(e,"optional",!1)}}class ye{constructor(e={}){this.name=t(e,"name",""),this.optional=t(e,"optional",!1)}}class ve{constructor(e={}){this.name=t(e,"name",""),this.optional=t(e,"optional",!1),this.value=t(e,"value",new ye),this.local=t(e,"local",!1)}}class be{constructor(e={}){this.data=t(e,"data",new ArrayBuffer(0))}fromBER(e,t,r){this.data=e.slice(t,r)}toBER(e=!1){return this.data}}function we(e,t,r){const a=t;let n=new S({},Object);if(!1===s(new b,e,t,r))return n.error="Wrong input parameters",{offset:-1,result:n};if(0===new Uint8Array(e,t,r).length)return this.error="Zero buffer length",{offset:-1,result:n};let i=n.idBlock.fromBER(e,t,r);if(n.warnings.concat(n.idBlock.warnings),-1===i)return n.error=n.idBlock.error,{offset:-1,result:n};if(t=i,r-=n.idBlock.blockLength,i=n.lenBlock.fromBER(e,t,r),n.warnings.concat(n.lenBlock.warnings),-1===i)return n.error=n.lenBlock.error,{offset:-1,result:n};if(t=i,r-=n.lenBlock.blockLength,!1===n.idBlock.isConstructed&&!0===n.lenBlock.isIndefiniteForm)return n.error="Indefinite length form used for primitive encoding form",{offset:-1,result:n};let o=S;switch(n.idBlock.tagClass){case 1:if(n.idBlock.tagNumber>=37&&!1===n.idBlock.isHexOnly)return n.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:n};switch(n.idBlock.tagNumber){case 0:if(!0===n.idBlock.isConstructed&&n.lenBlock.length>0)return n.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:n};o=P;break;case 1:o=V;break;case 2:o=J;break;case 3:o=R;break;case 4:o=L;break;case 5:o=H;break;case 6:o=W;break;case 10:o=$;break;case 12:o=_;break;case 14:o=ge;break;case 15:return n.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:n};case 16:o=O;break;case 17:o=j;break;case 18:o=ee;break;case 19:o=te;break;case 20:o=re;break;case 21:o=se;break;case 22:o=ae;break;case 23:o=ce;break;case 24:o=ue;break;case 25:o=ne;break;case 26:o=ie;break;case 27:o=oe;break;case 28:o=Z;break;case 29:o=le;break;case 30:o=Q;break;case 31:o=he;break;case 32:o=me;break;case 33:o=fe;break;case 34:o=de;break;default:{let s;(s=!0===n.idBlock.isConstructed?new E:new I).idBlock=n.idBlock,s.lenBlock=n.lenBlock,s.warnings=n.warnings,i=(n=s).fromBER(e,t,r)}}break;case 2:case 3:case 4:default:o=!0===n.idBlock.isConstructed?E:I}return i=(n=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecode=e.valueBeforeDecode.slice(0),r}(n,o)).fromBER(e,t,!0===n.lenBlock.isIndefiniteForm?r:n.lenBlock.length),n.valueBeforeDecode=e.slice(a,a+n.blockLength),{offset:i,result:n}}function ke(e){if(0===e.byteLength){const e=new S({},Object);return e.error="Input buffer has zero length",{offset:-1,result:e}}return we(e,0,e.byteLength)}function Ae(e,t,r){if(r instanceof pe){for(let s=0;s<r.value.length;s++){if(!0===Ae(e,t,r.value[s]).verified)return{verified:!0,result:e}}{const e={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty("name")&&(e.name=r.name),e}}if(r instanceof ye)return r.hasOwnProperty("name")&&(e[r.name]=t),{verified:!0,result:e};if(e instanceof Object==!1)return{verified:!1,result:{error:"Wrong root object"}};if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=r.idBlock.toBER(!1);if(0===s.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(s,0,s.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==t.idBlock.tagClass)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==t.idBlock.tagNumber)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==t.idBlock.isConstructed)return{verified:!1,result:e};if("isHexOnly"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==t.idBlock.isHexOnly)return{verified:!1,result:e};if(!0===r.idBlock.isHexOnly){if("valueHex"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=new Uint8Array(r.idBlock.valueHex),a=new Uint8Array(t.idBlock.valueHex);if(s.length!==a.length)return{verified:!1,result:e};for(let t=0;t<s.length;t++)if(s[t]!==a[1])return{verified:!1,result:e}}if(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(e[r.name]=t)),!0===r.idBlock.isConstructed){let s=0,a={verified:!1},n=r.valueBlock.value.length;if(n>0&&r.valueBlock.value[0]instanceof ve&&(n=t.valueBlock.value.length),0===n)return{verified:!0,result:e};if(0===t.valueBlock.value.length&&0!==r.valueBlock.value.length){let t=!0;for(let e=0;e<r.valueBlock.value.length;e++)t=t&&(r.valueBlock.value[e].optional||!1);return!0===t?{verified:!0,result:e}:(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),e.error="Inconsistent object length",{verified:!1,result:e})}for(let i=0;i<n;i++)if(i-s>=t.valueBlock.value.length){if(!1===r.valueBlock.value[i].optional){const t={verified:!1,result:e};return e.error="Inconsistent length between ASN.1 data and schema",r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}}else if(r.valueBlock.value[0]instanceof ve){if(!1===(a=Ae(e,t.valueBlock.value[i],r.valueBlock.value[0].value)).verified){if(!0!==r.valueBlock.value[0].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),a;s++}if("name"in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let s={};void 0===(s="local"in r.valueBlock.value[0]&&!0===r.valueBlock.value[0].local?t:e)[r.valueBlock.value[0].name]&&(s[r.valueBlock.value[0].name]=[]),s[r.valueBlock.value[0].name].push(t.valueBlock.value[i])}}else if(!1===(a=Ae(e,t.valueBlock.value[i-s],r.valueBlock.value[i])).verified){if(!0!==r.valueBlock.value[i].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),a;s++}if(!1===a.verified){const t={verified:!1,result:e};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}return{verified:!0,result:e}}if("primitiveSchema"in r&&"valueHex"in t.valueBlock){const s=ke(t.valueBlock.valueHex);if(-1===s.offset){const t={verified:!1,result:s.result};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}return Ae(e,s.result,r.primitiveSchema)}return{verified:!0,result:e}}class Be{constructor(e={}){this.algorithmId=t(e,"algorithmId",Be.defaultValues("algorithmId")),"algorithmParams"in e&&(this.algorithmParams=t(e,"algorithmParams",Be.defaultValues("algorithmParams"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"algorithmId":return"";case"algorithmParams":return new ye;default:throw new Error(`Invalid member name for AlgorithmIdentifier class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"algorithmId":return""===t;case"algorithmParams":return t instanceof ye;default:throw new Error(`Invalid member name for AlgorithmIdentifier class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",optional:r.optional||!1,value:[new W({name:r.algorithmIdentifier||""}),new ye({name:r.algorithmParams||"",optional:!0})]})}fromSchema(e){const t=Ae(e,e,Be.schema({names:{algorithmIdentifier:"algorithm",algorithmParams:"params"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier");this.algorithmId=t.result.algorithm.valueBlock.toString(),"params"in t.result&&(this.algorithmParams=t.result.params)}toSchema(){const e=[];return e.push(new W({value:this.algorithmId})),"algorithmParams"in this&&this.algorithmParams instanceof ye==!1&&e.push(this.algorithmParams),new O({value:e})}toJSON(){const e={algorithmId:this.algorithmId};return"algorithmParams"in this&&this.algorithmParams instanceof ye==!1&&(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof Be!=!1&&(this.algorithmId===e.algorithmId&&("algorithmParams"in this?"algorithmParams"in e&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!("algorithmParams"in e)))}}class Se{constructor(e={}){this.x=t(e,"x",Se.defaultValues("x")),this.y=t(e,"y",Se.defaultValues("y")),this.namedCurve=t(e,"namedCurve",Se.defaultValues("namedCurve")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"x":case"y":return new ArrayBuffer(0);case"namedCurve":return"";default:throw new Error(`Invalid member name for ECCPublicKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"x":case"y":return l(t,Se.defaultValues(e));case"namedCurve":return""===t;default:throw new Error(`Invalid member name for ECCPublicKey class: ${e}`)}}static schema(e={}){return new be}fromSchema(e){if(e instanceof ArrayBuffer==!1)throw new Error("Object's schema was not verified against input data for ECPublicKey");const t=new Uint8Array(e);if(4!==t[0])throw new Error("Object's schema was not verified against input data for ECPublicKey");let r;switch(this.namedCurve){case"1.2.840.10045.3.1.7":r=32;break;case"1.3.132.0.34":r=48;break;case"1.3.132.0.35":r=66;break;default:throw new Error(`Incorrect curve OID: ${this.namedCurve}`)}if(e.byteLength!==2*r+1)throw new Error("Object's schema was not verified against input data for ECPublicKey");this.x=e.slice(1,r+1),this.y=e.slice(1+r,2*r+1)}toSchema(){return new be({data:i(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}return{crv:e,x:m(d(this.x),!0,!0,!1),y:m(d(this.y),!0,!0,!1)}}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("x"in e))throw new Error('Absent mandatory parameter "x"');{const r=g(f(e.x,!0));if(r.byteLength<t){this.x=new ArrayBuffer(t);const e=new Uint8Array(this.x),s=new Uint8Array(r);e.set(1,s)}else this.x=r.slice(0,t)}if(!("y"in e))throw new Error('Absent mandatory parameter "y"');{const r=g(f(e.y,!0));if(r.byteLength<t){this.y=new ArrayBuffer(t);const e=new Uint8Array(this.y),s=new Uint8Array(r);e.set(1,s)}else this.y=r.slice(0,t)}}}class Ce{constructor(e={}){this.modulus=t(e,"modulus",Ce.defaultValues("modulus")),this.publicExponent=t(e,"publicExponent",Ce.defaultValues("publicExponent")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"modulus":case"publicExponent":return new J;default:throw new Error(`Invalid member name for RSAPublicKey class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.modulus||""}),new J({name:r.publicExponent||""})]})}fromSchema(e){const t=Ae(e,e,Ce.schema({names:{modulus:"modulus",publicExponent:"publicExponent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPublicKey");this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new O({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:m(d(this.modulus.valueBlock.valueHex),!0,!0,!0),e:m(d(this.publicExponent.valueBlock.valueHex),!0,!0,!0)}}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');{const t=g(f(e.n,!0));this.modulus=new J({valueHex:t.slice(0,Math.pow(2,function(e){const t=Math.log(e)/p,r=Math.floor(t),s=Math.round(t);return r===s?r:s}(t.byteLength)))})}if(!("e"in e))throw new Error('Absent mandatory parameter "e"');this.publicExponent=new J({valueHex:g(f(e.e,!0)).slice(0,3)})}}class Ie{constructor(e={}){this.algorithm=t(e,"algorithm",Ie.defaultValues("algorithm")),this.subjectPublicKey=t(e,"subjectPublicKey",Ie.defaultValues("subjectPublicKey")),"parsedKey"in e&&(this.parsedKey=t(e,"parsedKey",Ie.defaultValues("parsedKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"algorithm":return new Be;case"subjectPublicKey":return new R;default:throw new Error(`Invalid member name for PublicKeyInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Be.schema(r.algorithm||{}),new R({name:r.subjectPublicKey||""})]})}fromSchema(e){const t=Ae(e,e,Ie.schema({names:{algorithm:{names:{blockName:"algorithm"}},subjectPublicKey:"subjectPublicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PUBLIC_KEY_INFO");switch(this.algorithm=new Be({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey,this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams instanceof W)try{this.parsedKey=new Se({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHex})}catch(e){}break;case"1.2.840.113549.1.1.1":{const e=ke(this.subjectPublicKey.valueBlock.valueHex);if(-1!==e.offset)try{this.parsedKey=new Ce({schema:e.result})}catch(e){}}}}toSchema(){return new O({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if("parsedKey"in this==!1)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};const e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const r of Object.keys(t))e[r]=t[r];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new Se({json:e}),this.algorithm=new Be({algorithmId:"1.2.840.10045.2.1",algorithmParams:new W({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Ce({json:e}),this.algorithm=new Be({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new H});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.subjectPublicKey=new R({valueHex:this.parsedKey.toSchema().toBER(!1)})}}importKey(e){let t=Promise.resolve();const r=this;if(void 0===e)return Promise.reject("Need to provide publicKey input parameter");const s=Re();return void 0===s?Promise.reject("Unable to create WebCrypto object"):t=(t=t.then(()=>s.exportKey("spki",e))).then(e=>{const t=ke(e);try{r.fromSchema(t.result)}catch(e){return Promise.reject("Error during initializing object from schema")}},e=>Promise.reject(`Error during exporting public key: ${e}`))}}class Ne{constructor(e={}){this.type=t(e,"type",Ne.defaultValues("type")),this.values=t(e,"values",Ne.defaultValues("values")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return"";case"values":return[];default:throw new Error(`Invalid member name for Attribute class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"type":return""===t;case"values":return 0===t.length;default:throw new Error(`Invalid member name for Attribute class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.type||""}),new j({name:r.setName||"",value:[new ve({name:r.values||"",value:new ye})]})]})}fromSchema(e){const t=Ae(e,e,Ne.schema({names:{type:"type",values:"values"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ATTRIBUTE");this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new O({value:[new W({value:this.type}),new j({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,e=>e.toJSON())}}}class Ee{constructor(e={}){this.version=t(e,"version",Ee.defaultValues("version")),this.privateKey=t(e,"privateKey",Ee.defaultValues("privateKey")),"namedCurve"in e&&(this.namedCurve=t(e,"namedCurve",Ee.defaultValues("namedCurve"))),"publicKey"in e&&(this.publicKey=t(e,"publicKey",Ee.defaultValues("publicKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 1;case"privateKey":return new L;case"namedCurve":return"";case"publicKey":return new Se;default:throw new Error(`Invalid member name for ECCPrivateKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return t===Ee.defaultValues(e);case"privateKey":return t.isEqual(Ee.defaultValues(e));case"namedCurve":return""===t;case"publicKey":return Se.compareWithDefault("namedCurve",t.namedCurve)&&Se.compareWithDefault("x",t.x)&&Se.compareWithDefault("y",t.y);default:throw new Error(`Invalid member name for ECCPrivateKey class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.version||""}),new L({name:r.privateKey||""}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new W({name:r.namedCurve||""})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new R({name:r.publicKey||""})]})]})}fromSchema(e){const t=Ae(e,e,Ee.schema({names:{version:"version",privateKey:"privateKey",namedCurve:"namedCurve",publicKey:"publicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ECPrivateKey");if(this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,"namedCurve"in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),"publicKey"in t.result){const e={schema:t.result.publicKey.valueBlock.valueHex};"namedCurve"in this&&(e.namedCurve=this.namedCurve),this.publicKey=new Se(e)}}toSchema(){const e=[new J({value:this.version}),this.privateKey];return"namedCurve"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:[new W({value:this.namedCurve})]})),"publicKey"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:1},value:[new R({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new O({value:e})}toJSON(){if("namedCurve"in this==!1||Ee.compareWithDefault("namedCurve",this.namedCurve))throw new Error('Not enough information for making JSON: absent "namedCurve" value');let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}const t={crv:e,d:m(d(this.privateKey.valueBlock.valueHex),!0,!0,!1)};if("publicKey"in this){const e=this.publicKey.toJSON();t.x=e.x,t.y=e.y}return t}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("d"in e))throw new Error('Absent mandatory parameter "d"');{const r=g(f(e.d,!0));if(r.byteLength<t){const e=new ArrayBuffer(t),s=new Uint8Array(e),a=new Uint8Array(r);s.set(1,a),this.privateKey=new L({valueHex:e})}else this.privateKey=new L({valueHex:r.slice(0,t)})}"x"in e&&"y"in e&&(this.publicKey=new Se({json:e}))}}class xe{constructor(e={}){this.prime=t(e,"prime",xe.defaultValues("prime")),this.exponent=t(e,"exponent",xe.defaultValues("exponent")),this.coefficient=t(e,"coefficient",xe.defaultValues("coefficient")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"prime":case"exponent":case"coefficient":return new J;default:throw new Error(`Invalid member name for OtherPrimeInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.prime||""}),new J({name:r.exponent||""}),new J({name:r.coefficient||""})]})}fromSchema(e){const t=Ae(e,e,xe.schema({names:{prime:"prime",exponent:"exponent",coefficient:"coefficient"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherPrimeInfo");this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new O({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:m(d(this.prime.valueBlock.valueHex),!0,!0),d:m(d(this.exponent.valueBlock.valueHex),!0,!0),t:m(d(this.coefficient.valueBlock.valueHex),!0,!0)}}fromJSON(e){if(!("r"in e))throw new Error('Absent mandatory parameter "r"');if(this.prime=new J({valueHex:g(f(e.r,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.exponent=new J({valueHex:g(f(e.d,!0))}),!("t"in e))throw new Error('Absent mandatory parameter "t"');this.coefficient=new J({valueHex:g(f(e.t,!0))})}}class Pe{constructor(e={}){this.version=t(e,"version",Pe.defaultValues("version")),this.modulus=t(e,"modulus",Pe.defaultValues("modulus")),this.publicExponent=t(e,"publicExponent",Pe.defaultValues("publicExponent")),this.privateExponent=t(e,"privateExponent",Pe.defaultValues("privateExponent")),this.prime1=t(e,"prime1",Pe.defaultValues("prime1")),this.prime2=t(e,"prime2",Pe.defaultValues("prime2")),this.exponent1=t(e,"exponent1",Pe.defaultValues("exponent1")),this.exponent2=t(e,"exponent2",Pe.defaultValues("exponent2")),this.coefficient=t(e,"coefficient",Pe.defaultValues("coefficient")),"otherPrimeInfos"in e&&(this.otherPrimeInfos=t(e,"otherPrimeInfos",Pe.defaultValues("otherPrimeInfos"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 0;case"modulus":case"publicExponent":case"privateExponent":case"prime1":case"prime2":case"exponent1":case"exponent2":case"coefficient":return new J;case"otherPrimeInfos":return[];default:throw new Error(`Invalid member name for RSAPrivateKey class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.version||""}),new J({name:r.modulus||""}),new J({name:r.publicExponent||""}),new J({name:r.privateExponent||""}),new J({name:r.prime1||""}),new J({name:r.prime2||""}),new J({name:r.exponent1||""}),new J({name:r.exponent2||""}),new J({name:r.coefficient||""}),new O({optional:!0,value:[new ve({name:r.otherPrimeInfosName||"",value:xe.schema(r.otherPrimeInfo||{})})]})]})}fromSchema(e){const t=Ae(e,e,Pe.schema({names:{version:"version",modulus:"modulus",publicExponent:"publicExponent",privateExponent:"privateExponent",prime1:"prime1",prime2:"prime2",exponent1:"exponent1",exponent2:"exponent2",coefficient:"coefficient",otherPrimeInfo:{names:{blockName:"otherPrimeInfos"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPrivateKey");this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),"otherPrimeInfos"in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,e=>new xe({schema:e})))}toSchema(){const e=[];return e.push(new J({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),"otherPrimeInfos"in this&&e.push(new O({value:Array.from(this.otherPrimeInfos,e=>e.toSchema())})),new O({value:e})}toJSON(){const e={n:m(d(this.modulus.valueBlock.valueHex),!0,!0,!0),e:m(d(this.publicExponent.valueBlock.valueHex),!0,!0,!0),d:m(d(this.privateExponent.valueBlock.valueHex),!0,!0,!0),p:m(d(this.prime1.valueBlock.valueHex),!0,!0,!0),q:m(d(this.prime2.valueBlock.valueHex),!0,!0,!0),dp:m(d(this.exponent1.valueBlock.valueHex),!0,!0,!0),dq:m(d(this.exponent2.valueBlock.valueHex),!0,!0,!0),qi:m(d(this.coefficient.valueBlock.valueHex),!0,!0,!0)};return"otherPrimeInfos"in this&&(e.oth=Array.from(this.otherPrimeInfos,e=>e.toJSON())),e}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');if(this.modulus=new J({valueHex:g(f(e.n,!0,!0))}),!("e"in e))throw new Error('Absent mandatory parameter "e"');if(this.publicExponent=new J({valueHex:g(f(e.e,!0,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.privateExponent=new J({valueHex:g(f(e.d,!0,!0))}),!("p"in e))throw new Error('Absent mandatory parameter "p"');if(this.prime1=new J({valueHex:g(f(e.p,!0,!0))}),!("q"in e))throw new Error('Absent mandatory parameter "q"');if(this.prime2=new J({valueHex:g(f(e.q,!0,!0))}),!("dp"in e))throw new Error('Absent mandatory parameter "dp"');if(this.exponent1=new J({valueHex:g(f(e.dp,!0,!0))}),!("dq"in e))throw new Error('Absent mandatory parameter "dq"');if(this.exponent2=new J({valueHex:g(f(e.dq,!0,!0))}),!("qi"in e))throw new Error('Absent mandatory parameter "qi"');this.coefficient=new J({valueHex:g(f(e.qi,!0,!0))}),"oth"in e&&(this.otherPrimeInfos=Array.from(e.oth,e=>new xe({json:e})))}}class De{constructor(e={}){this.version=t(e,"version",De.defaultValues("version")),this.privateKeyAlgorithm=t(e,"privateKeyAlgorithm",De.defaultValues("privateKeyAlgorithm")),this.privateKey=t(e,"privateKey",De.defaultValues("privateKey")),"attributes"in e&&(this.attributes=t(e,"attributes",De.defaultValues("attributes"))),"parsedKey"in e&&(this.parsedKey=t(e,"parsedKey",De.defaultValues("parsedKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 0;case"privateKeyAlgorithm":return new Be;case"privateKey":return new L;case"attributes":return[];default:throw new Error(`Invalid member name for PrivateKeyInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.version||""}),Be.schema(r.privateKeyAlgorithm||{}),new L({name:r.privateKey||""}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ve({name:r.attributes||"",value:Ne.schema()})]})]})}fromSchema(e){const t=Ae(e,e,De.schema({names:{version:"version",privateKeyAlgorithm:{names:{blockName:"privateKeyAlgorithm"}},privateKey:"privateKey",attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PKCS8");switch(this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new Be({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,"attributes"in t.result&&(this.attributes=Array.from(t.result.attributes,e=>new Ne({schema:e}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{const e=ke(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new Pe({schema:e.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof W){const e=ke(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new Ee({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:e.result}))}}}toSchema(){const e=[new J({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return"attributes"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new O({value:e})}toJSON(){if("parsedKey"in this==!1){const e={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return"attributes"in this&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}const e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const r of Object.keys(t))e[r]=t[r];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new Ee({json:e}),this.privateKeyAlgorithm=new Be({algorithmId:"1.2.840.10045.2.1",algorithmParams:new W({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Pe({json:e}),this.privateKeyAlgorithm=new Be({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new H});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.privateKey=new L({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}class Ve{constructor(e={}){if(this.contentType=t(e,"contentType",Ve.defaultValues("contentType")),this.contentEncryptionAlgorithm=t(e,"contentEncryptionAlgorithm",Ve.defaultValues("contentEncryptionAlgorithm")),"encryptedContent"in e&&(this.encryptedContent=e.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed)){const e=new L({idBlock:{isConstructed:!0},isConstructed:!0});let t=0,r=this.encryptedContent.valueBlock.valueHex.byteLength;for(;r>0;){const s=new Uint8Array(this.encryptedContent.valueBlock.valueHex,t,t+1024>this.encryptedContent.valueBlock.valueHex.byteLength?this.encryptedContent.valueBlock.valueHex.byteLength-t:1024),a=new ArrayBuffer(s.length),n=new Uint8Array(a);for(let e=0;e<n.length;e++)n[e]=s[e];e.valueBlock.value.push(new L({valueHex:a})),r-=s.length,t+=s.length}this.encryptedContent=e}"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"contentType":return"";case"contentEncryptionAlgorithm":return new Be;case"encryptedContent":return new L;default:throw new Error(`Invalid member name for EncryptedContentInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"contentType":return""===t;case"contentEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"encryptedContent":return t.isEqual(Ve.defaultValues(e));default:throw new Error(`Invalid member name for EncryptedContentInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.contentType||""}),Be.schema(r.contentEncryptionAlgorithm||{}),new pe({value:[new E({name:r.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0},value:[new ve({value:new L})]}),new I({name:r.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){const t=Ae(e,e,Ve.schema({names:{contentType:"contentType",contentEncryptionAlgorithm:{names:{blockName:"contentEncryptionAlgorithm"}},encryptedContent:"encryptedContent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EncryptedContentInfo");this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new Be({schema:t.result.contentEncryptionAlgorithm}),"encryptedContent"in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){const e={isIndefiniteForm:!1},t=[];if(t.push(new W({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),"encryptedContent"in this){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;const r=this.encryptedContent;r.idBlock.tagClass=3,r.idBlock.tagNumber=0,r.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(r)}return new O({lenBlock:e,value:t})}toJSON(){const e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return"encryptedContent"in this&&(e.encryptedContent=this.encryptedContent.toJSON()),e}}class Oe{constructor(e={}){this.hashAlgorithm=t(e,"hashAlgorithm",Oe.defaultValues("hashAlgorithm")),this.maskGenAlgorithm=t(e,"maskGenAlgorithm",Oe.defaultValues("maskGenAlgorithm")),this.saltLength=t(e,"saltLength",Oe.defaultValues("saltLength")),this.trailerField=t(e,"trailerField",Oe.defaultValues("trailerField")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new Be({algorithmId:"1.3.14.3.2.26",algorithmParams:new H});case"maskGenAlgorithm":return new Be({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new Be({algorithmId:"1.3.14.3.2.26",algorithmParams:new H}).toSchema()});case"saltLength":return 20;case"trailerField":return 1;default:throw new Error(`Invalid member name for RSASSAPSSParams class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new E({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[Be.schema(r.hashAlgorithm||{})]}),new E({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[Be.schema(r.maskGenAlgorithm||{})]}),new E({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new J({name:r.saltLength||""})]}),new E({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new J({name:r.trailerField||""})]})]})}fromSchema(e){const t=Ae(e,e,Oe.schema({names:{hashAlgorithm:{names:{blockName:"hashAlgorithm"}},maskGenAlgorithm:{names:{blockName:"maskGenAlgorithm"}},saltLength:"saltLength",trailerField:"trailerField"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSASSA_PSS_params");"hashAlgorithm"in t.result&&(this.hashAlgorithm=new Be({schema:t.result.hashAlgorithm})),"maskGenAlgorithm"in t.result&&(this.maskGenAlgorithm=new Be({schema:t.result.maskGenAlgorithm})),"saltLength"in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),"trailerField"in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){const e=[];return this.hashAlgorithm.isEqual(Oe.defaultValues("hashAlgorithm"))||e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(Oe.defaultValues("maskGenAlgorithm"))||e.push(new E({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==Oe.defaultValues("saltLength")&&e.push(new E({idBlock:{tagClass:3,tagNumber:2},value:[new J({value:this.saltLength})]})),this.trailerField!==Oe.defaultValues("trailerField")&&e.push(new E({idBlock:{tagClass:3,tagNumber:3},value:[new J({value:this.trailerField})]})),new O({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(Oe.defaultValues("hashAlgorithm"))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(Oe.defaultValues("maskGenAlgorithm"))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==Oe.defaultValues("saltLength")&&(e.saltLength=this.saltLength),this.trailerField!==Oe.defaultValues("trailerField")&&(e.trailerField=this.trailerField),e}}class je{constructor(e={}){this.salt=t(e,"salt",je.defaultValues("salt")),this.iterationCount=t(e,"iterationCount",je.defaultValues("iterationCount")),"keyLength"in e&&(this.keyLength=t(e,"keyLength",je.defaultValues("keyLength"))),"prf"in e&&(this.prf=t(e,"prf",je.defaultValues("prf"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"salt":return{};case"iterationCount":return-1;case"keyLength":return 0;case"prf":return new Be({algorithmId:"1.3.14.3.2.26",algorithmParams:new H});default:throw new Error(`Invalid member name for PBKDF2Params class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new pe({value:[new L({name:r.saltPrimitive||""}),Be.schema(r.saltConstructed||{})]}),new J({name:r.iterationCount||""}),new J({name:r.keyLength||"",optional:!0}),Be.schema(r.prf||{names:{optional:!0}})]})}fromSchema(e){const t=Ae(e,e,je.schema({names:{saltPrimitive:"salt",saltConstructed:{names:{blockName:"salt"}},iterationCount:"iterationCount",keyLength:"keyLength",prf:{names:{blockName:"prf",optional:!0}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBKDF2_params");this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,"keyLength"in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),"prf"in t.result&&(this.prf=new Be({schema:t.result.prf}))}toSchema(){const e=[];return e.push(this.salt),e.push(new J({value:this.iterationCount})),"keyLength"in this&&je.defaultValues("keyLength")!==this.keyLength&&e.push(new J({value:this.keyLength})),"prf"in this&&!1===je.defaultValues("prf").isEqual(this.prf)&&e.push(this.prf.toSchema()),new O({value:e})}toJSON(){const e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return"keyLength"in this&&je.defaultValues("keyLength")!==this.keyLength&&(e.keyLength=this.keyLength),"prf"in this&&!1===je.defaultValues("prf").isEqual(this.prf)&&(e.prf=this.prf.toJSON()),e}}class He{constructor(e={}){this.keyDerivationFunc=t(e,"keyDerivationFunc",He.defaultValues("keyDerivationFunc")),this.encryptionScheme=t(e,"encryptionScheme",He.defaultValues("encryptionScheme")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyDerivationFunc":case"encryptionScheme":return new Be;default:throw new Error(`Invalid member name for PBES2Params class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Be.schema(r.keyDerivationFunc||{}),Be.schema(r.encryptionScheme||{})]})}fromSchema(e){const t=Ae(e,e,He.schema({names:{keyDerivationFunc:{names:{blockName:"keyDerivationFunc"}},encryptionScheme:{names:{blockName:"encryptionScheme"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBES2_params");this.keyDerivationFunc=new Be({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new Be({schema:t.result.encryptionScheme})}toSchema(){return new O({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}function Ue(e,t,r,s,a,n){let i,o;const l=[];switch(t.toUpperCase()){case"SHA-1":i=20,o=64;break;case"SHA-256":i=32,o=64;break;case"SHA-384":i=48,o=128;break;case"SHA-512":i=64,o=128;break;default:throw new Error("Unsupported hashing algorithm")}const c=new Uint8Array(s),u=new ArrayBuffer(2*s.byteLength+2),h=new Uint8Array(u);for(let e=0;e<c.length;e++)h[2*e]=0,h[2*e+1]=c[e];h[h.length-2]=0,h[h.length-1]=0,s=u.slice(0);const m=new ArrayBuffer(o),f=new Uint8Array(m);for(let e=0;e<m.byteLength;e++)f[e]=3;const d=a.byteLength,g=o*Math.ceil(d/o),p=new ArrayBuffer(g),y=new Uint8Array(p),v=new Uint8Array(a);for(let e=0;e<g;e++)y[e]=v[e%d];const b=s.byteLength,w=o*Math.ceil(b/o),k=new ArrayBuffer(w),A=new Uint8Array(k),B=new Uint8Array(s);for(let e=0;e<w;e++)A[e]=B[e%b];const S=p.byteLength+k.byteLength;let C=new ArrayBuffer(S),I=new Uint8Array(C);I.set(y),I.set(A,y.length);const N=Math.ceil((r>>3)/i);let E=Promise.resolve(C);for(let r=0;r<=N;r++){E=E.then(e=>{const t=new ArrayBuffer(m.byteLength+e.byteLength),r=new Uint8Array(t);return r.set(f),r.set(I,f.length),t});for(let r=0;r<n;r++)E=E.then(r=>e.digest({name:t},new Uint8Array(r)));E=E.then(e=>{const t=new ArrayBuffer(o),r=new Uint8Array(t);for(let s=0;s<t.byteLength;s++)r[s]=e[s%e.length];const s=Math.ceil(d/o)+Math.ceil(b/o),a=[];let n=0,i=o;for(let e=0;e<s;e++){const e=Array.from(new Uint8Array(C.slice(n,n+i)));(n+=o)+o>C.byteLength&&(i=C.byteLength-n);let s=511;for(let a=t.byteLength-1;a>=0;a--)s>>=8,s+=r[a]+e[a],e[a]=255&s;a.push(...e)}return C=new ArrayBuffer(a.length),(I=new Uint8Array(C)).set(a),l.push(...new Uint8Array(e)),C})}return E=E.then(()=>{const e=new ArrayBuffer(r>>3);return new Uint8Array(e).set(new Uint8Array(l).slice(0,r>>3)),e})}let Le={name:"none",crypto:null,subtle:null};function Ke(){return Le}!function(){if("undefined"!=typeof self&&"crypto"in self){let e="webcrypto";const r=self.crypto;let s=null;if("webkitSubtle"in self.crypto){try{s=self.crypto.webkitSubtle}catch(e){s=self.crypto.subtle}e="safari"}"subtle"in self.crypto&&(s=self.crypto.subtle),Le={name:e,crypto:r,subtle:new class{constructor(e={}){this.crypto=t(e,"crypto",{}),this.subtle=t(e,"subtle",{}),this.name=t(e,"name","")}importKey(e,t,r,s,a){let n={};switch(t instanceof Uint8Array&&(t=t.buffer),e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,r,s,a);case"spki":{const e=ke(t);if(-1===e.offset)return Promise.reject("Incorrect keyData");const i=new Ie;try{i.fromSchema(e.result)}catch(e){return Promise.reject("Incorrect keyData")}switch(r.name.toUpperCase()){case"RSA-PSS":switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="PS1";break;case"SHA-256":n.alg="PS256";break;case"SHA-384":n.alg="PS384";break;case"SHA-512":n.alg="PS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(a=["verify"],n.kty="RSA",n.ext=s,n.key_ops=a,"1.2.840.113549.1.1.1"!==i.algorithm.algorithmId)return Promise.reject(`Incorrect public key algorithm: ${i.algorithm.algorithmId}`);if("alg"in n==0)switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RS1";break;case"SHA-256":n.alg="RS256";break;case"SHA-384":n.alg="RS384";break;case"SHA-512":n.alg="RS512";break;default:return Promise.reject(`Incorrect public key algorithm: ${i.algorithm.algorithmId}`)}const e=i.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;case"ECDSA":a=["verify"];case"ECDH":{if(n={kty:"EC",ext:s,key_ops:a},"1.2.840.10045.2.1"!==i.algorithm.algorithmId)return Promise.reject(`Incorrect public key algorithm: ${i.algorithm.algorithmId}`);const e=i.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;case"RSA-OAEP":{if(n.kty="RSA",n.ext=s,n.key_ops=a,"safari"===this.name.toLowerCase())n.alg="RSA-OAEP";else switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RSA-OAEP-1";break;case"SHA-256":n.alg="RSA-OAEP-256";break;case"SHA-384":n.alg="RSA-OAEP-384";break;case"SHA-512":n.alg="RSA-OAEP-512";break;default:return Promise.reject(`Incorrect public key algorithm: ${i.algorithm.algorithmId}`)}const e=i.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;default:return Promise.reject(`Incorrect algorithm name: ${r.name.toUpperCase()}`)}}break;case"pkcs8":{const e=new De,i=ke(t);if(-1===i.offset)return Promise.reject("Incorrect keyData");try{e.fromSchema(i.result)}catch(e){return Promise.reject("Incorrect keyData")}switch(r.name.toUpperCase()){case"RSA-PSS":switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="PS1";break;case"SHA-256":n.alg="PS256";break;case"SHA-384":n.alg="PS384";break;case"SHA-512":n.alg="PS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(a=["sign"],n.kty="RSA",n.ext=s,n.key_ops=a,"1.2.840.113549.1.1.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject(`Incorrect private key algorithm: ${e.privateKeyAlgorithm.algorithmId}`);if("alg"in n==0)switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RS1";break;case"SHA-256":n.alg="RS256";break;case"SHA-384":n.alg="RS384";break;case"SHA-512":n.alg="RS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}const t=e.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;case"ECDSA":a=["sign"];case"ECDH":{if(n={kty:"EC",ext:s,key_ops:a},"1.2.840.10045.2.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject(`Incorrect algorithm: ${e.privateKeyAlgorithm.algorithmId}`);const t=e.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;case"RSA-OAEP":{if(n.kty="RSA",n.ext=s,n.key_ops=a,"safari"===this.name.toLowerCase())n.alg="RSA-OAEP";else switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RSA-OAEP-1";break;case"SHA-256":n.alg="RSA-OAEP-256";break;case"SHA-384":n.alg="RSA-OAEP-384";break;case"SHA-512":n.alg="RSA-OAEP-512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}const t=e.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;default:return Promise.reject(`Incorrect algorithm name: ${r.name.toUpperCase()}`)}}break;case"jwk":n=t;break;default:return Promise.reject(`Incorrect format: ${e}`)}return"safari"===this.name.toLowerCase()?Promise.resolve().then(()=>this.subtle.importKey("jwk",g(JSON.stringify(n)),r,s,a)).then(e=>e,e=>this.subtle.importKey("jwk",n,r,s,a)):this.subtle.importKey("jwk",n,r,s,a)}exportKey(e,t){let r=this.subtle.exportKey("jwk",t);switch("safari"===this.name.toLowerCase()&&(r=r.then(e=>e instanceof ArrayBuffer?JSON.parse(d(e)):e)),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":r=r.then(e=>{const t=new Ie;try{t.fromJSON(e)}catch(e){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"pkcs8":r=r.then(e=>{const t=new De;try{t.fromJSON(e)}catch(e){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"jwk":break;default:return Promise.reject(`Incorrect format: ${e}`)}return r}convert(e,t,r,s,a,n){switch(e.toLowerCase()){case"raw":switch(t.toLowerCase()){case"raw":return Promise.resolve(r);case"spki":return Promise.resolve().then(()=>this.importKey("raw",r,s,a,n)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("raw",r,s,a,n)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve().then(()=>this.importKey("raw",r,s,a,n)).then(e=>this.exportKey("jwk",e));default:return Promise.reject(`Incorrect outputFormat: ${t}`)}case"spki":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("spki",r,s,a,n)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve(r);case"pkcs8":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"jwk":return Promise.resolve().then(()=>this.importKey("spki",r,s,a,n)).then(e=>this.exportKey("jwk",e));default:return Promise.reject(`Incorrect outputFormat: ${t}`)}case"pkcs8":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("pkcs8",r,s,a,n)).then(e=>this.exportKey("raw",e));case"spki":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"pkcs8":return Promise.resolve(r);case"jwk":return Promise.resolve().then(()=>this.importKey("pkcs8",r,s,a,n)).then(e=>this.exportKey("jwk",e));default:return Promise.reject(`Incorrect outputFormat: ${t}`)}case"jwk":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("jwk",r,s,a,n)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve().then(()=>this.importKey("jwk",r,s,a,n)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("jwk",r,s,a,n)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve(r);default:return Promise.reject(`Incorrect outputFormat: ${t}`)}default:return Promise.reject(`Incorrect inputFormat: ${e}`)}}encrypt(...e){return this.subtle.encrypt(...e)}decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}verify(...e){return this.subtle.verify(...e)}digest(...e){return this.subtle.digest(...e)}generateKey(...e){return this.subtle.generateKey(...e)}deriveKey(...e){return this.subtle.deriveKey(...e)}deriveBits(...e){return this.subtle.deriveBits(...e)}wrapKey(...e){return this.subtle.wrapKey(...e)}unwrapKey(...e){return this.subtle.unwrapKey(...e)}getRandomValues(e){if("getRandomValues"in this.crypto==0)throw new Error("No support for getRandomValues");return this.crypto.getRandomValues(e)}getAlgorithmByOID(e){switch(e){case"1.2.840.113549.1.1.1":case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}return{}}getOIDByAlgorithm(e){let t="";switch(e.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.1.1.5";break;case"SHA-256":t="1.2.840.113549.1.1.11";break;case"SHA-384":t="1.2.840.113549.1.1.12";break;case"SHA-512":t="1.2.840.113549.1.1.13"}break;case"RSA-PSS":t="1.2.840.113549.1.1.10";break;case"RSA-OAEP":t="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.10045.4.1";break;case"SHA-256":t="1.2.840.10045.4.3.2";break;case"SHA-384":t="1.2.840.10045.4.3.3";break;case"SHA-512":t="1.2.840.10045.4.3.4"}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":t="1.3.133.16.840.63.0.2";break;case"SHA-256":t="1.3.132.1.11.1";break;case"SHA-384":t="1.3.132.1.11.2";break;case"SHA-512":t="1.3.132.1.11.3"}break;case"AES-CTR":break;case"AES-CBC":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.2";break;case 192:t="2.16.840.1.101.3.4.1.22";break;case 256:t="2.16.840.1.101.3.4.1.42"}break;case"AES-CMAC":break;case"AES-GCM":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.6";break;case 192:t="2.16.840.1.101.3.4.1.26";break;case 256:t="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.4";break;case 192:t="2.16.840.1.101.3.4.1.24";break;case 256:t="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.5";break;case 192:t="2.16.840.1.101.3.4.1.25";break;case 256:t="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.2.7";break;case"SHA-256":t="1.2.840.113549.2.9";break;case"SHA-384":t="1.2.840.113549.2.10";break;case"SHA-512":t="1.2.840.113549.2.11"}break;case"DH":t="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":t="1.3.14.3.2.26";break;case"SHA-256":t="2.16.840.1.101.3.4.2.1";break;case"SHA-384":t="2.16.840.1.101.3.4.2.2";break;case"SHA-512":t="2.16.840.1.101.3.4.2.3";break;case"CONCAT":case"HKDF":break;case"PBKDF2":t="1.2.840.113549.1.5.12";break;case"P-256":t="1.2.840.10045.3.1.7";break;case"P-384":t="1.3.132.0.34";break;case"P-521":t="1.3.132.0.35"}return t}getAlgorithmParameters(e,t){let r={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":r={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":r={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":r={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":r={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;case"exportkey":default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":r={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":r={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":r={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":r={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":switch(t.toLowerCase()){case"derivekey":r={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"HKDF"},usages:[]}}break;case"PBKDF2":switch(t.toLowerCase()){case"derivekey":r={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"PBKDF2"},usages:[]}}}return r}getHashAlgorithm(e){let t="";switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{const r=new Oe({schema:e.algorithmParams});if("hashAlgorithm"in r){const e=this.getAlgorithmByOID(r.hashAlgorithm.algorithmId);if("name"in e==0)return"";t=e.name}else t="SHA-1"}catch(e){}}return t}encryptEncryptedContentInfo(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("contentEncryptionAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "contentEncryptionAlgorithm"');if("hmacHashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hmacHashAlgorithm"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("contentToEncrypt"in e==0)return Promise.reject('Absent mandatory parameter "contentToEncrypt"');if("contentType"in e==0)return Promise.reject('Absent mandatory parameter "contentType"');const t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm);if(""===t)return Promise.reject('Wrong "contentEncryptionAlgorithm" value');const r=this.getOIDByAlgorithm({name:"PBKDF2"});if(""===r)return Promise.reject("Can not find OID for PBKDF2");const s=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}});if(""===s)return Promise.reject(`Incorrect value for "hmacHashAlgorithm": ${e.hmacHashAlgorithm}`);let a=Promise.resolve();const n=new ArrayBuffer(16),i=new Uint8Array(n);this.getRandomValues(i);const o=new ArrayBuffer(64),l=new Uint8Array(o);this.getRandomValues(l);const c=new Uint8Array(e.contentToEncrypt),u=new je({salt:new L({valueHex:o}),iterationCount:e.iterationCount,prf:new Be({algorithmId:s,algorithmParams:new H})});return a=(a=(a=(a=a.then(()=>{const t=new Uint8Array(e.password);return this.importKey("raw",t,"PBKDF2",!1,["deriveKey"])},e=>Promise.reject(e))).then(t=>this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:l,iterations:e.iterationCount},t,e.contentEncryptionAlgorithm,!1,["encrypt"]),e=>Promise.reject(e))).then(t=>this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:i},t,c),e=>Promise.reject(e))).then(s=>{const a=new He({keyDerivationFunc:new Be({algorithmId:r,algorithmParams:u.toSchema()}),encryptionScheme:new Be({algorithmId:t,algorithmParams:new L({valueHex:n})})});return new Ve({contentType:e.contentType,contentEncryptionAlgorithm:new Be({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:a.toSchema()}),encryptedContent:new L({valueHex:s})})},e=>Promise.reject(e))}decryptEncryptedContentInfo(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("encryptedContentInfo"in e==0)return Promise.reject('Absent mandatory parameter "encryptedContentInfo"');if("1.2.840.113549.1.5.13"!==e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)return Promise.reject(`Unknown "contentEncryptionAlgorithm": ${e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);let t,r=Promise.resolve();try{t=new He({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(e){return Promise.reject('Incorrectly encoded "pbes2Parameters"')}let s;try{s=new je({schema:t.keyDerivationFunc.algorithmParams})}catch(e){return Promise.reject('Incorrectly encoded "pbkdf2Params"')}const a=this.getAlgorithmByOID(t.encryptionScheme.algorithmId);if("name"in a==0)return Promise.reject(`Incorrect OID for "contentEncryptionAlgorithm": ${t.encryptionScheme.algorithmId}`);const n=t.encryptionScheme.algorithmParams.valueBlock.valueHex,o=new Uint8Array(n),l=s.salt.valueBlock.valueHex,c=new Uint8Array(l),u=s.iterationCount;let h="SHA-1";if("prf"in s){const e=this.getAlgorithmByOID(s.prf.algorithmId);if("name"in e==0)return Promise.reject("Incorrect OID for HMAC hash algorithm");h=e.hash.name}return r=(r=(r=r.then(()=>this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),e=>Promise.reject(e))).then(e=>this.deriveKey({name:"PBKDF2",hash:{name:h},salt:c,iterations:u},e,a,!1,["decrypt"]),e=>Promise.reject(e))).then(t=>{let r=new ArrayBuffer(0);if(!1===e.encryptedContentInfo.encryptedContent.idBlock.isConstructed)r=e.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else for(const t of e.encryptedContentInfo.encryptedContent.valueBlock.value)r=i(r,t.valueBlock.valueHex);return this.decrypt({name:a.name,iv:o},t,r)},e=>Promise.reject(e))}stampDataWithPassword(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToStamp"in e==0)return Promise.reject('Absent mandatory parameter "contentToStamp"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let r=Promise.resolve();const s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return r=(r=(r=r.then(()=>Ue(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount))).then(e=>this.importKey("raw",new Uint8Array(e),s,!1,["sign"]))).then(t=>this.sign(s,t,new Uint8Array(e.contentToStamp)),e=>Promise.reject(e))}verifyDataStampedWithPassword(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToVerify"in e==0)return Promise.reject('Absent mandatory parameter "contentToVerify"');if("signatureToVerify"in e==0)return Promise.reject('Absent mandatory parameter "signatureToVerify"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let r=Promise.resolve();const s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return r=(r=(r=r.then(()=>Ue(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount))).then(e=>this.importKey("raw",new Uint8Array(e),s,!1,["verify"]))).then(t=>this.verify(s,t,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify)),e=>Promise.reject(e))}getSignatureParameters(e,t="SHA-1"){const r=this.getOIDByAlgorithm({name:t});if(""===r)return Promise.reject(`Unsupported hash algorithm: ${t}`);const s=new Be,a=this.getAlgorithmParameters(e.algorithm.name,"sign");switch(a.algorithm.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":s.algorithmId=this.getOIDByAlgorithm(a.algorithm);break;case"RSA-PSS":{switch(t.toUpperCase()){case"SHA-256":a.algorithm.saltLength=32;break;case"SHA-384":a.algorithm.saltLength=48;break;case"SHA-512":a.algorithm.saltLength=64}const e={};if("SHA-1"!==t.toUpperCase()){const r=this.getOIDByAlgorithm({name:t});if(""===r)return Promise.reject(`Unsupported hash algorithm: ${t}`);e.hashAlgorithm=new Be({algorithmId:r,algorithmParams:new H}),e.maskGenAlgorithm=new Be({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:e.hashAlgorithm.toSchema()})}20!==a.algorithm.saltLength&&(e.saltLength=a.algorithm.saltLength);const r=new Oe(e);s.algorithmId="1.2.840.113549.1.1.10",s.algorithmParams=r.toSchema()}break;default:return Promise.reject(`Unsupported signature algorithm: ${e.algorithm.name}`)}return Promise.resolve().then(()=>({signatureAlgorithm:s,parameters:a}))}signWithPrivateKey(e,t,r){return this.sign(r.algorithm,t,new Uint8Array(e)).then(e=>("ECDSA"===r.algorithm.name&&(e=function(e){if(e.byteLength%2!=0)return new ArrayBuffer(0);const t=e.byteLength/2,r=new ArrayBuffer(t);new Uint8Array(r).set(new Uint8Array(e,0,t));const s=new J({valueHex:r}),a=new ArrayBuffer(t);new Uint8Array(a).set(new Uint8Array(e,t,t));const n=new J({valueHex:a});return new O({value:[s.convertToDER(),n.convertToDER()]}).toBER(!1)}(e)),e),e=>Promise.reject(`Signing error: ${e}`))}verifyWithPublicKey(e,t,r,s){let a=Promise.resolve();const n=this.getHashAlgorithm(s);return""===n?Promise.reject(`Unsupported signature algorithm: ${s.algorithmId}`):a=(a=a.then(()=>{const e=this.getAlgorithmByOID(s.algorithmId);if("name"in e==="")return Promise.reject(`Unsupported public key algorithm: ${s.algorithmId}`);const t=this.getAlgorithmParameters(e.name,"importkey");if("hash"in t.algorithm&&(t.algorithm.hash.name=n),"ECDSA"===e.name){let e=!1;if("algorithmParams"in r.algorithm==1&&"idBlock"in r.algorithm.algorithmParams&&1===r.algorithm.algorithmParams.idBlock.tagClass&&6===r.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)return Promise.reject("Incorrect type for ECDSA public key parameters");const s=this.getAlgorithmByOID(r.algorithm.algorithmParams.valueBlock.toString());if("name"in s==0)return Promise.reject(`Unsupported named curve algorithm: ${r.algorithm.algorithmParams.valueBlock.toString()}`);t.algorithm.namedCurve=s.name}const a=r.toSchema().toBER(!1),i=new Uint8Array(a);return this.importKey("spki",i,t.algorithm,!0,t.usages)})).then(r=>{const a=this.getAlgorithmParameters(r.algorithm.name,"verify");"hash"in a.algorithm&&(a.algorithm.hash.name=n);let i=t.valueBlock.valueHex;if("ECDSA"===r.algorithm.name&&(i=Me(ke(i).result)),"RSA-PSS"===r.algorithm.name){let e;try{e=new Oe({schema:s.algorithmParams})}catch(e){return Promise.reject(e)}a.algorithm.saltLength="saltLength"in e?e.saltLength:20;let t="SHA-1";if("hashAlgorithm"in e){const r=this.getAlgorithmByOID(e.hashAlgorithm.algorithmId);if("name"in r==0)return Promise.reject(`Unrecognized hash algorithm: ${e.hashAlgorithm.algorithmId}`);t=r.name}a.algorithm.hash.name=t}return this.verify(a.algorithm,r,new Uint8Array(i),new Uint8Array(e))})}}({name:e,crypto:self.crypto,subtle:s})}}}();function Re(){if(null!==Le.subtle)return Le.subtle}function Te(e){return Le.subtle.getRandomValues(e)}function Je(e){return Le.subtle.getOIDByAlgorithm(e)}function $e(e,t){return Le.subtle.getAlgorithmParameters(e,t)}function Fe(e){let t=!1,r="";const s=e.trim();for(let e=0;e<s.length;e++)32===s.charCodeAt(e)?!1===t&&(t=!0):(t&&(r+=" ",t=!1),r+=s[e]);return r.toLowerCase()}function Me(e){if(e instanceof O==!1)return new ArrayBuffer(0);if(2!==e.valueBlock.value.length)return new ArrayBuffer(0);if(e.valueBlock.value[0]instanceof J==!1)return new ArrayBuffer(0);if(e.valueBlock.value[1]instanceof J==!1)return new ArrayBuffer(0);const t=e.valueBlock.value[0].convertFromDER(),r=e.valueBlock.value[1].convertFromDER();switch(!0){case t.valueBlock.valueHex.byteLength<r.valueBlock.valueHex.byteLength:{if(r.valueBlock.valueHex.byteLength-t.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=r.valueBlock.valueHex.byteLength,s=new Uint8Array(t.valueBlock.valueHex),a=new ArrayBuffer(e),n=new Uint8Array(a);return n.set(s,1),n[0]=0,i(a,r.valueBlock.valueHex)}case t.valueBlock.valueHex.byteLength>r.valueBlock.valueHex.byteLength:{if(t.valueBlock.valueHex.byteLength-r.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=t.valueBlock.valueHex.byteLength,s=new Uint8Array(r.valueBlock.valueHex),a=new ArrayBuffer(e),n=new Uint8Array(a);return n.set(s,1),n[0]=0,i(t.valueBlock.valueHex,a)}default:if(t.valueBlock.valueHex.byteLength%2){const e=t.valueBlock.valueHex.byteLength+1,s=new Uint8Array(t.valueBlock.valueHex),a=new ArrayBuffer(e),n=new Uint8Array(a);n.set(s,1),n[0]=0;const o=new Uint8Array(r.valueBlock.valueHex),l=new ArrayBuffer(e),c=new Uint8Array(l);return c.set(o,1),c[0]=0,i(a,l)}}return i(t.valueBlock.valueHex,r.valueBlock.valueHex)}function We(e){return Le.subtle.getAlgorithmByOID(e)}function qe(e){return Le.subtle.getHashAlgorithm(e)}function _e(e,t,r,s){switch(e.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":break;default:return Promise.reject(`Unknown hash function: ${e}`)}if(t instanceof ArrayBuffer==!1)return Promise.reject('Please set "Zbuffer" as "ArrayBuffer"');if(0===t.byteLength)return Promise.reject('"Zbuffer" has zero length, error');if(s instanceof ArrayBuffer==!1)return Promise.reject('Please set "SharedInfo" as "ArrayBuffer"');if(r>255)return Promise.reject('Please set "Counter" variable to value less or equal to 255');const a=new ArrayBuffer(4),n=new Uint8Array(a);n[0]=0,n[1]=0,n[2]=0,n[3]=r;let o=new ArrayBuffer(0);const l=Re();return void 0===l?Promise.reject("Unable to create WebCrypto object"):(o=i(o=i(o=i(o,t),a),s),l.digest({name:e},o).then(e=>({counter:r,result:e})))}function Ge(e,t,r,s){let a=0,n=1;const o=[];switch(e.toUpperCase()){case"SHA-1":a=160;break;case"SHA-256":a=256;break;case"SHA-384":a=384;break;case"SHA-512":a=512;break;default:return Promise.reject(`Unknown hash function: ${e}`)}if(t instanceof ArrayBuffer==!1)return Promise.reject('Please set "Zbuffer" as "ArrayBuffer"');if(0===t.byteLength)return Promise.reject('"Zbuffer" has zero length, error');if(s instanceof ArrayBuffer==!1)return Promise.reject('Please set "SharedInfo" as "ArrayBuffer"');const l=r/a;Math.floor(l)>0&&l-(n=Math.floor(l))>0&&n++;for(let r=1;r<=n;r++)o.push(_e(e,t,r,s));return Promise.all(o).then(e=>{let t=new ArrayBuffer(0),s=1,a=!0;for(;a;){a=!1;for(const r of e)if(r.counter===s){t=i(t,r.result),a=!0;break}s++}if(r>>=3,t.byteLength>r){const e=new ArrayBuffer(r),s=new Uint8Array(e),a=new Uint8Array(t);for(let e=0;e<r;e++)s[e]=a[e];return e}return t})}class Qe{constructor(e={}){this.type=t(e,"type",Qe.defaultValues("type")),this.value=t(e,"value",Qe.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return"";case"value":return{};default:throw new Error(`Invalid member name for AttributeTypeAndValue class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.type||""}),new ye({name:r.value||""})]})}fromSchema(e){const t=Ae(e,e,Qe.schema({names:{type:"type",value:"typeValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ATTR_TYPE_AND_VALUE");this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new O({value:[new W({value:this.type}),this.value]})}toJSON(){const e={type:this.type};return 0!==Object.keys(this.value).length?e.value=this.value.toJSON():e.value=this.value,e}isEqual(e){if(e instanceof Qe){if(this.type!==e.type)return!1;if(this.value instanceof _&&e.value instanceof _||this.value instanceof Q&&e.value instanceof Q||this.value instanceof Z&&e.value instanceof Z||this.value instanceof ee&&e.value instanceof ee||this.value instanceof te&&e.value instanceof te||this.value instanceof re&&e.value instanceof re||this.value instanceof se&&e.value instanceof se||this.value instanceof ae&&e.value instanceof ae||this.value instanceof ne&&e.value instanceof ne||this.value instanceof ie&&e.value instanceof ie||this.value instanceof oe&&e.value instanceof oe||this.value instanceof le&&e.value instanceof le){const t=Fe(this.value.valueBlock.value),r=Fe(e.value.valueBlock.value);if(0!==t.localeCompare(r))return!1}else if(!1===l(this.value.valueBeforeDecode,e.value.valueBeforeDecode))return!1;return!0}return e instanceof ArrayBuffer&&l(this.value.valueBeforeDecode,e)}}class ze{constructor(e={}){this.typesAndValues=t(e,"typesAndValues",ze.defaultValues("typesAndValues")),this.valueBeforeDecode=t(e,"valueBeforeDecode",ze.defaultValues("valueBeforeDecode")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"typesAndValues":return[];case"valueBeforeDecode":return new ArrayBuffer(0);default:throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"typesAndValues":return 0===t.length;case"valueBeforeDecode":return 0===t.byteLength;default:throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ve({name:r.repeatedSequence||"",value:new j({value:[new ve({name:r.repeatedSet||"",value:Qe.schema(r.typeAndValue||{})})]})})]})}fromSchema(e){const t=Ae(e,e,ze.schema({names:{blockName:"RDN",repeatedSet:"typesAndValues"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RDN");"typesAndValues"in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,e=>new Qe({schema:e}))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecode}toSchema(){if(0===this.valueBeforeDecode.byteLength)return new O({value:[new j({value:Array.from(this.typesAndValues,e=>e.toSchema())})]});const e=ke(this.valueBeforeDecode);return e.result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,e=>e.toJSON())}}isEqual(e){if(e instanceof ze){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(const[t,r]of this.typesAndValues.entries())if(!1===r.isEqual(e.typesAndValues[t]))return!1;return!0}return e instanceof ArrayBuffer&&l(this.valueBeforeDecode,e)}}class Ze{constructor(e={}){this.type=t(e,"type",Ze.defaultValues("type")),this.value=t(e,"value",Ze.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return 9;case"value":return{};default:throw new Error(`Invalid member name for GeneralName class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"type":return t===Ze.defaultValues(e);case"value":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for GeneralName class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new pe({value:[new E({idBlock:{tagClass:3,tagNumber:0},name:r.blockName||"",value:[new W,new E({idBlock:{tagClass:3,tagNumber:0},value:[new ye]})]}),new I({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:1}}),new I({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:2}}),new E({idBlock:{tagClass:3,tagNumber:3},name:r.blockName||"",value:[function(e={},r=!1){const s=t(e,"names",{});return new O({optional:r,value:[new E({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:s.country_name||"",value:[new pe({value:[new ee,new te]})]}),new E({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:s.administration_domain_name||"",value:[new pe({value:[new ee,new te]})]}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:s.network_address||"",isHexOnly:!0}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:s.terminal_identifier||"",isHexOnly:!0}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:s.private_domain_name||"",value:[new pe({value:[new ee,new te]})]}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:s.organization_name||"",isHexOnly:!0}),new I({optional:!0,name:s.numeric_user_identifier||"",idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new E({optional:!0,name:s.personal_name||"",idBlock:{tagClass:3,tagNumber:5},value:[new I({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new E({optional:!0,name:s.organizational_unit_names||"",idBlock:{tagClass:3,tagNumber:6},value:[new ve({value:new te})]})]})}(r.builtInStandardAttributes||{},!1),function(e=!1){return new O({optional:e,value:[new te,new te]})}(!0),function(e=!1){return new j({optional:e,value:[new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ye]})]})}(!0)]}),new E({idBlock:{tagClass:3,tagNumber:4},name:r.blockName||"",value:[ze.schema(r.directoryName||{})]}),new E({idBlock:{tagClass:3,tagNumber:5},name:r.blockName||"",value:[new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new pe({value:[new re,new te,new Z,new _,new Q]})]}),new E({idBlock:{tagClass:3,tagNumber:1},value:[new pe({value:[new re,new te,new Z,new _,new Q]})]})]}),new I({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:6}}),new I({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:7}}),new I({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){const t=Ae(e,e,Ze.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GENERAL_NAME");switch(this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:this.value=t.result.blockName;break;case 1:case 2:case 6:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=22;const r=e.toBER(!1);this.value=ke(r).result.valueBlock.value}break;case 3:this.value=t.result.blockName;break;case 4:this.value=new ze({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new L({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=6;const r=e.toBER(!1);this.value=ke(r).result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new E({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{const e=new ae({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new E({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{const e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{const e=new W({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return Ze.schema()}}toJSON(){const e={type:this.type};return"string"==typeof this.value?e.value=this.value:e.value=this.value.toJSON(),e}}class Ye{constructor(e={}){this.accessMethod=t(e,"accessMethod",Ye.defaultValues("accessMethod")),this.accessLocation=t(e,"accessLocation",Ye.defaultValues("accessLocation")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"accessMethod":return"";case"accessLocation":return new Ze;default:throw new Error(`Invalid member name for AccessDescription class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.accessMethod||""}),Ze.schema(r.accessLocation||{})]})}fromSchema(e){const t=Ae(e,e,Ye.schema({names:{accessMethod:"accessMethod",accessLocation:{names:{blockName:"accessLocation"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AccessDescription");this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new Ze({schema:t.result.accessLocation})}toSchema(){return new O({value:[new W({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}class Xe{constructor(e={}){"seconds"in e&&(this.seconds=t(e,"seconds",Xe.defaultValues("seconds"))),"millis"in e&&(this.millis=t(e,"millis",Xe.defaultValues("millis"))),"micros"in e&&(this.micros=t(e,"micros",Xe.defaultValues("micros"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"seconds":case"millis":case"micros":return 0;default:throw new Error(`Invalid member name for Accuracy class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"seconds":case"millis":case"micros":return t===Xe.defaultValues(e);default:throw new Error(`Invalid member name for Accuracy class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",optional:!0,value:[new J({optional:!0,name:r.seconds||""}),new I({name:r.millis||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new I({name:r.micros||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){const t=Ae(e,e,Xe.schema({names:{seconds:"seconds",millis:"millis",micros:"micros"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for tsp.Accuracy");if("seconds"in t.result&&(this.seconds=t.result.seconds.valueBlock.valueDec),"millis"in t.result){const e=new J({valueHex:t.result.millis.valueBlock.valueHex});this.millis=e.valueBlock.valueDec}if("micros"in t.result){const e=new J({valueHex:t.result.micros.valueBlock.valueHex});this.micros=e.valueBlock.valueDec}}toSchema(){const e=[];if("seconds"in this&&e.push(new J({value:this.seconds})),"millis"in this){const t=new J({value:this.millis});e.push(new I({idBlock:{tagClass:3,tagNumber:0},valueHex:t.valueBlock.valueHex}))}if("micros"in this){const t=new J({value:this.micros});e.push(new I({idBlock:{tagClass:3,tagNumber:1},valueHex:t.valueBlock.valueHex}))}return new O({value:e})}toJSON(){const e={};return"seconds"in this&&(e.seconds=this.seconds),"millis"in this&&(e.millis=this.millis),"micros"in this&&(e.micros=this.micros),e}}class et{constructor(e={}){this.altNames=t(e,"altNames",et.defaultValues("altNames")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"altNames":return[];default:throw new Error(`Invalid member name for AltName class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ve({name:r.altNames||"",value:Ze.schema()})]})}fromSchema(e){const t=Ae(e,e,et.schema({names:{altNames:"altNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AltName");"altNames"in t.result&&(this.altNames=Array.from(t.result.altNames,e=>new Ze({schema:e})))}toSchema(){return new O({value:Array.from(this.altNames,e=>e.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,e=>e.toJSON())}}}class tt{constructor(e={}){this.contentType=t(e,"contentType",tt.defaultValues("contentType")),this.content=t(e,"content",tt.defaultValues("content")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"contentType":return"";case"content":return new ye;default:throw new Error(`Invalid member name for ContentInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"contentType":return""===t;case"content":return t instanceof ye;default:throw new Error(`Invalid member name for ContentInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return"optional"in r==!1&&(r.optional=!1),new O({name:r.blockName||"ContentInfo",optional:r.optional,value:[new W({name:r.contentType||"contentType"}),new E({idBlock:{tagClass:3,tagNumber:0},value:[new ye({name:r.content||"content"})]})]})}fromSchema(e){const t=Ae(e,e,tt.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CMS_CONTENT_INFO");this.contentType=t.result.contentType.valueBlock.toString(),this.content=t.result.content}toSchema(){return new O({value:[new W({value:this.contentType}),new E({idBlock:{tagClass:3,tagNumber:0},value:[this.content]})]})}toJSON(){const e={contentType:this.contentType};return this.content instanceof ye||(e.content=this.content.toJSON()),e}}class rt{constructor(e={}){this.version=t(e,"version",rt.defaultValues("version")),this.encryptedContentInfo=t(e,"encryptedContentInfo",rt.defaultValues("encryptedContentInfo")),"unprotectedAttrs"in e&&(this.unprotectedAttrs=t(e,"unprotectedAttrs",rt.defaultValues("unprotectedAttrs"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"encryptedContentInfo":return new Ve;case"unprotectedAttrs":return[];default:throw new Error(`Invalid member name for EncryptedData class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return 0===t;case"encryptedContentInfo":return Ve.compareWithDefault("contentType",t.contentType)&&Ve.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&Ve.compareWithDefault("encryptedContent",t.encryptedContent);case"unprotectedAttrs":return 0===t.length;default:throw new Error(`Invalid member name for EncryptedData class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.version||""}),Ve.schema(r.encryptedContentInfo||{}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ve({name:r.unprotectedAttrs||"",value:Ne.schema()})]})]})}fromSchema(e){const t=Ae(e,e,rt.schema({names:{version:"version",encryptedContentInfo:{names:{blockName:"encryptedContentInfo"}},unprotectedAttrs:"unprotectedAttrs"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CMS_ENCRYPTED_DATA");this.version=t.result.version.valueBlock.valueDec,this.encryptedContentInfo=new Ve({schema:t.result.encryptedContentInfo}),"unprotectedAttrs"in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,e=>new Ne({schema:e})))}toSchema(){const e=[];return e.push(new J({value:this.version})),e.push(this.encryptedContentInfo.toSchema()),"unprotectedAttrs"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,e=>e.toSchema())})),new O({value:e})}toJSON(){const e={version:this.version,encryptedContentInfo:this.encryptedContentInfo.toJSON()};return"unprotectedAttrs"in this&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,e=>e.toJSON())),e}encrypt(e){if(e instanceof Object==!1)return Promise.reject('Parameters must have type "Object"');const t=Ke();return void 0===t?Promise.reject("Unable to initialize cryptographic engine"):(e.contentType="1.2.840.113549.1.7.1","encryptEncryptedContentInfo"in t.subtle?t.subtle.encryptEncryptedContentInfo(e).then(e=>{this.encryptedContentInfo=e}):Promise.reject(`No support for "encryptEncryptedContentInfo" in current crypto engine ${t.name}`))}decrypt(e){if(e instanceof Object==!1)return Promise.reject('Parameters must have type "Object"');const t=Ke();return void 0===t?Promise.reject("Unable to initialize cryptographic engine"):(e.encryptedContentInfo=this.encryptedContentInfo,"decryptEncryptedContentInfo"in t.subtle?t.subtle.decryptEncryptedContentInfo(e):Promise.reject(`No support for "decryptEncryptedContentInfo" in current crypto engine ${t.name}`))}}class st{constructor(e={}){this.encryptionAlgorithm=t(e,"encryptionAlgorithm",st.defaultValues("encryptionAlgorithm")),this.encryptedData=t(e,"encryptedData",st.defaultValues("encryptedData")),"parsedValue"in e&&(this.parsedValue=t(e,"parsedValue",st.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"encryptionAlgorithm":return new Be;case"encryptedData":return new L;case"parsedValue":return{};default:throw new Error(`Invalid member name for PKCS8ShroudedKeyBag class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"encryptionAlgorithm":return Be.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case"encryptedData":return t.isEqual(st.defaultValues(e));case"parsedValue":return t instanceof Object&&0===Object.keys(t).length;default:throw new Error(`Invalid member name for PKCS8ShroudedKeyBag class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Be.schema(r.encryptionAlgorithm||{names:{blockName:"encryptionAlgorithm"}}),new pe({value:[new L({name:r.encryptedData||"encryptedData"}),new L({idBlock:{isConstructed:!0},name:r.encryptedData||"encryptedData"})]})]})}fromSchema(e){const t=Ae(e,e,st.schema({names:{encryptionAlgorithm:{names:{blockName:"encryptionAlgorithm"}},encryptedData:"encryptedData"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PKCS8ShroudedKeyBag");this.encryptionAlgorithm=new Be({schema:t.result.encryptionAlgorithm}),this.encryptedData=t.result.encryptedData}toSchema(){return new O({value:[this.encryptionAlgorithm.toSchema(),this.encryptedData]})}toJSON(){return{encryptionAlgorithm:this.encryptionAlgorithm.toJSON(),encryptedData:this.encryptedData.toJSON()}}parseInternalValues(e){let t=Promise.resolve();const r=new rt({encryptedContentInfo:new Ve({contentEncryptionAlgorithm:this.encryptionAlgorithm,encryptedContent:this.encryptedData})});return t=(t=t.then(()=>r.decrypt(e),e=>Promise.reject(e))).then(e=>{const t=ke(e);if(-1===t.offset)return Promise.reject("Error during parsing ASN.1 data");this.parsedValue=new De({schema:t.result})},e=>Promise.reject(e))}makeInternalValues(e){if("parsedValue"in this==!1)return Promise.reject('Please initialize "parsedValue" first');let t=Promise.resolve();const r=new rt;return t=(t=t.then(()=>(e.contentToEncrypt=this.parsedValue.toSchema().toBER(!1),r.encrypt(e)),e=>Promise.reject(e))).then(()=>{this.encryptionAlgorithm=r.encryptedContentInfo.contentEncryptionAlgorithm,this.encryptedData=r.encryptedContentInfo.encryptedContent})}}class at{constructor(e={}){this.type=t(e,"type",at.defaultValues("type")),this.value=t(e,"value",at.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return 0;case"value":return new Date(0,0,0);default:throw new Error(`Invalid member name for Time class: ${e}`)}}static schema(e={},r=!1){const s=t(e,"names",{});return new pe({optional:r,value:[new ce({name:s.utcTimeName||""}),new ue({name:s.generalTimeName||""})]})}fromSchema(e){const t=Ae(e,e,at.schema({names:{utcTimeName:"utcTimeName",generalTimeName:"generalTimeName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for TIME");"utcTimeName"in t.result&&(this.type=0,this.value=t.result.utcTimeName.toDate()),"generalTimeName"in t.result&&(this.type=1,this.value=t.result.generalTimeName.toDate())}toSchema(){let e={};return 0===this.type&&(e=new ce({valueDate:this.value})),1===this.type&&(e=new ue({valueDate:this.value})),e}toJSON(){return{type:this.type,value:this.value}}}class nt{constructor(e={}){this.attributes=t(e,"attributes",nt.defaultValues("attributes")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"attributes":return[];default:throw new Error(`Invalid member name for SubjectDirectoryAttributes class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ve({name:r.attributes||"",value:Ne.schema()})]})}fromSchema(e){const t=Ae(e,e,nt.schema({names:{attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SubjectDirectoryAttributes");this.attributes=Array.from(t.result.attributes,e=>new Ne({schema:e}))}toSchema(){return new O({value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,e=>e.toJSON())}}}class it{constructor(e={}){"notBefore"in e&&(this.notBefore=t(e,"notBefore",it.defaultValues("notBefore"))),"notAfter"in e&&(this.notAfter=t(e,"notAfter",it.defaultValues("notAfter"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"notBefore":case"notAfter":return new Date;default:throw new Error(`Invalid member name for PrivateKeyUsagePeriod class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new I({name:r.notBefore||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new I({name:r.notAfter||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){const t=Ae(e,e,it.schema({names:{notBefore:"notBefore",notAfter:"notAfter"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyUsagePeriod");if("notBefore"in t.result){const e=new ue;e.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=e.toDate()}if("notAfter"in t.result){const e=new ue({valueHex:t.result.notAfter.valueBlock.valueHex});e.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=e.toDate()}}toSchema(){const e=[];return"notBefore"in this&&e.push(new I({idBlock:{tagClass:3,tagNumber:0},valueHex:new ue({valueDate:this.notBefore}).valueBlock.valueHex})),"notAfter"in this&&e.push(new I({idBlock:{tagClass:3,tagNumber:1},valueHex:new ue({valueDate:this.notAfter}).valueBlock.valueHex})),new O({value:e})}toJSON(){const e={};return"notBefore"in this&&(e.notBefore=this.notBefore),"notAfter"in this&&(e.notAfter=this.notAfter),e}}class ot{constructor(e={}){this.cA=t(e,"cA",!1),"pathLenConstraint"in e&&(this.pathLenConstraint=t(e,"pathLenConstraint",0)),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"cA":return!1;default:throw new Error(`Invalid member name for BasicConstraints class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new V({optional:!0,name:r.cA||""}),new J({optional:!0,name:r.pathLenConstraint||""})]})}fromSchema(e){const t=Ae(e,e,ot.schema({names:{cA:"cA",pathLenConstraint:"pathLenConstraint"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for BasicConstraints");"cA"in t.result&&(this.cA=t.result.cA.valueBlock.value),"pathLenConstraint"in t.result&&(t.result.pathLenConstraint.valueBlock.isHexOnly?this.pathLenConstraint=t.result.pathLenConstraint:this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){const e=[];return this.cA!==ot.defaultValues("cA")&&e.push(new V({value:this.cA})),"pathLenConstraint"in this&&(this.pathLenConstraint instanceof J?e.push(this.pathLenConstraint):e.push(new J({value:this.pathLenConstraint}))),new O({value:e})}toJSON(){const e={};return this.cA!==ot.defaultValues("cA")&&(e.cA=this.cA),"pathLenConstraint"in this&&(this.pathLenConstraint instanceof J?e.pathLenConstraint=this.pathLenConstraint.toJSON():e.pathLenConstraint=this.pathLenConstraint),e}}class lt{constructor(e={}){"distributionPoint"in e&&(this.distributionPoint=t(e,"distributionPoint",lt.defaultValues("distributionPoint"))),this.onlyContainsUserCerts=t(e,"onlyContainsUserCerts",lt.defaultValues("onlyContainsUserCerts")),this.onlyContainsCACerts=t(e,"onlyContainsCACerts",lt.defaultValues("onlyContainsCACerts")),"onlySomeReasons"in e&&(this.onlySomeReasons=t(e,"onlySomeReasons",lt.defaultValues("onlySomeReasons"))),this.indirectCRL=t(e,"indirectCRL",lt.defaultValues("indirectCRL")),this.onlyContainsAttributeCerts=t(e,"onlyContainsAttributeCerts",lt.defaultValues("onlyContainsAttributeCerts")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"onlyContainsUserCerts":case"onlyContainsCACerts":return!1;case"onlySomeReasons":return 0;case"indirectCRL":case"onlyContainsAttributeCerts":return!1;default:throw new Error(`Invalid member name for IssuingDistributionPoint class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new pe({value:[new E({name:r.distributionPoint||"",idBlock:{tagClass:3,tagNumber:0},value:[new ve({name:r.distributionPointNames||"",value:Ze.schema()})]}),new E({name:r.distributionPoint||"",idBlock:{tagClass:3,tagNumber:1},value:ze.schema().valueBlock.value})]})]}),new I({name:r.onlyContainsUserCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new I({name:r.onlyContainsCACerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new I({name:r.onlySomeReasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new I({name:r.indirectCRL||"",optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new I({name:r.onlyContainsAttributeCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){const t=Ae(e,e,lt.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",onlyContainsUserCerts:"onlyContainsUserCerts",onlyContainsCACerts:"onlyContainsCACerts",onlySomeReasons:"onlySomeReasons",indirectCRL:"indirectCRL",onlyContainsAttributeCerts:"onlyContainsAttributeCerts"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for IssuingDistributionPoint");if("distributionPoint"in t.result)switch(!0){case 0===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new Ze({schema:e}));break;case 1===t.result.distributionPoint.idBlock.tagNumber:t.result.distributionPoint.idBlock.tagClass=1,t.result.distributionPoint.idBlock.tagNumber=16,this.distributionPoint=new ze({schema:t.result.distributionPoint});break;default:throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if("onlyContainsUserCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==e[0]}if("onlyContainsCACerts"in t.result){const e=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==e[0]}if("onlySomeReasons"in t.result){const e=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=e[0]}if("indirectCRL"in t.result){const e=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==e[0]}if("onlyContainsAttributeCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==e[0]}}toSchema(){const e=[];if("distributionPoint"in this){let t;this.distributionPoint instanceof Array?t=new E({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):((t=this.distributionPoint.toSchema()).idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(t)}if(this.onlyContainsUserCerts!==lt.defaultValues("onlyContainsUserCerts")&&e.push(new I({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==lt.defaultValues("onlyContainsCACerts")&&e.push(new I({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),"onlySomeReasons"in this){const t=new ArrayBuffer(1);new Uint8Array(t)[0]=this.onlySomeReasons,e.push(new I({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==lt.defaultValues("indirectCRL")&&e.push(new I({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==lt.defaultValues("onlyContainsAttributeCerts")&&e.push(new I({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new O({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==lt.defaultValues("onlyContainsUserCerts")&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==lt.defaultValues("onlyContainsCACerts")&&(e.onlyContainsCACerts=this.onlyContainsCACerts),"onlySomeReasons"in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==lt.defaultValues("indirectCRL")&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==lt.defaultValues("onlyContainsAttributeCerts")&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}}class ct{constructor(e={}){this.names=t(e,"names",ct.defaultValues("names")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"names":return[];default:throw new Error(`Invalid member name for GeneralNames class: ${e}`)}}static schema(e={},r=!1){const s=t(e,"names",{});return new O({optional:r,name:s.blockName||"",value:[new ve({name:s.generalNames||"",value:Ze.schema()})]})}fromSchema(e){const t=Ae(e,e,ct.schema({names:{blockName:"names",generalNames:"generalNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralNames");this.names=Array.from(t.result.generalNames,e=>new Ze({schema:e}))}toSchema(){return new O({value:Array.from(this.names,e=>e.toSchema())})}toJSON(){return{names:Array.from(this.names,e=>e.toJSON())}}}class ut{constructor(e={}){this.base=t(e,"base",ut.defaultValues("base")),this.minimum=t(e,"minimum",ut.defaultValues("minimum")),"maximum"in e&&(this.maximum=t(e,"maximum",ut.defaultValues("maximum"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"base":return new Ze;case"minimum":case"maximum":return 0;default:throw new Error(`Invalid member name for GeneralSubtree class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Ze.schema(r.base||{}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new J({name:r.minimum||""})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new J({name:r.maximum||""})]})]})}fromSchema(e){const t=Ae(e,e,ut.schema({names:{base:{names:{blockName:"base"}},minimum:"minimum",maximum:"maximum"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ");this.base=new Ze({schema:t.result.base}),"minimum"in t.result&&(t.result.minimum.valueBlock.isHexOnly?this.minimum=t.result.minimum:this.minimum=t.result.minimum.valueBlock.valueDec),"maximum"in t.result&&(t.result.maximum.valueBlock.isHexOnly?this.maximum=t.result.maximum:this.maximum=t.result.maximum.valueBlock.valueDec)}toSchema(){const e=[];if(e.push(this.base.toSchema()),0!==this.minimum){let t=0;t=this.minimum instanceof J?this.minimum:new J({value:this.minimum}),e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if("maximum"in this){let t=0;t=this.maximum instanceof J?this.maximum:new J({value:this.maximum}),e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new O({value:e})}toJSON(){const e={base:this.base.toJSON()};return 0!==this.minimum&&("number"==typeof this.minimum?e.minimum=this.minimum:e.minimum=this.minimum.toJSON()),"maximum"in this&&("number"==typeof this.maximum?e.maximum=this.maximum:e.maximum=this.maximum.toJSON()),e}}class ht{constructor(e={}){"permittedSubtrees"in e&&(this.permittedSubtrees=t(e,"permittedSubtrees",ht.defaultValues("permittedSubtrees"))),"excludedSubtrees"in e&&(this.excludedSubtrees=t(e,"excludedSubtrees",ht.defaultValues("excludedSubtrees"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"permittedSubtrees":case"excludedSubtrees":return[];default:throw new Error(`Invalid member name for NameConstraints class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ve({name:r.permittedSubtrees||"",value:ut.schema()})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ve({name:r.excludedSubtrees||"",value:ut.schema()})]})]})}fromSchema(e){const t=Ae(e,e,ht.schema({names:{permittedSubtrees:"permittedSubtrees",excludedSubtrees:"excludedSubtrees"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for NameConstraints");"permittedSubtrees"in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,e=>new ut({schema:e}))),"excludedSubtrees"in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,e=>new ut({schema:e})))}toSchema(){const e=[];return"permittedSubtrees"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new O({value:Array.from(this.permittedSubtrees,e=>e.toSchema())})]})),"excludedSubtrees"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new O({value:Array.from(this.excludedSubtrees,e=>e.toSchema())})]})),new O({value:e})}toJSON(){const e={};return"permittedSubtrees"in this&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,e=>e.toJSON())),"excludedSubtrees"in this&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,e=>e.toJSON())),e}}class mt{constructor(e={}){"distributionPoint"in e&&(this.distributionPoint=t(e,"distributionPoint",mt.defaultValues("distributionPoint"))),"reasons"in e&&(this.reasons=t(e,"reasons",mt.defaultValues("reasons"))),"cRLIssuer"in e&&(this.cRLIssuer=t(e,"cRLIssuer",mt.defaultValues("cRLIssuer"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"reasons":return new R;case"cRLIssuer":return[];default:throw new Error(`Invalid member name for DistributionPoint class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new pe({value:[new E({name:r.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ve({name:r.distributionPointNames||"",value:Ze.schema()})]}),new E({name:r.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:ze.schema().valueBlock.value})]})]}),new I({name:r.reasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new E({name:r.cRLIssuer||"",optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new ve({name:r.cRLIssuerNames||"",value:Ze.schema()})]})]})}fromSchema(e){const t=Ae(e,e,mt.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",reasons:"reasons",cRLIssuer:"cRLIssuer",cRLIssuerNames:"cRLIssuerNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for DistributionPoint");"distributionPoint"in t.result&&(0===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new Ze({schema:e}))),1===t.result.distributionPoint.idBlock.tagNumber&&(t.result.distributionPoint.idBlock.tagClass=1,t.result.distributionPoint.idBlock.tagNumber=16,this.distributionPoint=new ze({schema:t.result.distributionPoint}))),"reasons"in t.result&&(this.reasons=new R({valueHex:t.result.reasons.valueBlock.valueHex})),"cRLIssuer"in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,e=>new Ze({schema:e})))}toSchema(){const e=[];if("distributionPoint"in this){let t;t=this.distributionPoint instanceof Array?new E({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):new E({idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return"reasons"in this&&e.push(new I({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHex})),"cRLIssuer"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,e=>e.toSchema())})),new O({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),"reasons"in this&&(e.reasons=this.reasons.toJSON()),"cRLIssuer"in this&&(e.cRLIssuer=Array.from(this.cRLIssuer,e=>e.toJSON())),e}}class ft{constructor(e={}){this.distributionPoints=t(e,"distributionPoints",ft.defaultValues("distributionPoints")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoints":return[];default:throw new Error(`Invalid member name for CRLDistributionPoints class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ve({name:r.distributionPoints||"",value:mt.schema()})]})}fromSchema(e){const t=Ae(e,e,ft.schema({names:{distributionPoints:"distributionPoints"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CRLDistributionPoints");this.distributionPoints=Array.from(t.result.distributionPoints,e=>new mt({schema:e}))}toSchema(){return new O({value:Array.from(this.distributionPoints,e=>e.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,e=>e.toJSON())}}}class dt{constructor(e={}){this.policyQualifierId=t(e,"policyQualifierId",dt.defaultValues("policyQualifierId")),this.qualifier=t(e,"qualifier",dt.defaultValues("qualifier")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"policyQualifierId":return"";case"qualifier":return new ye;default:throw new Error(`Invalid member name for PolicyQualifierInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.policyQualifierId||""}),new ye({name:r.qualifier||""})]})}fromSchema(e){const t=Ae(e,e,dt.schema({names:{policyQualifierId:"policyQualifierId",qualifier:"qualifier"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyQualifierInfo");this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new O({value:[new W({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}class gt{constructor(e={}){this.policyIdentifier=t(e,"policyIdentifier",gt.defaultValues("policyIdentifier")),"policyQualifiers"in e&&(this.policyQualifiers=t(e,"policyQualifiers",gt.defaultValues("policyQualifiers"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"policyIdentifier":return"";case"policyQualifiers":return[];default:throw new Error(`Invalid member name for PolicyInformation class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.policyIdentifier||""}),new O({optional:!0,value:[new ve({name:r.policyQualifiers||"",value:dt.schema()})]})]})}fromSchema(e){const t=Ae(e,e,gt.schema({names:{policyIdentifier:"policyIdentifier",policyQualifiers:"policyQualifiers"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyInformation");this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),"policyQualifiers"in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,e=>new dt({schema:e})))}toSchema(){const e=[];return e.push(new W({value:this.policyIdentifier})),"policyQualifiers"in this&&e.push(new O({value:Array.from(this.policyQualifiers,e=>e.toSchema())})),new O({value:e})}toJSON(){const e={policyIdentifier:this.policyIdentifier};return"policyQualifiers"in this&&(e.policyQualifiers=Array.from(this.policyQualifiers,e=>e.toJSON())),e}}class pt{constructor(e={}){this.certificatePolicies=t(e,"certificatePolicies",pt.defaultValues("certificatePolicies")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certificatePolicies":return[];default:throw new Error(`Invalid member name for CertificatePolicies class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ve({name:r.certificatePolicies||"",value:gt.schema()})]})}fromSchema(e){const t=Ae(e,e,pt.schema({names:{certificatePolicies:"certificatePolicies"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificatePolicies");this.certificatePolicies=Array.from(t.result.certificatePolicies,e=>new gt({schema:e}))}toSchema(){return new O({value:Array.from(this.certificatePolicies,e=>e.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,e=>e.toJSON())}}}class yt{constructor(e={}){this.issuerDomainPolicy=t(e,"issuerDomainPolicy",yt.defaultValues("issuerDomainPolicy")),this.subjectDomainPolicy=t(e,"subjectDomainPolicy",yt.defaultValues("subjectDomainPolicy")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"issuerDomainPolicy":case"subjectDomainPolicy":return"";default:throw new Error(`Invalid member name for PolicyMapping class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.issuerDomainPolicy||""}),new W({name:r.subjectDomainPolicy||""})]})}fromSchema(e){const t=Ae(e,e,yt.schema({names:{issuerDomainPolicy:"issuerDomainPolicy",subjectDomainPolicy:"subjectDomainPolicy"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMapping");this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new O({value:[new W({value:this.issuerDomainPolicy}),new W({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}class vt{constructor(e={}){this.mappings=t(e,"mappings",vt.defaultValues("mappings")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"mappings":return[];default:throw new Error(`Invalid member name for PolicyMappings class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ve({name:r.mappings||"",value:yt.schema()})]})}fromSchema(e){const t=Ae(e,e,vt.schema({names:{mappings:"mappings"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMappings");this.mappings=Array.from(t.result.mappings,e=>new yt({schema:e}))}toSchema(){return new O({value:Array.from(this.mappings,e=>e.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,e=>e.toJSON())}}}class bt{constructor(e={}){"keyIdentifier"in e&&(this.keyIdentifier=t(e,"keyIdentifier",bt.defaultValues("keyIdentifier"))),"authorityCertIssuer"in e&&(this.authorityCertIssuer=t(e,"authorityCertIssuer",bt.defaultValues("authorityCertIssuer"))),"authorityCertSerialNumber"in e&&(this.authorityCertSerialNumber=t(e,"authorityCertSerialNumber",bt.defaultValues("authorityCertSerialNumber"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyIdentifier":return new L;case"authorityCertIssuer":return[];case"authorityCertSerialNumber":return new J;default:throw new Error(`Invalid member name for AuthorityKeyIdentifier class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new I({name:r.keyIdentifier||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ve({name:r.authorityCertIssuer||"",value:Ze.schema()})]}),new I({name:r.authorityCertSerialNumber||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){const t=Ae(e,e,bt.schema({names:{keyIdentifier:"keyIdentifier",authorityCertIssuer:"authorityCertIssuer",authorityCertSerialNumber:"authorityCertSerialNumber"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AuthorityKeyIdentifier");"keyIdentifier"in t.result&&(this.keyIdentifier=new L({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,e=>new Ze({schema:e}))),"authorityCertSerialNumber"in t.result&&(this.authorityCertSerialNumber=new J({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){const e=[];if("keyIdentifier"in this){const t=this.keyIdentifier;t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if("authorityCertIssuer"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,e=>e.toSchema())})),"authorityCertSerialNumber"in this){const t=this.authorityCertSerialNumber;t.idBlock.tagClass=3,t.idBlock.tagNumber=2,e.push(t)}return new O({value:e})}toJSON(){const e={};return"keyIdentifier"in this&&(e.keyIdentifier=this.keyIdentifier.toJSON()),"authorityCertIssuer"in this&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,e=>e.toJSON())),"authorityCertSerialNumber"in this&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}}class wt{constructor(e={}){"requireExplicitPolicy"in e&&(this.requireExplicitPolicy=t(e,"requireExplicitPolicy",wt.defaultValues("requireExplicitPolicy"))),"inhibitPolicyMapping"in e&&(this.inhibitPolicyMapping=t(e,"inhibitPolicyMapping",wt.defaultValues("inhibitPolicyMapping"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"requireExplicitPolicy":case"inhibitPolicyMapping":return 0;default:throw new Error(`Invalid member name for PolicyConstraints class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new I({name:r.requireExplicitPolicy||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new I({name:r.inhibitPolicyMapping||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){const t=Ae(e,e,wt.schema({names:{requireExplicitPolicy:"requireExplicitPolicy",inhibitPolicyMapping:"inhibitPolicyMapping"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyConstraints");if("requireExplicitPolicy"in t.result){const e=t.result.requireExplicitPolicy;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=ke(e.toBER(!1));this.requireExplicitPolicy=r.result.valueBlock.valueDec}if("inhibitPolicyMapping"in t.result){const e=t.result.inhibitPolicyMapping;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=ke(e.toBER(!1));this.inhibitPolicyMapping=r.result.valueBlock.valueDec}}toSchema(){const e=[];if("requireExplicitPolicy"in this){const t=new J({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if("inhibitPolicyMapping"in this){const t=new J({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new O({value:e})}toJSON(){const e={};return"requireExplicitPolicy"in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),"inhibitPolicyMapping"in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}}class kt{constructor(e={}){this.keyPurposes=t(e,"keyPurposes",kt.defaultValues("keyPurposes")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyPurposes":return[];default:throw new Error(`Invalid member name for ExtKeyUsage class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ve({name:r.keyPurposes||"",value:new W})]})}fromSchema(e){const t=Ae(e,e,kt.schema({names:{keyPurposes:"keyPurposes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ExtKeyUsage");this.keyPurposes=Array.from(t.result.keyPurposes,e=>e.valueBlock.toString())}toSchema(){return new O({value:Array.from(this.keyPurposes,e=>new W({value:e}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}class At{constructor(e={}){this.accessDescriptions=t(e,"accessDescriptions",At.defaultValues("accessDescriptions")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"accessDescriptions":return[];default:throw new Error(`Invalid member name for InfoAccess class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ve({name:r.accessDescriptions||"",value:Ye.schema()})]})}fromSchema(e){const t=Ae(e,e,At.schema({names:{accessDescriptions:"accessDescriptions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for InfoAccess");this.accessDescriptions=Array.from(t.result.accessDescriptions,e=>new Ye({schema:e}))}toSchema(){return new O({value:Array.from(this.accessDescriptions,e=>e.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,e=>e.toJSON())}}}class Bt{constructor(e={}){this.extnID=t(e,"extnID",Bt.defaultValues("extnID")),this.critical=t(e,"critical",Bt.defaultValues("critical")),this.extnValue="extnValue"in e?new L({valueHex:e.extnValue}):Bt.defaultValues("extnValue"),"parsedValue"in e&&(this.parsedValue=t(e,"parsedValue",Bt.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"extnID":return"";case"critical":return!1;case"extnValue":return new L;case"parsedValue":return{};default:throw new Error(`Invalid member name for Extension class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.extnID||""}),new V({name:r.critical||"",optional:!0}),new L({name:r.extnValue||""})]})}fromSchema(e){let t=Ae(e,e,Bt.schema({names:{extnID:"extnID",critical:"critical",extnValue:"extnValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EXTENSION");if(this.extnID=t.result.extnID.valueBlock.toString(),"critical"in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue,-1!==(t=ke(this.extnValue.valueBlock.valueHex)).offset)switch(this.extnID){case"2.5.29.9":this.parsedValue=new nt({schema:t.result});break;case"2.5.29.14":case"2.5.29.15":this.parsedValue=t.result;break;case"2.5.29.16":this.parsedValue=new it({schema:t.result});break;case"2.5.29.17":case"2.5.29.18":this.parsedValue=new et({schema:t.result});break;case"2.5.29.19":this.parsedValue=new ot({schema:t.result});break;case"2.5.29.20":case"2.5.29.27":case"2.5.29.21":case"2.5.29.24":this.parsedValue=t.result;break;case"2.5.29.28":this.parsedValue=new lt({schema:t.result});break;case"2.5.29.29":this.parsedValue=new ct({schema:t.result});break;case"2.5.29.30":this.parsedValue=new ht({schema:t.result});break;case"2.5.29.31":case"2.5.29.46":this.parsedValue=new ft({schema:t.result});break;case"2.5.29.32":this.parsedValue=new pt({schema:t.result});break;case"2.5.29.33":this.parsedValue=new vt({schema:t.result});break;case"2.5.29.35":this.parsedValue=new bt({schema:t.result});break;case"2.5.29.36":this.parsedValue=new wt({schema:t.result});break;case"2.5.29.37":this.parsedValue=new kt({schema:t.result});break;case"2.5.29.54":this.parsedValue=t.result;break;case"1.3.6.1.5.5.7.1.1":case"1.3.6.1.5.5.7.1.11":this.parsedValue=new At({schema:t.result})}}toSchema(){const e=[];return e.push(new W({value:this.extnID})),this.critical!==Bt.defaultValues("critical")&&e.push(new V({value:this.critical})),e.push(this.extnValue),new O({value:e})}toJSON(){const e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==Bt.defaultValues("critical")&&(e.critical=this.critical),"parsedValue"in this&&(e.parsedValue=this.parsedValue.toJSON()),e}}class St{constructor(e={}){this.extensions=t(e,"extensions",St.defaultValues("extensions")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"extensions":return[];default:throw new Error(`Invalid member name for Extensions class: ${e}`)}}static schema(e={},r=!1){const s=t(e,"names",{});return new O({optional:r,name:s.blockName||"",value:[new ve({name:s.extensions||"",value:Bt.schema(s.extension||{})})]})}fromSchema(e){const t=Ae(e,e,St.schema({names:{extensions:"extensions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EXTENSIONS");this.extensions=Array.from(t.result.extensions,e=>new Bt({schema:e}))}toSchema(){return new O({value:Array.from(this.extensions,e=>e.toSchema())})}toJSON(){return{extensions:Array.from(this.extensions,e=>e.toJSON())}}}class Ct{constructor(e={}){this.tbs=t(e,"tbs",Ct.defaultValues("tbs")),this.version=t(e,"version",Ct.defaultValues("version")),this.serialNumber=t(e,"serialNumber",Ct.defaultValues("serialNumber")),this.signature=t(e,"signature",Ct.defaultValues("signature")),this.issuer=t(e,"issuer",Ct.defaultValues("issuer")),this.notBefore=t(e,"notBefore",Ct.defaultValues("notBefore")),this.notAfter=t(e,"notAfter",Ct.defaultValues("notAfter")),this.subject=t(e,"subject",Ct.defaultValues("subject")),this.subjectPublicKeyInfo=t(e,"subjectPublicKeyInfo",Ct.defaultValues("subjectPublicKeyInfo")),"issuerUniqueID"in e&&(this.issuerUniqueID=t(e,"issuerUniqueID",Ct.defaultValues("issuerUniqueID"))),"subjectUniqueID"in e&&(this.subjectUniqueID=t(e,"subjectUniqueID",Ct.defaultValues("subjectUniqueID"))),"extensions"in e&&(this.extensions=t(e,"extensions",Ct.defaultValues("extensions"))),this.signatureAlgorithm=t(e,"signatureAlgorithm",Ct.defaultValues("signatureAlgorithm")),this.signatureValue=t(e,"signatureValue",Ct.defaultValues("signatureValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"version":return 0;case"serialNumber":return new J;case"signature":return new Be;case"issuer":return new ze;case"notBefore":case"notAfter":return new at;case"subject":return new ze;case"subjectPublicKeyInfo":return new Ie;case"issuerUniqueID":case"subjectUniqueID":return new ArrayBuffer(0);case"extensions":return[];case"signatureAlgorithm":return new Be;case"signatureValue":return new R;default:throw new Error(`Invalid member name for Certificate class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[function(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"tbsCertificate",value:[new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new J({name:r.tbsCertificateVersion||"tbsCertificate.version"})]}),new J({name:r.tbsCertificateSerialNumber||"tbsCertificate.serialNumber"}),Be.schema(r.signature||{names:{blockName:"tbsCertificate.signature"}}),ze.schema(r.issuer||{names:{blockName:"tbsCertificate.issuer"}}),new O({name:r.tbsCertificateValidity||"tbsCertificate.validity",value:[at.schema(r.notBefore||{names:{utcTimeName:"tbsCertificate.notBefore",generalTimeName:"tbsCertificate.notBefore"}}),at.schema(r.notAfter||{names:{utcTimeName:"tbsCertificate.notAfter",generalTimeName:"tbsCertificate.notAfter"}})]}),ze.schema(r.subject||{names:{blockName:"tbsCertificate.subject"}}),Ie.schema(r.subjectPublicKeyInfo||{names:{blockName:"tbsCertificate.subjectPublicKeyInfo"}}),new I({name:r.tbsCertificateIssuerUniqueID||"tbsCertificate.issuerUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new I({name:r.tbsCertificateSubjectUniqueID||"tbsCertificate.subjectUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[St.schema(r.extensions||{names:{blockName:"tbsCertificate.extensions"}})]})]})}(r.tbsCertificate),Be.schema(r.signatureAlgorithm||{names:{blockName:"signatureAlgorithm"}}),new R({name:r.signatureValue||"signatureValue"})]})}fromSchema(e){const t=Ae(e,e,Ct.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:"tbsCertificate.extensions"}}}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CERT");this.tbs=t.result.tbsCertificate.valueBeforeDecode,"tbsCertificate.version"in t.result&&(this.version=t.result["tbsCertificate.version"].valueBlock.valueDec),this.serialNumber=t.result["tbsCertificate.serialNumber"],this.signature=new Be({schema:t.result["tbsCertificate.signature"]}),this.issuer=new ze({schema:t.result["tbsCertificate.issuer"]}),this.notBefore=new at({schema:t.result["tbsCertificate.notBefore"]}),this.notAfter=new at({schema:t.result["tbsCertificate.notAfter"]}),this.subject=new ze({schema:t.result["tbsCertificate.subject"]}),this.subjectPublicKeyInfo=new Ie({schema:t.result["tbsCertificate.subjectPublicKeyInfo"]}),"tbsCertificate.issuerUniqueID"in t.result&&(this.issuerUniqueID=t.result["tbsCertificate.issuerUniqueID"].valueBlock.valueHex),"tbsCertificate.subjectUniqueID"in t.result&&(this.issuerUniqueID=t.result["tbsCertificate.subjectUniqueID"].valueBlock.valueHex),"tbsCertificate.extensions"in t.result&&(this.extensions=Array.from(t.result["tbsCertificate.extensions"],e=>new Bt({schema:e}))),this.signatureAlgorithm=new Be({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return"version"in this&&this.version!==Ct.defaultValues("version")&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new J({value:this.version})]})),e.push(this.serialNumber),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(new O({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),e.push(this.subject.toSchema()),e.push(this.subjectPublicKeyInfo.toSchema()),"issuerUniqueID"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),"subjectUniqueID"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),"subjectUniqueID"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[this.extensions.toSchema()]})),"extensions"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new O({value:Array.from(this.extensions,e=>e.toSchema())})]})),new O({value:e})}toSchema(e=!1){let t={};if(!1===e){if(0===this.tbs.length)return Ct.schema().value[0];t=ke(this.tbs).result}else t=this.encodeTBS();return new O({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:r(this.tbs,0,this.tbs.byteLength),serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return"version"in this&&this.version!==Ct.defaultValues("version")&&(e.version=this.version),"issuerUniqueID"in this&&(e.issuerUniqueID=r(this.issuerUniqueID,0,this.issuerUniqueID.byteLength)),"subjectUniqueID"in this&&(e.subjectUniqueID=r(this.subjectUniqueID,0,this.subjectUniqueID.byteLength)),"extensions"in this&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}getPublicKey(e=null){const t=Re();if(void 0===t)return Promise.reject("Unable to create WebCrypto object");if(null===e){e={};const t=qe(this.signatureAlgorithm);if(""===t)return Promise.reject(`Unsupported signature algorithm: ${this.signatureAlgorithm.algorithmId}`);const r=We(this.subjectPublicKeyInfo.algorithm.algorithmId);if("name"in r==!1)return Promise.reject(`Unsupported public key algorithm: ${this.subjectPublicKeyInfo.algorithm.algorithmId}`);if(e.algorithm=$e(r.name,"importkey"),"hash"in e.algorithm.algorithm&&(e.algorithm.algorithm.hash.name=t),"ECDSA"===r.name){let t=!1;if("algorithmParams"in this.subjectPublicKeyInfo.algorithm==!0&&"idBlock"in this.subjectPublicKeyInfo.algorithm.algorithmParams&&1===this.subjectPublicKeyInfo.algorithm.algorithmParams.idBlock.tagClass&&6===this.subjectPublicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)return Promise.reject("Incorrect type for ECDSA public key parameters");const r=We(this.subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString());if("name"in r==!1)return Promise.reject(`Unsupported named curve algorithm: ${this.subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);e.algorithm.algorithm.namedCurve=r.name}}const r=this.subjectPublicKeyInfo.toSchema(),s=r.toBER(!1),a=new Uint8Array(s);return t.importKey("spki",a,e.algorithm.algorithm,!0,e.algorithm.usages)}getKeyHash(){const e=Re();return void 0===e?Promise.reject("Unable to create WebCrypto object"):e.digest({name:"sha-1"},new Uint8Array(this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex))}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let r,s=Promise.resolve();const a=Ke();return s=(s=(s=(s=(s=s.then(()=>a.subtle.getSignatureParameters(e,t))).then(e=>{r=e.parameters,this.signature=e.signatureAlgorithm,this.signatureAlgorithm=e.signatureAlgorithm})).then(()=>{this.tbs=this.encodeTBS().toBER(!1)})).then(()=>a.subtle.signWithPrivateKey(this.tbs,e,r))).then(e=>{this.signatureValue=new R({valueHex:e})})}verify(e=null){let t=Promise.resolve(),r={};const s=this.signatureValue,a=this.tbs;if(null!==e?r=e.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(r=this.subjectPublicKeyInfo),r instanceof Ie==!1)return Promise.reject("Please provide issuer certificate as a parameter");const n=Re();if(void 0===n)return Promise.reject("Unable to create WebCrypto object");const i=qe(this.signatureAlgorithm);return""===i?Promise.reject(`Unsupported signature algorithm: ${this.signatureAlgorithm.algorithmId}`):t=(t=t.then(()=>{let e;const t=We(e="1.2.840.113549.1.1.10"===this.signatureAlgorithm.algorithmId?this.signatureAlgorithm.algorithmId:r.algorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Unsupported public key algorithm: ${e}`);const s=$e(t.name,"importkey");if("hash"in s.algorithm&&(s.algorithm.hash.name=i),"ECDSA"===t.name){let e=!1;if("algorithmParams"in r.algorithm==!0&&"idBlock"in r.algorithm.algorithmParams&&1===r.algorithm.algorithmParams.idBlock.tagClass&&6===r.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)return Promise.reject("Incorrect type for ECDSA public key parameters");const t=We(r.algorithm.algorithmParams.valueBlock.toString());if("name"in t==!1)return Promise.reject(`Unsupported named curve algorithm: ${r.algorithm.algorithmParams.valueBlock.toString()}`);s.algorithm.namedCurve=t.name}const a=r.toSchema().toBER(!1),o=new Uint8Array(a);return n.importKey("spki",o,s.algorithm,!0,s.usages)})).then(e=>{const t=$e(e.algorithm.name,"verify");"hash"in t.algorithm&&(t.algorithm.hash.name=i);let r=s.valueBlock.valueHex;if("ECDSA"===e.algorithm.name){r=Me(ke(r).result)}if("RSA-PSS"===e.algorithm.name){let e;try{e=new Oe({schema:this.signatureAlgorithm.algorithmParams})}catch(e){return Promise.reject(e)}t.algorithm.saltLength="saltLength"in e?e.saltLength:20;let r="SHA-1";if("hashAlgorithm"in e){const t=We(e.hashAlgorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Unrecognized hash algorithm: ${e.hashAlgorithm.algorithmId}`);r=t.name}t.algorithm.hash.name=r}return n.verify(t.algorithm,e,new Uint8Array(r),new Uint8Array(a))})}}class It{constructor(e={}){this.notBeforeTime=t(e,"notBeforeTime",It.defaultValues("notBeforeTime")),this.notAfterTime=t(e,"notAfterTime",It.defaultValues("notAfterTime")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"notBeforeTime":case"notAfterTime":return new Date(0,0,0);default:throw new Error(`Invalid member name for AttCertValidityPeriod class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ue({name:r.notBeforeTime||""}),new ue({name:r.notAfterTime||""})]})}fromSchema(e){const t=Ae(e,e,It.schema({names:{notBeforeTime:"notBeforeTime",notAfterTime:"notAfterTime"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AttCertValidityPeriod");this.notBeforeTime=t.result.notBeforeTime.toDate(),this.notAfterTime=t.result.notAfterTime.toDate()}toSchema(){return new O({value:[new ue({valueDate:this.notBeforeTime}),new ue({valueDate:this.notAfterTime})]})}toJSON(){return{notBeforeTime:this.notBeforeTime,notAfterTime:this.notAfterTime}}}class Nt{constructor(e={}){this.digestedObjectType=t(e,"digestedObjectType",Nt.defaultValues("digestedObjectType")),"otherObjectTypeID"in e&&(this.otherObjectTypeID=t(e,"otherObjectTypeID",Nt.defaultValues("otherObjectTypeID"))),this.digestAlgorithm=t(e,"digestAlgorithm",Nt.defaultValues("digestAlgorithm")),this.objectDigest=t(e,"objectDigest",Nt.defaultValues("objectDigest")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"digestedObjectType":return new $;case"otherObjectTypeID":return new W;case"digestAlgorithm":return new Be;case"objectDigest":return new R;default:throw new Error(`Invalid member name for ObjectDigestInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new $({name:r.digestedObjectType||""}),new W({optional:!0,name:r.otherObjectTypeID||""}),Be.schema(r.digestAlgorithm||{}),new R({name:r.objectDigest||""})]})}fromSchema(e){const t=Ae(e,e,Nt.schema({names:{digestedObjectType:"digestedObjectType",otherObjectTypeID:"otherObjectTypeID",digestAlgorithm:{names:{blockName:"digestAlgorithm"}},objectDigest:"objectDigest"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ObjectDigestInfo");this.digestedObjectType=t.result.digestedObjectType,"otherObjectTypeID"in t.result&&(this.otherObjectTypeID=t.result.otherObjectTypeID),this.digestAlgorithm=new Be({schema:t.result.digestAlgorithm}),this.objectDigest=t.result.objectDigest}toSchema(){const e=new O({value:[this.digestedObjectType]});return"otherObjectTypeID"in this&&e.value.push(this.otherObjectTypeID),e.value.push(this.digestAlgorithm.toSchema()),e.value.push(this.objectDigest),e}toJSON(){const e={digestedObjectType:this.digestedObjectType.toJSON()};return"otherObjectTypeID"in this&&(e.otherObjectTypeID=this.otherObjectTypeID.toJSON()),e.digestAlgorithm=this.digestAlgorithm.toJSON(),e.objectDigest=this.objectDigest.toJSON(),e}}class Et{constructor(e={}){this.issuer=t(e,"issuer",Et.defaultValues("issuer")),this.serialNumber=t(e,"serialNumber",Et.defaultValues("serialNumber")),"issuerUID"in e&&(this.issuerUID=t(e,"issuerUID",Et.defaultValues("issuerUID"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"issuer":return new ct;case"serialNumber":return new J;case"issuerUID":return new R;default:throw new Error(`Invalid member name for IssuerSerial class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[ct.schema(r.issuer||{}),new J({name:r.serialNumber||""}),new R({optional:!0,name:r.issuerUID||""})]})}fromSchema(e){const t=Ae(e,e,Et.schema({names:{issuer:{names:{blockName:"issuer"}},serialNumber:"serialNumber",issuerUID:"issuerUID"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for IssuerSerial");this.issuer=new ct({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber,"issuerUID"in t.result&&(this.issuerUID=t.result.issuerUID)}toSchema(){const e=new O({value:[this.issuer.toSchema(),this.serialNumber]});return"issuerUID"in this&&e.valueBlock.value.push(this.issuerUID),e}toJSON(){const e={issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()};return"issuerUID"in this&&(e.issuerUID=this.issuerUID.toJSON()),e}}class xt{constructor(e={}){"issuerName"in e&&(this.issuerName=t(e,"issuerName",xt.defaultValues("issuerName"))),"baseCertificateID"in e&&(this.baseCertificateID=t(e,"baseCertificateID",xt.defaultValues("baseCertificateID"))),"objectDigestInfo"in e&&(this.objectDigestInfo=t(e,"objectDigestInfo",xt.defaultValues("objectDigestInfo"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"issuerName":return new ct;case"baseCertificateID":return new Et;case"objectDigestInfo":return new Nt;default:throw new Error(`Invalid member name for V2Form class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[ct.schema({names:{blockName:r.issuerName}},!0),new E({optional:!0,name:r.baseCertificateID||"",idBlock:{tagClass:3,tagNumber:0},value:Et.schema().valueBlock.value}),new E({optional:!0,name:r.objectDigestInfo||"",idBlock:{tagClass:3,tagNumber:1},value:Nt.schema().valueBlock.value})]})}fromSchema(e){const t=Ae(e,e,xt.schema({names:{issuerName:"issuerName",baseCertificateID:"baseCertificateID",objectDigestInfo:"objectDigestInfo"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for V2Form");"issuerName"in t.result&&(this.issuerName=new ct({schema:t.result.issuerName})),"baseCertificateID"in t.result&&(t.result.baseCertificateID.idBlock.tagClass=1,t.result.baseCertificateID.idBlock.tagNumber=16,this.baseCertificateID=new Et({schema:t.result.baseCertificateID})),"objectDigestInfo"in t.result&&(t.result.objectDigestInfo.idBlock.tagClass=1,t.result.objectDigestInfo.idBlock.tagNumber=16,this.objectDigestInfo=new Nt({schema:t.result.objectDigestInfo}))}toSchema(){const e=new O;return"issuerName"in this&&e.valueBlock.value.push(this.issuerName.toSchema()),"baseCertificateID"in this&&e.valueBlock.value.push(new E({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),"objectDigestInfo"in this&&e.valueBlock.value.push(new E({idBlock:{tagClass:3,tagNumber:1},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){const e={};return"issuerName"in this&&(e.issuerName=this.issuerName.toJSON()),"baseCertificateID"in this&&(e.baseCertificateID=this.baseCertificateID.toJSON()),"objectDigestInfo"in this&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}class Pt{constructor(e={}){"baseCertificateID"in e&&(this.baseCertificateID=t(e,"baseCertificateID",Pt.defaultValues("baseCertificateID"))),"entityName"in e&&(this.entityName=t(e,"entityName",Pt.defaultValues("entityName"))),"objectDigestInfo"in e&&(this.objectDigestInfo=t(e,"objectDigestInfo",Pt.defaultValues("objectDigestInfo"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"baseCertificateID":return new Et;case"entityName":return new ct;case"objectDigestInfo":return new Nt;default:throw new Error(`Invalid member name for Holder class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new E({optional:!0,name:r.baseCertificateID||"",idBlock:{tagClass:3,tagNumber:0},value:Et.schema().valueBlock.value}),new E({optional:!0,name:r.entityName||"",idBlock:{tagClass:3,tagNumber:1},value:ct.schema().valueBlock.value}),new E({optional:!0,name:r.objectDigestInfo||"",idBlock:{tagClass:3,tagNumber:2},value:Nt.schema().valueBlock.value})]})}fromSchema(e){const t=Ae(e,e,Pt.schema({names:{baseCertificateID:"baseCertificateID",entityName:"entityName",objectDigestInfo:"objectDigestInfo"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Holder");"baseCertificateID"in t.result&&(t.result.baseCertificateID.idBlock.tagClass=1,t.result.baseCertificateID.idBlock.tagNumber=16,this.baseCertificateID=new Et({schema:t.result.baseCertificateID})),"entityName"in t.result&&(t.result.entityName.idBlock.tagClass=1,t.result.entityName.idBlock.tagNumber=16,this.entityName=new ct({schema:t.result.entityName})),"objectDigestInfo"in t.result&&(t.result.objectDigestInfo.idBlock.tagClass=1,t.result.objectDigestInfo.idBlock.tagNumber=16,this.objectDigestInfo=new Nt({schema:t.result.objectDigestInfo}))}toSchema(){const e=new O;return"baseCertificateID"in this&&e.valueBlock.value.push(new E({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),"entityName"in this&&e.valueBlock.value.push(new E({idBlock:{tagClass:3,tagNumber:1},value:this.entityName.toSchema().valueBlock.value})),"objectDigestInfo"in this&&e.valueBlock.value.push(new E({idBlock:{tagClass:3,tagNumber:2},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){const e={};return"baseCertificateID"in this&&(e.baseCertificateID=this.baseCertificateID.toJSON()),"entityName"in this&&(e.entityName=this.entityName.toJSON()),"objectDigestInfo"in this&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}class Dt{constructor(e={}){this.version=t(e,"version",Dt.defaultValues("version")),this.holder=t(e,"holder",Dt.defaultValues("holder")),this.issuer=t(e,"issuer",Dt.defaultValues("issuer")),this.signature=t(e,"signature",Dt.defaultValues("signature")),this.serialNumber=t(e,"serialNumber",Dt.defaultValues("serialNumber")),this.attrCertValidityPeriod=t(e,"attrCertValidityPeriod",Dt.defaultValues("attrCertValidityPeriod")),this.attributes=t(e,"attributes",Dt.defaultValues("attributes")),"issuerUniqueID"in e&&(this.issuerUniqueID=t(e,"issuerUniqueID",Dt.defaultValues("issuerUniqueID"))),"extensions"in e&&(this.extensions=t(e,"extensions",Dt.defaultValues("extensions"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 1;case"holder":return new Pt;case"issuer":return{};case"signature":return new Be;case"serialNumber":return new J;case"attrCertValidityPeriod":return new It;case"attributes":return[];case"issuerUniqueID":return new R;case"extensions":return new St;default:throw new Error(`Invalid member name for AttributeCertificateInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.version||""}),Pt.schema(r.holder||{}),new pe({value:[ct.schema({names:{blockName:r.issuer||""}}),new E({name:r.issuer||"",idBlock:{tagClass:3,tagNumber:0},value:xt.schema().valueBlock.value})]}),Be.schema(r.signature||{}),new J({name:r.serialNumber||""}),It.schema(r.attrCertValidityPeriod||{}),new O({name:r.attributes||"",value:[new ve({value:Ne.schema()})]}),new R({optional:!0,name:r.issuerUniqueID||""}),St.schema(r.extensions||{},!0)]})}fromSchema(e){const t=Ae(e,e,Dt.schema({names:{version:"version",holder:{names:{blockName:"holder"}},issuer:"issuer",signature:{names:{blockName:"signature"}},serialNumber:"serialNumber",attrCertValidityPeriod:{names:{blockName:"attrCertValidityPeriod"}},attributes:"attributes",issuerUniqueID:"issuerUniqueID",extensions:{names:{blockName:"extensions"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AttributeCertificateInfo");switch(this.version=t.result.version.valueBlock.valueDec,this.holder=new Pt({schema:t.result.holder}),t.result.issuer.idBlock.tagClass){case 3:t.result.issuer.idBlock.tagClass=1,t.result.issuer.idBlock.tagNumber=16,this.issuer=new xt({schema:t.result.issuer});break;case 1:default:throw new Error("Incorect value for 'issuer' in AttributeCertificateInfo")}this.signature=new Be({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new It({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,e=>new Ne({schema:e})),"issuerUniqueID"in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),"extensions"in t.result&&(this.extensions=new St({schema:t.result.extensions}))}toSchema(){const e=new O({value:[new J({value:this.version}),this.holder.toSchema(),new E({idBlock:{tagClass:3,tagNumber:0},value:this.issuer.toSchema().valueBlock.value}),this.signature.toSchema(),this.serialNumber,this.attrCertValidityPeriod.toSchema(),new O({value:Array.from(this.attributes,e=>e.toSchema())})]});return"issuerUniqueID"in this&&e.valueBlock.value.push(this.issuerUniqueID),"extensions"in this&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){const e={version:this.version,holder:this.holder.toJSON(),issuer:this.issuer.toJSON(),signature:this.signature.toJSON(),serialNumber:this.serialNumber.toJSON(),attrCertValidityPeriod:this.attrCertValidityPeriod.toJSON(),attributes:Array.from(this.attributes,e=>e.toJSON())};return"issuerUniqueID"in this&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),"extensions"in this&&(e.extensions=this.extensions.toJSON()),e}}class Vt{constructor(e={}){this.acinfo=t(e,"acinfo",Vt.defaultValues("acinfo")),this.signatureAlgorithm=t(e,"signatureAlgorithm",Vt.defaultValues("signatureAlgorithm")),this.signatureValue=t(e,"signatureValue",Vt.defaultValues("signatureValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"acinfo":return new Dt;case"signatureAlgorithm":return new Be;case"signatureValue":return new R;default:throw new Error(`Invalid member name for AttributeCertificateV1 class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Dt.schema(r.acinfo||{}),Be.schema(r.signatureAlgorithm||{}),new R({name:r.signatureValue||""})]})}fromSchema(e){const t=Ae(e,e,Vt.schema({names:{acinfo:{names:{blockName:"acinfo"}},signatureAlgorithm:{names:{blockName:"signatureAlgorithm"}},signatureValue:"signatureValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AttributeCertificateV1");this.acinfo=new Dt({schema:t.result.acinfo}),this.signatureAlgorithm=new Be({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new O({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}}class Ot{constructor(e={}){this.certId=t(e,"certId",Ot.defaultValues("certId")),this.certValue=t(e,"certValue",Ot.defaultValues("certValue")),"parsedValue"in e&&(this.parsedValue=t(e,"parsedValue",Ot.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certId":return"";case"certValue":return new ye;case"parsedValue":return{};default:throw new Error(`Invalid member name for CertBag class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"certId":return""===t;case"certValue":return t instanceof ye;case"parsedValue":return t instanceof Object&&0===Object.keys(t).length;default:throw new Error(`Invalid member name for CertBag class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.id||"id"}),new E({idBlock:{tagClass:3,tagNumber:0},value:[new ye({name:r.value||"value"})]})]})}fromSchema(e){const t=Ae(e,e,Ot.schema({names:{id:"certId",value:"certValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertBag");switch(this.certId=t.result.certId.valueBlock.toString(),this.certValue=t.result.certValue,this.certId){case"1.2.840.113549.1.9.22.1":{const e=ke(this.certValue.valueBlock.valueHex);try{this.parsedValue=new Ct({schema:e.result})}catch(t){this.parsedValue=new Vt({schema:e.result})}}break;case"1.2.840.113549.1.9.22.3":{const e=ke(this.certValue.valueBlock.valueHex);this.parsedValue=new Vt({schema:e.result})}break;case"1.2.840.113549.1.9.22.2":default:throw new Error(`Incorrect "certId" value in CertBag: ${this.certId}`)}}toSchema(){return"parsedValue"in this&&("acinfo"in this.parsedValue?this.certId="1.2.840.113549.1.9.22.3":this.certId="1.2.840.113549.1.9.22.1",this.certValue=new L({valueHex:this.parsedValue.toSchema().toBER(!1)})),new O({value:[new W({value:this.certId}),new E({idBlock:{tagClass:3,tagNumber:0},value:["toSchema"in this.certValue?this.certValue.toSchema():this.certValue]})]})}toJSON(){return{certId:this.certId,certValue:this.certValue.toJSON()}}}class jt{constructor(e={}){this.userCertificate=t(e,"userCertificate",jt.defaultValues("userCertificate")),this.revocationDate=t(e,"revocationDate",jt.defaultValues("revocationDate")),"crlEntryExtensions"in e&&(this.crlEntryExtensions=t(e,"crlEntryExtensions",jt.defaultValues("crlEntryExtensions"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"userCertificate":return new J;case"revocationDate":return new at;case"crlEntryExtensions":return new St;default:throw new Error(`Invalid member name for RevokedCertificate class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.userCertificate||"userCertificate"}),at.schema({names:{utcTimeName:r.revocationDate||"revocationDate",generalTimeName:r.revocationDate||"revocationDate"}}),St.schema({names:{blockName:r.crlEntryExtensions||"crlEntryExtensions"}},!0)]})}fromSchema(e){const t=Ae(e,e,jt.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for REV_CERT");this.userCertificate=t.result.userCertificate,this.revocationDate=new at({schema:t.result.revocationDate}),"crlEntryExtensions"in t.result&&(this.crlEntryExtensions=new St({schema:t.result.crlEntryExtensions}))}toSchema(){const e=[this.userCertificate,this.revocationDate.toSchema()];return"crlEntryExtensions"in this&&e.push(this.crlEntryExtensions.toSchema()),new O({value:e})}toJSON(){const e={userCertificate:this.userCertificate.toJSON(),revocationDate:this.revocationDate.toJSON};return"crlEntryExtensions"in this&&(e.crlEntryExtensions=this.crlEntryExtensions.toJSON()),e}}class Ht{constructor(e={}){this.tbs=t(e,"tbs",Ht.defaultValues("tbs")),this.version=t(e,"version",Ht.defaultValues("version")),this.signature=t(e,"signature",Ht.defaultValues("signature")),this.issuer=t(e,"issuer",Ht.defaultValues("issuer")),this.thisUpdate=t(e,"thisUpdate",Ht.defaultValues("thisUpdate")),"nextUpdate"in e&&(this.nextUpdate=t(e,"nextUpdate",Ht.defaultValues("nextUpdate"))),"revokedCertificates"in e&&(this.revokedCertificates=t(e,"revokedCertificates",Ht.defaultValues("revokedCertificates"))),"crlExtensions"in e&&(this.crlExtensions=t(e,"crlExtensions",Ht.defaultValues("crlExtensions"))),this.signatureAlgorithm=t(e,"signatureAlgorithm",Ht.defaultValues("signatureAlgorithm")),this.signatureValue=t(e,"signatureValue",Ht.defaultValues("signatureValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"version":return 1;case"signature":return new Be;case"issuer":return new ze;case"thisUpdate":case"nextUpdate":return new at;case"revokedCertificates":return[];case"crlExtensions":return new St;case"signatureAlgorithm":return new Be;case"signatureValue":return new R;default:throw new Error(`Invalid member name for CertificateRevocationList class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"CertificateList",value:[function(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"tbsCertList",value:[new J({optional:!0,name:r.tbsCertListVersion||"tbsCertList.version",value:2}),Be.schema(r.signature||{names:{blockName:"tbsCertList.signature"}}),ze.schema(r.issuer||{names:{blockName:"tbsCertList.issuer"}}),at.schema(r.tbsCertListThisUpdate||{names:{utcTimeName:"tbsCertList.thisUpdate",generalTimeName:"tbsCertList.thisUpdate"}}),at.schema(r.tbsCertListNextUpdate||{names:{utcTimeName:"tbsCertList.nextUpdate",generalTimeName:"tbsCertList.nextUpdate"}},!0),new O({optional:!0,value:[new ve({name:r.tbsCertListRevokedCertificates||"tbsCertList.revokedCertificates",value:new O({value:[new J,at.schema(),St.schema({},!0)]})})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[St.schema(r.crlExtensions||{names:{blockName:"tbsCertList.extensions"}})]})]})}(e),Be.schema(r.signatureAlgorithm||{names:{blockName:"signatureAlgorithm"}}),new R({name:r.signatureValue||"signatureValue"})]})}fromSchema(e){const t=Ae(e,e,Ht.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CRL");this.tbs=t.result.tbsCertList.valueBeforeDecode,"tbsCertList.version"in t.result&&(this.version=t.result["tbsCertList.version"].valueBlock.valueDec),this.signature=new Be({schema:t.result["tbsCertList.signature"]}),this.issuer=new ze({schema:t.result["tbsCertList.issuer"]}),this.thisUpdate=new at({schema:t.result["tbsCertList.thisUpdate"]}),"tbsCertList.nextUpdate"in t.result&&(this.nextUpdate=new at({schema:t.result["tbsCertList.nextUpdate"]})),"tbsCertList.revokedCertificates"in t.result&&(this.revokedCertificates=Array.from(t.result["tbsCertList.revokedCertificates"],e=>new jt({schema:e}))),"tbsCertList.extensions"in t.result&&(this.crlExtensions=new St({schema:t.result["tbsCertList.extensions"]})),this.signatureAlgorithm=new Be({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return this.version!==Ht.defaultValues("version")&&e.push(new J({value:this.version})),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(this.thisUpdate.toSchema()),"nextUpdate"in this&&e.push(this.nextUpdate.toSchema()),"revokedCertificates"in this&&e.push(new O({value:Array.from(this.revokedCertificates,e=>e.toSchema())})),"crlExtensions"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.crlExtensions.toSchema()]})),new O({value:e})}toSchema(e=!1){let t;if(!1===e){if(0===this.tbs.length)return Ht.schema();t=ke(this.tbs).result}else t=this.encodeTBS();return new O({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:r(this.tbs,0,this.tbs.byteLength),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),thisUpdate:this.thisUpdate.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return this.version!==Ht.defaultValues("version")&&(e.version=this.version),"nextUpdate"in this&&(e.nextUpdate=this.nextUpdate.toJSON()),"revokedCertificates"in this&&(e.revokedCertificates=Array.from(this.revokedCertificates,e=>e.toJSON())),"crlExtensions"in this&&(e.crlExtensions=this.crlExtensions.toJSON()),e}isCertificateRevoked(e){if(!1===this.issuer.isEqual(e.issuer))return!1;if("revokedCertificates"in this==!1)return!1;for(const t of this.revokedCertificates)if(t.userCertificate.isEqual(e.serialNumber))return!0;return!1}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let r,s=Promise.resolve();const a=Ke();return s=(s=(s=(s=(s=s.then(()=>a.subtle.getSignatureParameters(e,t))).then(e=>{r=e.parameters,this.signature=e.signatureAlgorithm,this.signatureAlgorithm=e.signatureAlgorithm})).then(()=>{this.tbs=this.encodeTBS().toBER(!1)})).then(()=>a.subtle.signWithPrivateKey(this.tbs,e,r))).then(e=>{this.signatureValue=new R({valueHex:e})})}verify(e={}){let t=Promise.resolve();const r=this.signatureValue,s=this.tbs;let a=-1;if("issuerCertificate"in e&&(a=e.issuerCertificate.subjectPublicKeyInfo,!1===this.issuer.isEqual(e.issuerCertificate.subject)))return Promise.resolve(!1);if("publicKeyInfo"in e&&(a=e.publicKeyInfo),a instanceof Ie==!1)return Promise.reject("Issuer's certificate must be provided as an input parameter");if("crlExtensions"in this)for(const e of this.crlExtensions.extensions)if(e.critical&&"parsedValue"in e==!1)return Promise.resolve(!1);const n=Re();if(void 0===n)return Promise.reject("Unable to create WebCrypto object");const i=qe(this.signatureAlgorithm);return""===i?Promise.reject(`Unsupported signature algorithm: ${this.signatureAlgorithm.algorithmId}`):t=(t=t.then(()=>{const e=We(this.signature.algorithmId);if("name"in e==="")return Promise.reject(`Unsupported public key algorithm: ${this.signature.algorithmId}`);const t=$e(e.name,"importkey");if("hash"in t.algorithm&&(t.algorithm.hash.name=i),"ECDSA"===e.name){let e=!1;if("algorithmParams"in a.algorithm==!0&&"idBlock"in a.algorithm.algorithmParams&&1===a.algorithm.algorithmParams.idBlock.tagClass&&6===a.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)return Promise.reject("Incorrect type for ECDSA public key parameters");const r=We(a.algorithm.algorithmParams.valueBlock.toString());if("name"in r==!1)return Promise.reject(`Unsupported named curve algorithm: ${a.algorithm.algorithmParams.valueBlock.toString()}`);t.algorithm.namedCurve=r.name}const r=a.toSchema().toBER(!1),s=new Uint8Array(r);return n.importKey("spki",s,t.algorithm,!0,t.usages)})).then(e=>{const t=$e(e.algorithm.name,"verify");"hash"in t.algorithm&&(t.algorithm.hash.name=i);let a=r.valueBlock.valueHex;if("ECDSA"===e.algorithm.name){a=Me(ke(a).result)}if("RSA-PSS"===e.algorithm.name){let e;try{e=new Oe({schema:this.signatureAlgorithm.algorithmParams})}catch(e){return Promise.reject(e)}t.algorithm.saltLength="saltLength"in e?e.saltLength:20;let r="SHA-1";if("hashAlgorithm"in e){const t=We(e.hashAlgorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Unrecognized hash algorithm: ${e.hashAlgorithm.algorithmId}`);r=t.name}t.algorithm.hash.name=r}return n.verify(t.algorithm,e,new Uint8Array(a),new Uint8Array(s))})}}class Ut{constructor(e={}){this.crlId=t(e,"crlId",Ut.defaultValues("crlId")),this.crlValue=t(e,"crlValue",Ut.defaultValues("crlValue")),"parsedValue"in e&&(this.parsedValue=t(e,"parsedValue",Ut.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"crlId":return"";case"crlValue":return new ye;case"parsedValue":return{};default:throw new Error(`Invalid member name for CRLBag class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"crlId":return""===t;case"crlValue":return t instanceof ye;case"parsedValue":return t instanceof Object&&0===Object.keys(t).length;default:throw new Error(`Invalid member name for CRLBag class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.id||"id"}),new E({idBlock:{tagClass:3,tagNumber:0},value:[new ye({name:r.value||"value"})]})]})}fromSchema(e){const t=Ae(e,e,Ut.schema({names:{id:"crlId",value:"crlValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CRLBag");switch(this.crlId=t.result.crlId.valueBlock.toString(),this.crlValue=t.result.crlValue,this.crlId){case"1.2.840.113549.1.9.23.1":{const e=ke(this.certValue.valueBlock.valueHex);this.parsedValue=new Ht({schema:e.result})}break;default:throw new Error(`Incorrect "crlId" value in CRLBag: ${this.crlId}`)}}toSchema(){return"parsedValue"in this&&(this.certId="1.2.840.113549.1.9.23.1",this.certValue=new L({valueHex:this.parsedValue.toSchema().toBER(!1)})),new O({value:[new W({value:this.crlId}),new E({idBlock:{tagClass:3,tagNumber:0},value:[this.crlValue.toSchema()]})]})}toJSON(){return{crlId:this.crlId,crlValue:this.crlValue.toJSON()}}}class Lt{constructor(e={}){this.secretTypeId=t(e,"secretTypeId",Lt.defaultValues("secretTypeId")),this.secretValue=t(e,"secretValue",Lt.defaultValues("secretValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"secretTypeId":return"";case"secretValue":return new ye;default:throw new Error(`Invalid member name for SecretBag class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"secretTypeId":return""===t;case"secretValue":return t instanceof ye;default:throw new Error(`Invalid member name for SecretBag class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.id||"id"}),new E({idBlock:{tagClass:3,tagNumber:0},value:[new ye({name:r.value||"value"})]})]})}fromSchema(e){const t=Ae(e,e,Lt.schema({names:{id:"secretTypeId",value:"secretValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SecretBag");this.secretTypeId=t.result.secretTypeId.valueBlock.toString(),this.secretValue=t.result.secretValue}toSchema(){return new O({value:[new W({value:this.secretTypeId}),new E({idBlock:{tagClass:3,tagNumber:0},value:[this.secretValue.toSchema()]})]})}toJSON(){return{secretTypeId:this.secretTypeId,secretValue:this.secretValue.toJSON()}}}class Kt{constructor(e={}){this.bagId=t(e,"bagId",Kt.defaultValues("bagId")),this.bagValue=t(e,"bagValue",Kt.defaultValues("bagValue")),"bagAttributes"in e&&(this.bagAttributes=t(e,"bagAttributes",Kt.defaultValues("bagAttributes"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"bagId":return"";case"bagValue":return new ye;case"bagAttributes":return[];default:throw new Error(`Invalid member name for SafeBag class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"bagId":return""===t;case"bagValue":return t instanceof ye;case"bagAttributes":return 0===t.length;default:throw new Error(`Invalid member name for SafeBag class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.bagId||"bagId"}),new E({idBlock:{tagClass:3,tagNumber:0},value:[new ye({name:r.bagValue||"bagValue"})]}),new j({optional:!0,value:[new ve({name:r.bagAttributes||"bagAttributes",value:Ne.schema()})]})]})}fromSchema(e){const t=Ae(e,e,Kt.schema({names:{bagId:"bagId",bagValue:"bagValue",bagAttributes:"bagAttributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SafeBag");switch(this.bagId=t.result.bagId.valueBlock.toString(),this.bagId){case"1.2.840.113549.1.12.10.1.1":this.bagValue=new De({schema:t.result.bagValue});break;case"1.2.840.113549.1.12.10.1.2":this.bagValue=new st({schema:t.result.bagValue});break;case"1.2.840.113549.1.12.10.1.3":this.bagValue=new Ot({schema:t.result.bagValue});break;case"1.2.840.113549.1.12.10.1.4":this.bagValue=new Ut({schema:t.result.bagValue});break;case"1.2.840.113549.1.12.10.1.5":this.bagValue=new Lt({schema:t.result.bagValue});break;case"1.2.840.113549.1.12.10.1.6":this.bagValue=new Rt({schema:t.result.bagValue});break;default:throw new Error(`Invalid "bagId" for SafeBag: ${this.bagId}`)}"bagAttributes"in t.result&&(this.bagAttributes=Array.from(t.result.bagAttributes,e=>new Ne({schema:e})))}toSchema(){const e=[new W({value:this.bagId}),new E({idBlock:{tagClass:3,tagNumber:0},value:[this.bagValue.toSchema()]})];return"bagAttributes"in this&&e.push(new j({value:Array.from(this.bagAttributes,e=>e.toSchema())})),new O({value:e})}toJSON(){const e={bagId:this.bagId,bagValue:this.bagValue.toJSON()};return"bagAttributes"in this&&(e.bagAttributes=Array.from(this.bagAttributes,e=>e.toJSON())),e}}class Rt{constructor(e={}){this.safeBags=t(e,"safeBags",Rt.defaultValues("safeBags")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"safeBags":return[];default:throw new Error(`Invalid member name for SafeContents class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"safeBags":return 0===t.length;default:throw new Error(`Invalid member name for SafeContents class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ve({name:r.safeBags||"",value:Kt.schema()})]})}fromSchema(e){const t=Ae(e,e,Rt.schema({names:{safeBags:"safeBags"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SafeContents");this.safeBags=Array.from(t.result.safeBags,e=>new Kt({schema:e}))}toSchema(){return new O({value:Array.from(this.safeBags,e=>e.toSchema())})}toJSON(){return{safeBags:Array.from(this.safeBags,e=>e.toJSON())}}}class Tt{constructor(e={}){this.certificates=t(e,"certificates",Tt.defaultValues("certificates")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certificates":return[];default:throw new Error(`Invalid member name for Attribute class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new j({name:r.blockName||"",value:[new ve({name:r.certificates||"",value:new pe({value:[Ct.schema(),new E({idBlock:{tagClass:3,tagNumber:1},value:[new ye]}),new E({idBlock:{tagClass:3,tagNumber:2},value:[new ye]}),new E({idBlock:{tagClass:3,tagNumber:3},value:[new W,new ye]})]})})]})}fromSchema(e){const t=Ae(e,e,Tt.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CMS_CERTIFICATE_SET");this.certificates=Array.from(t.result.certificates,e=>1===e.idBlock.tagClass?new Ct({schema:e}):e)}toSchema(){return new j({value:Array.from(this.certificates,e=>e instanceof Ct?e.toSchema():e)})}toJSON(){return{certificates:Array.from(this.certificates,e=>e.toJSON())}}}class Jt{constructor(e={}){this.otherRevInfoFormat=t(e,"otherRevInfoFormat",Jt.defaultValues("otherRevInfoFormat")),this.otherRevInfo=t(e,"otherRevInfo",Jt.defaultValues("otherRevInfo")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"otherRevInfoFormat":return"";case"otherRevInfo":return new ye;default:throw new Error(`Invalid member name for OtherRevocationInfoFormat class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.otherRevInfoFormat||"otherRevInfoFormat"}),new ye({name:r.otherRevInfo||"otherRevInfo"})]})}fromSchema(e){const t=Ae(e,e,Jt.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherRevocationInfoFormat");this.otherRevInfoFormat=t.result.otherRevInfoFormat.valueBlock.toString(),this.otherRevInfo=t.result.otherRevInfo}toSchema(){return new O({value:[new W({value:this.otherRevInfoFormat}),this.otherRevInfo]})}toJSON(){const e={otherRevInfoFormat:this.otherRevInfoFormat};return this.otherRevInfo instanceof ye||(e.otherRevInfo=this.otherRevInfo.toJSON()),e}}class $t{constructor(e={}){this.crls=t(e,"crls",$t.defaultValues("crls")),this.otherRevocationInfos=t(e,"otherRevocationInfos",$t.defaultValues("otherRevocationInfos")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"crls":case"otherRevocationInfos":return[];default:throw new Error(`Invalid member name for RevocationInfoChoices class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new j({name:r.blockName||"",value:[new ve({name:r.crls||"",value:new pe({value:[Ht.schema(),new E({idBlock:{tagClass:3,tagNumber:1},value:[new W,new ye]})]})})]})}fromSchema(e){const t=Ae(e,e,$t.schema({names:{crls:"crls"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CSM_REVOCATION_INFO_CHOICES");for(const e of t.result.crls)1===e.idBlock.tagClass?this.crls.push(new Ht({schema:e})):this.otherRevocationInfos.push(new Jt({schema:e}))}toSchema(){const e=[];return e.push(...Array.from(this.crls,e=>e.toSchema())),e.push(...Array.from(this.otherRevocationInfos,e=>{const t=e.toSchema();return t.idBlock.tagClass=3,t.idBlock.tagNumber=1,t})),new j({value:e})}toJSON(){return{crls:Array.from(this.crls,e=>e.toJSON()),otherRevocationInfos:Array.from(this.otherRevocationInfos,e=>e.toJSON())}}}class Ft{constructor(e={}){this.certs=t(e,"certs",Ft.defaultValues("certs")),this.crls=t(e,"crls",Ft.defaultValues("crls")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certs":return new Tt;case"crls":return new $t;default:throw new Error(`Invalid member name for OriginatorInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"certs":return 0===t.certificates.length;case"crls":return 0===t.crls.length&&0===t.otherRevocationInfos.length;default:throw new Error(`Invalid member name for OriginatorInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new E({name:r.certs||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Tt.schema().valueBlock.value}),new E({name:r.crls||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:$t.schema().valueBlock.value})]})}fromSchema(e){const t=Ae(e,e,Ft.schema({names:{certs:"certs",crls:"crls"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OriginatorInfo");t.result.certs.idBlock.tagClass=1,t.result.certs.idBlock.tagNumber=17,this.certs=new Tt({schema:t.result.certs}),t.result.crls.idBlock.tagClass=1,t.result.crls.idBlock.tagNumber=17,this.crls=new $t({schema:t.result.crls})}toSchema(){return new O({value:[new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:this.certs.toSchema().valueBlock.value}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:this.crls.toSchema().valueBlock.value})]})}toJSON(){return{certs:this.certs.toJSON(),crls:this.crls.toJSON()}}}class Mt{constructor(e={}){this.issuer=t(e,"issuer",Mt.defaultValues("issuer")),this.serialNumber=t(e,"serialNumber",Mt.defaultValues("serialNumber")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"issuer":return new ze;case"serialNumber":return new J;default:throw new Error(`Invalid member name for IssuerAndSerialNumber class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[ze.schema(r.issuer||{}),new J({name:r.serialNumber||""})]})}fromSchema(e){const t=Ae(e,e,Mt.schema({names:{issuer:{names:{blockName:"issuer"}},serialNumber:"serialNumber"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for IssuerAndSerialNumber");this.issuer=new ze({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber}toSchema(){return new O({value:[this.issuer.toSchema(),this.serialNumber]})}toJSON(){return{issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()}}}class Wt{constructor(e={}){this.variant=t(e,"variant",Wt.defaultValues("variant")),"value"in e&&(this.value=t(e,"value",Wt.defaultValues("value"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"variant":return-1;case"value":return{};default:throw new Error(`Invalid member name for RecipientIdentifier class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"variant":return-1===t;case"values":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for RecipientIdentifier class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new pe({value:[Mt.schema({names:{blockName:r.blockName||""}}),new E({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:0},value:[new L]})]})}fromSchema(e){const t=Ae(e,e,Wt.schema({names:{blockName:"blockName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RecipientIdentifier");1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new Mt({schema:t.result.blockName})):(this.variant=2,this.value=t.result.blockName.valueBlock.value[0])}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return new E({idBlock:{tagClass:3,tagNumber:0},value:[this.value]});default:return new ye}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant||(e.value=this.value.toJSON()),e}}class qt{constructor(e={}){this.version=t(e,"version",qt.defaultValues("version")),this.rid=t(e,"rid",qt.defaultValues("rid")),this.keyEncryptionAlgorithm=t(e,"keyEncryptionAlgorithm",qt.defaultValues("keyEncryptionAlgorithm")),this.encryptedKey=t(e,"encryptedKey",qt.defaultValues("encryptedKey")),this.recipientCertificate=t(e,"recipientCertificate",qt.defaultValues("recipientCertificate")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return-1;case"rid":return{};case"keyEncryptionAlgorithm":return new Be;case"encryptedKey":return new L;case"recipientCertificate":return new Ct;default:throw new Error(`Invalid member name for KeyTransRecipientInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return t===qt.defaultValues("version");case"rid":return 0===Object.keys(t).length;case"keyEncryptionAlgorithm":case"encryptedKey":return t.isEqual(qt.defaultValues(e));case"recipientCertificate":return!1;default:throw new Error(`Invalid member name for KeyTransRecipientInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.version||""}),Wt.schema(r.rid||{}),Be.schema(r.keyEncryptionAlgorithm||{}),new L({name:r.encryptedKey||""})]})}fromSchema(e){const t=Ae(e,e,qt.schema({names:{version:"version",rid:{names:{blockName:"rid"}},keyEncryptionAlgorithm:{names:{blockName:"keyEncryptionAlgorithm"}},encryptedKey:"encryptedKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for KeyTransRecipientInfo");this.version=t.result.version.valueBlock.valueDec,3===t.result.rid.idBlock.tagClass?this.rid=t.result.rid.valueBlock.value[0]:this.rid=new Mt({schema:t.result.rid}),this.keyEncryptionAlgorithm=new Be({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){const e=[];return this.rid instanceof Mt?(this.version=0,e.push(new J({value:this.version})),e.push(this.rid.toSchema())):(this.version=2,e.push(new J({value:this.version})),e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:[this.rid]}))),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new O({value:e})}toJSON(){return{version:this.version,rid:this.rid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}class _t{constructor(e={}){this.algorithm=t(e,"algorithm",_t.defaultValues("algorithm")),this.publicKey=t(e,"publicKey",_t.defaultValues("publicKey")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"algorithm":return new Be;case"publicKey":return new R;default:throw new Error(`Invalid member name for OriginatorPublicKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"algorithm":case"publicKey":return t.isEqual(_t.defaultValues(e));default:throw new Error(`Invalid member name for OriginatorPublicKey class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Be.schema(r.algorithm||{}),new R({name:r.publicKey||""})]})}fromSchema(e){const t=Ae(e,e,_t.schema({names:{algorithm:{names:{blockName:"algorithm"}},publicKey:"publicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OriginatorPublicKey");this.algorithm=new Be({schema:t.result.algorithm}),this.publicKey=t.result.publicKey}toSchema(){return new O({value:[this.algorithm.toSchema(),this.publicKey]})}toJSON(){return{algorithm:this.algorithm.toJSON(),publicKey:this.publicKey.toJSON()}}}class Gt{constructor(e={}){this.variant=t(e,"variant",Gt.defaultValues("variant")),"value"in e&&(this.value=t(e,"value",Gt.defaultValues("value"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"variant":return-1;case"value":return{};default:throw new Error(`Invalid member name for OriginatorIdentifierOrKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"variant":return-1===t;case"value":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for OriginatorIdentifierOrKey class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new pe({value:[Mt.schema({names:{blockName:r.blockName||""}}),new I({idBlock:{tagClass:3,tagNumber:0},name:r.blockName||""}),new E({idBlock:{tagClass:3,tagNumber:1},name:r.blockName||"",value:_t.schema().valueBlock.value})]})}fromSchema(e){const t=Ae(e,e,Gt.schema({names:{blockName:"blockName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OriginatorIdentifierOrKey");1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new Mt({schema:t.result.blockName})):0===t.result.blockName.idBlock.tagNumber?(t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=4,this.variant=2,this.value=t.result.blockName):(t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=16,this.variant=3,this.value=new _t({schema:t.result.blockName}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return this.value.idBlock.tagClass=3,this.value.idBlock.tagNumber=0,this.value;case 3:{const e=this.value.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}default:return new ye}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant&&3!==this.variant||(e.value=this.value.toJSON()),e}}class Qt{constructor(e={}){this.keyAttrId=t(e,"keyAttrId",Qt.defaultValues("keyAttrId")),"keyAttr"in e&&(this.keyAttr=t(e,"keyAttr",Qt.defaultValues("keyAttr"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyAttrId":return"";case"keyAttr":return{};default:throw new Error(`Invalid member name for OtherKeyAttribute class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"keyAttrId":return""===t;case"keyAttr":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for OtherKeyAttribute class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({optional:r.optional||!0,name:r.blockName||"",value:[new W({name:r.keyAttrId||""}),new ye({optional:!0,name:r.keyAttr||""})]})}fromSchema(e){const t=Ae(e,e,Qt.schema({names:{keyAttrId:"keyAttrId",keyAttr:"keyAttr"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherKeyAttribute");this.keyAttrId=t.result.keyAttrId.valueBlock.toString(),"keyAttr"in t.result&&(this.keyAttr=t.result.keyAttr)}toSchema(){const e=[];return e.push(new W({value:this.keyAttrId})),"keyAttr"in this&&e.push(this.keyAttr.toSchema()),new O({value:e})}toJSON(){const e={keyAttrId:this.keyAttrId};return"keyAttr"in this&&(e.keyAttr=this.keyAttr.toJSON()),e}}class zt{constructor(e={}){this.subjectKeyIdentifier=t(e,"subjectKeyIdentifier",zt.defaultValues("subjectKeyIdentifier")),"date"in e&&(this.date=t(e,"date",zt.defaultValues("date"))),"other"in e&&(this.other=t(e,"other",zt.defaultValues("other"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"subjectKeyIdentifier":return new L;case"date":return new ue;case"other":return new Qt;default:throw new Error(`Invalid member name for RecipientKeyIdentifier class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"subjectKeyIdentifier":return t.isEqual(zt.defaultValues("subjectKeyIdentifier"));case"date":return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case"other":return""===t.keyAttrId&&"keyAttr"in t==!1;default:throw new Error(`Invalid member name for RecipientKeyIdentifier class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new L({name:r.subjectKeyIdentifier||""}),new ue({optional:!0,name:r.date||""}),Qt.schema(r.other||{})]})}fromSchema(e){const t=Ae(e,e,zt.schema({names:{subjectKeyIdentifier:"subjectKeyIdentifier",date:"date",other:{names:{blockName:"other"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RecipientKeyIdentifier");this.subjectKeyIdentifier=t.result.subjectKeyIdentifier,"date"in t.result&&(this.date=t.result.date),"other"in t.result&&(this.other=new Qt({schema:t.result.other}))}toSchema(){const e=[];return e.push(this.subjectKeyIdentifier),"date"in this&&e.push(this.date),"other"in this&&e.push(this.other.toSchema()),new O({value:e})}toJSON(){const e={subjectKeyIdentifier:this.subjectKeyIdentifier.toJSON()};return"date"in this&&(e.date=this.date),"other"in this&&(e.other=this.other.toJSON()),e}}class Zt{constructor(e={}){this.variant=t(e,"variant",Zt.defaultValues("variant")),this.value=t(e,"value",Zt.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"variant":return-1;case"value":return{};default:throw new Error(`Invalid member name for KeyAgreeRecipientIdentifier class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"variant":return-1===t;case"value":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for KeyAgreeRecipientIdentifier class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new pe({value:[Mt.schema(r.issuerAndSerialNumber||{names:{blockName:r.blockName||""}}),new E({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:0},value:zt.schema(r.rKeyId||{names:{blockName:r.blockName||""}}).valueBlock.value})]})}fromSchema(e){const t=Ae(e,e,Zt.schema({names:{blockName:"blockName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for KeyAgreeRecipientIdentifier");1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new Mt({schema:t.result.blockName})):(this.variant=2,t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=16,this.value=new zt({schema:t.result.blockName}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return new E({idBlock:{tagClass:3,tagNumber:0},value:this.value.toSchema().valueBlock.value});default:return new ye}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant||(e.value=this.value.toJSON()),e}}class Yt{constructor(e={}){this.rid=t(e,"rid",Yt.defaultValues("rid")),this.encryptedKey=t(e,"encryptedKey",Yt.defaultValues("encryptedKey")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"rid":return new Zt;case"encryptedKey":return new L;default:throw new Error(`Invalid member name for RecipientEncryptedKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"rid":return-1===t.variant&&"value"in t==!1;case"encryptedKey":return t.isEqual(Yt.defaultValues("encryptedKey"));default:throw new Error(`Invalid member name for RecipientEncryptedKey class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Zt.schema(r.rid||{}),new L({name:r.encryptedKey||""})]})}fromSchema(e){const t=Ae(e,e,Yt.schema({names:{rid:{names:{blockName:"rid"}},encryptedKey:"encryptedKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RecipientEncryptedKey");this.rid=new Zt({schema:t.result.rid}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new O({value:[this.rid.toSchema(),this.encryptedKey]})}toJSON(){return{rid:this.rid.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}class Xt{constructor(e={}){this.encryptedKeys=t(e,"encryptedKeys",Xt.defaultValues("encryptedKeys")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"encryptedKeys":return[];default:throw new Error(`Invalid member name for RecipientEncryptedKeys class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"encryptedKeys":return 0===t.length;default:throw new Error(`Invalid member name for RecipientEncryptedKeys class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ve({name:r.RecipientEncryptedKeys||"",value:Yt.schema()})]})}fromSchema(e){const t=Ae(e,e,Xt.schema({names:{RecipientEncryptedKeys:"RecipientEncryptedKeys"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RecipientEncryptedKeys");this.encryptedKeys=Array.from(t.result.RecipientEncryptedKeys,e=>new Yt({schema:e}))}toSchema(){return new O({value:Array.from(this.encryptedKeys,e=>e.toSchema())})}toJSON(){return{encryptedKeys:Array.from(this.encryptedKeys,e=>e.toJSON())}}}class er{constructor(e={}){this.version=t(e,"version",er.defaultValues("version")),this.originator=t(e,"originator",er.defaultValues("originator")),"ukm"in e&&(this.ukm=t(e,"ukm",er.defaultValues("ukm"))),this.keyEncryptionAlgorithm=t(e,"keyEncryptionAlgorithm",er.defaultValues("keyEncryptionAlgorithm")),this.recipientEncryptedKeys=t(e,"recipientEncryptedKeys",er.defaultValues("recipientEncryptedKeys")),this.recipientCertificate=t(e,"recipientCertificate",er.defaultValues("recipientCertificate")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"originator":return new Gt;case"ukm":return new L;case"keyEncryptionAlgorithm":return new Be;case"recipientEncryptedKeys":return new Xt;case"recipientCertificate":return new Ct;default:throw new Error(`Invalid member name for KeyAgreeRecipientInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return 0===t;case"originator":return-1===t.variant&&"value"in t==!1;case"ukm":return t.isEqual(er.defaultValues("ukm"));case"keyEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"recipientEncryptedKeys":return 0===t.encryptedKeys.length;case"recipientCertificate":return!1;default:throw new Error(`Invalid member name for KeyAgreeRecipientInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.version||""}),new E({idBlock:{tagClass:3,tagNumber:0},value:[Gt.schema(r.originator||{})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new L({name:r.ukm||""})]}),Be.schema(r.keyEncryptionAlgorithm||{}),Xt.schema(r.recipientEncryptedKeys||{})]})}fromSchema(e){const t=Ae(e,e,er.schema({names:{version:"version",originator:{names:{blockName:"originator"}},ukm:"ukm",keyEncryptionAlgorithm:{names:{blockName:"keyEncryptionAlgorithm"}},recipientEncryptedKeys:{names:{blockName:"recipientEncryptedKeys"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for KeyAgreeRecipientInfo");this.version=t.result.version.valueBlock.valueDec,this.originator=new Gt({schema:t.result.originator}),"ukm"in t.result&&(this.ukm=t.result.ukm),this.keyEncryptionAlgorithm=new Be({schema:t.result.keyEncryptionAlgorithm}),this.recipientEncryptedKeys=new Xt({schema:t.result.recipientEncryptedKeys})}toSchema(){const e=[];return e.push(new J({value:this.version})),e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:[this.originator.toSchema()]})),"ukm"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[this.ukm]})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.recipientEncryptedKeys.toSchema()),new O({value:e})}toJSON(){const e={version:this.version,originator:this.originator.toJSON()};return"ukm"in this&&(e.ukm=this.ukm.toJSON()),e.keyEncryptionAlgorithm=this.keyEncryptionAlgorithm.toJSON(),e.recipientEncryptedKeys=this.recipientEncryptedKeys.toJSON(),e}}class tr{constructor(e={}){this.keyIdentifier=t(e,"keyIdentifier",tr.defaultValues("keyIdentifier")),"date"in e&&(this.date=t(e,"date",tr.defaultValues("date"))),"other"in e&&(this.other=t(e,"other",tr.defaultValues("other"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyIdentifier":return new L;case"date":return new ue;case"other":return new Qt;default:throw new Error(`Invalid member name for KEKIdentifier class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"keyIdentifier":return t.isEqual(tr.defaultValues("keyIdentifier"));case"date":return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case"other":return t.compareWithDefault("keyAttrId",t.keyAttrId)&&"keyAttr"in t==!1;default:throw new Error(`Invalid member name for KEKIdentifier class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new L({name:r.keyIdentifier||""}),new ue({optional:!0,name:r.date||""}),Qt.schema(r.other||{})]})}fromSchema(e){const t=Ae(e,e,tr.schema({names:{keyIdentifier:"keyIdentifier",date:"date",other:{names:{blockName:"other"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for KEKIdentifier");this.keyIdentifier=t.result.keyIdentifier,"date"in t.result&&(this.date=t.result.date),"other"in t.result&&(this.other=new Qt({schema:t.result.other}))}toSchema(){const e=[];return e.push(this.keyIdentifier),"date"in this&&e.push(this.date),"other"in this&&e.push(this.other.toSchema()),new O({value:e})}toJSON(){const e={keyIdentifier:this.keyIdentifier.toJSON()};return"date"in this&&(e.date=this.date),"other"in this&&(e.other=this.other.toJSON()),e}}class rr{constructor(e={}){this.version=t(e,"version",rr.defaultValues("version")),this.kekid=t(e,"kekid",rr.defaultValues("kekid")),this.keyEncryptionAlgorithm=t(e,"keyEncryptionAlgorithm",rr.defaultValues("keyEncryptionAlgorithm")),this.encryptedKey=t(e,"encryptedKey",rr.defaultValues("encryptedKey")),this.preDefinedKEK=t(e,"preDefinedKEK",rr.defaultValues("preDefinedKEK")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"kekid":return new tr;case"keyEncryptionAlgorithm":return new Be;case"encryptedKey":return new L;case"preDefinedKEK":return new ArrayBuffer(0);default:throw new Error(`Invalid member name for KEKRecipientInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"KEKRecipientInfo":return t===rr.defaultValues("version");case"kekid":return t.compareWithDefault("keyIdentifier",t.keyIdentifier)&&"date"in t==!1&&"other"in t==!1;case"keyEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"encryptedKey":return t.isEqual(rr.defaultValues("encryptedKey"));case"preDefinedKEK":return 0===t.byteLength;default:throw new Error(`Invalid member name for KEKRecipientInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.version||""}),tr.schema(r.kekid||{}),Be.schema(r.keyEncryptionAlgorithm||{}),new L({name:r.encryptedKey||""})]})}fromSchema(e){const t=Ae(e,e,rr.schema({names:{version:"version",kekid:{names:{blockName:"kekid"}},keyEncryptionAlgorithm:{names:{blockName:"keyEncryptionAlgorithm"}},encryptedKey:"encryptedKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for KEKRecipientInfo");this.version=t.result.version.valueBlock.valueDec,this.kekid=new tr({schema:t.result.kekid}),this.keyEncryptionAlgorithm=new Be({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new O({value:[new J({value:this.version}),this.kekid.toSchema(),this.keyEncryptionAlgorithm.toSchema(),this.encryptedKey]})}toJSON(){return{version:this.version,kekid:this.originator.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}class sr{constructor(e={}){this.version=t(e,"version",sr.defaultValues("version")),"keyDerivationAlgorithm"in e&&(this.keyDerivationAlgorithm=t(e,"keyDerivationAlgorithm",sr.defaultValues("keyDerivationAlgorithm"))),this.keyEncryptionAlgorithm=t(e,"keyEncryptionAlgorithm",sr.defaultValues("keyEncryptionAlgorithm")),this.encryptedKey=t(e,"encryptedKey",sr.defaultValues("encryptedKey")),this.password=t(e,"password",sr.defaultValues("password")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return-1;case"keyDerivationAlgorithm":case"keyEncryptionAlgorithm":return new Be;case"encryptedKey":return new L;case"password":return new ArrayBuffer(0);default:throw new Error(`Invalid member name for PasswordRecipientinfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return-1===t;case"keyDerivationAlgorithm":case"keyEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"encryptedKey":return t.isEqual(sr.defaultValues("encryptedKey"));case"password":return 0===t.byteLength;default:throw new Error(`Invalid member name for PasswordRecipientinfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.version||""}),new E({name:r.keyDerivationAlgorithm||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Be.schema().valueBlock.value}),Be.schema(r.keyEncryptionAlgorithm||{}),new L({name:r.encryptedKey||""})]})}fromSchema(e){const t=Ae(e,e,sr.schema({names:{version:"version",keyDerivationAlgorithm:"keyDerivationAlgorithm",keyEncryptionAlgorithm:{names:{blockName:"keyEncryptionAlgorithm"}},encryptedKey:"encryptedKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PasswordRecipientinfo");this.version=t.result.version.valueBlock.valueDec,"keyDerivationAlgorithm"in t.result&&(t.result.keyDerivationAlgorithm.idBlock.tagClass=1,t.result.keyDerivationAlgorithm.idBlock.tagNumber=16,this.keyDerivationAlgorithm=new Be({schema:t.result.keyDerivationAlgorithm})),this.keyEncryptionAlgorithm=new Be({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){const e=[];return e.push(new J({value:this.version})),"keyDerivationAlgorithm"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:this.keyDerivationAlgorithm.toSchema().valueBlock.value})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new O({value:e})}toJSON(){return{version:this.version,keyDerivationAlgorithm:this.keyDerivationAlgorithm.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}class ar{constructor(e={}){this.oriType=t(e,"oriType",ar.defaultValues("oriType")),this.oriValue=t(e,"oriValue",ar.defaultValues("oriValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"oriType":return"";case"oriValue":return{};default:throw new Error(`Invalid member name for OtherRecipientInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"oriType":return""===t;case"oriValue":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for OtherRecipientInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.oriType||""}),new ye({name:r.oriValue||""})]})}fromSchema(e){const t=Ae(e,e,ar.schema({names:{oriType:"oriType",oriValue:"oriValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherRecipientInfo");this.oriType=t.result.oriType.valueBlock.toString(),this.oriValue=t.result.oriValue}toSchema(){return new O({value:[new W({value:this.oriType}),this.oriValue]})}toJSON(){const e={oriType:this.oriType};return!1===ar.compareWithDefault("oriValue",this.oriValue)&&(e.oriValue=this.oriValue.toJSON()),e}}class nr{constructor(e={}){this.variant=t(e,"variant",nr.defaultValues("variant")),"value"in e&&(this.value=t(e,"value",nr.defaultValues("value"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"variant":return-1;case"value":return{};default:throw new Error(`Invalid member name for RecipientInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"variant":return t===nr.defaultValues(e);case"value":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for RecipientInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new pe({value:[qt.schema({names:{blockName:r.blockName||""}}),new E({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:1},value:er.schema().valueBlock.value}),new E({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:2},value:rr.schema().valueBlock.value}),new E({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:3},value:sr.schema().valueBlock.value}),new E({name:r.blockName||"",idBlock:{tagClass:3,tagNumber:4},value:ar.schema().valueBlock.value})]})}fromSchema(e){const t=Ae(e,e,nr.schema({names:{blockName:"blockName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CMS_RECIPIENT_INFO");if(1===t.result.blockName.idBlock.tagClass)this.variant=1,this.value=new qt({schema:t.result.blockName});else{const e=t.result.blockName.idBlock.tagNumber;switch(t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=16,e){case 1:this.variant=2,this.value=new er({schema:t.result.blockName});break;case 2:this.variant=3,this.value=new rr({schema:t.result.blockName});break;case 3:this.variant=4,this.value=new sr({schema:t.result.blockName});break;case 4:this.variant=5,this.value=new ar({schema:t.result.blockName});break;default:throw new Error("Incorrect structure of RecipientInfo block")}}}toSchema(){const e=this.value.toSchema();switch(this.variant){case 1:return e;case 2:case 3:case 4:return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.variant-1,e;default:return new ye}}toJSON(){const e={variant:this.variant};return this.variant>=1&&this.variant<=4&&(e.value=this.value.toJSON()),e}}class ir{constructor(e={}){this.hashAlgorithm=t(e,"hashAlgorithm",ir.defaultValues("hashAlgorithm")),this.maskGenAlgorithm=t(e,"maskGenAlgorithm",ir.defaultValues("maskGenAlgorithm")),this.pSourceAlgorithm=t(e,"pSourceAlgorithm",ir.defaultValues("pSourceAlgorithm")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new Be({algorithmId:"1.3.14.3.2.26",algorithmParams:new H});case"maskGenAlgorithm":return new Be({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new Be({algorithmId:"1.3.14.3.2.26",algorithmParams:new H}).toSchema()});case"pSourceAlgorithm":return new Be({algorithmId:"1.2.840.113549.1.1.9",algorithmParams:new L({valueHex:new Uint8Array([218,57,163,238,94,107,75,13,50,85,191,239,149,96,24,144,175,216,7,9]).buffer})});default:throw new Error(`Invalid member name for RSAESOAEPParams class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new E({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[Be.schema(r.hashAlgorithm||{})]}),new E({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[Be.schema(r.maskGenAlgorithm||{})]}),new E({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[Be.schema(r.pSourceAlgorithm||{})]})]})}fromSchema(e){const t=Ae(e,e,ir.schema({names:{hashAlgorithm:{names:{blockName:"hashAlgorithm"}},maskGenAlgorithm:{names:{blockName:"maskGenAlgorithm"}},pSourceAlgorithm:{names:{blockName:"pSourceAlgorithm"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAESOAEPParams");"hashAlgorithm"in t.result&&(this.hashAlgorithm=new Be({schema:t.result.hashAlgorithm})),"maskGenAlgorithm"in t.result&&(this.maskGenAlgorithm=new Be({schema:t.result.maskGenAlgorithm})),"pSourceAlgorithm"in t.result&&(this.pSourceAlgorithm=new Be({schema:t.result.pSourceAlgorithm}))}toSchema(){const e=[];return this.hashAlgorithm.isEqual(ir.defaultValues("hashAlgorithm"))||e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(ir.defaultValues("maskGenAlgorithm"))||e.push(new E({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.pSourceAlgorithm.isEqual(ir.defaultValues("pSourceAlgorithm"))||e.push(new E({idBlock:{tagClass:3,tagNumber:2},value:[this.pSourceAlgorithm.toSchema()]})),new O({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(ir.defaultValues("hashAlgorithm"))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(ir.defaultValues("maskGenAlgorithm"))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.pSourceAlgorithm.isEqual(ir.defaultValues("pSourceAlgorithm"))||(e.pSourceAlgorithm=this.pSourceAlgorithm.toJSON()),e}}class or{constructor(e={}){this.keyInfo=t(e,"keyInfo",or.defaultValues("keyInfo")),"entityUInfo"in e&&(this.entityUInfo=t(e,"entityUInfo",or.defaultValues("entityUInfo"))),this.suppPubInfo=t(e,"suppPubInfo",or.defaultValues("suppPubInfo")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyInfo":return new Be;case"entityUInfo":case"suppPubInfo":return new L;default:throw new Error(`Invalid member name for ECCCMSSharedInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"keyInfo":case"entityUInfo":case"suppPubInfo":return t.isEqual(or.defaultValues(e));default:throw new Error(`Invalid member name for ECCCMSSharedInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Be.schema(r.keyInfo||{}),new E({name:r.entityUInfo||"",idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[new L]}),new E({name:r.suppPubInfo||"",idBlock:{tagClass:3,tagNumber:2},value:[new L]})]})}fromSchema(e){const t=Ae(e,e,or.schema({names:{keyInfo:{names:{blockName:"keyInfo"}},entityUInfo:"entityUInfo",suppPubInfo:"suppPubInfo"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ECC_CMS_SharedInfo");this.keyInfo=new Be({schema:t.result.keyInfo}),"entityUInfo"in t.result&&(this.entityUInfo=t.result.entityUInfo.valueBlock.value[0]),this.suppPubInfo=t.result.suppPubInfo.valueBlock.value[0]}toSchema(){const e=[];return e.push(this.keyInfo.toSchema()),"entityUInfo"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:[this.entityUInfo]})),e.push(new E({idBlock:{tagClass:3,tagNumber:2},value:[this.suppPubInfo]})),new O({value:e})}toJSON(){const e={keyInfo:this.keyInfo.toJSON()};return"entityUInfo"in this&&(e.entityUInfo=this.entityUInfo.toJSON()),e.suppPubInfo=this.suppPubInfo.toJSON(),e}}class lr{constructor(e={}){this.version=t(e,"version",lr.defaultValues("version")),"originatorInfo"in e&&(this.originatorInfo=t(e,"originatorInfo",lr.defaultValues("originatorInfo"))),this.recipientInfos=t(e,"recipientInfos",lr.defaultValues("recipientInfos")),this.encryptedContentInfo=t(e,"encryptedContentInfo",lr.defaultValues("encryptedContentInfo")),"unprotectedAttrs"in e&&(this.unprotectedAttrs=t(e,"unprotectedAttrs",lr.defaultValues("unprotectedAttrs"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"originatorInfo":return new Ft;case"recipientInfos":return[];case"encryptedContentInfo":return new Ve;case"unprotectedAttrs":return[];default:throw new Error(`Invalid member name for EnvelopedData class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return t===lr.defaultValues(e);case"originatorInfo":return 0===t.certs.certificates.length&&0===t.crls.crls.length;case"recipientInfos":case"unprotectedAttrs":return 0===t.length;case"encryptedContentInfo":return Ve.compareWithDefault("contentType",t.contentType)&&Ve.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&Ve.compareWithDefault("encryptedContent",t.encryptedContent);default:throw new Error(`Invalid member name for EnvelopedData class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.version||""}),new E({name:r.originatorInfo||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Ft.schema().valueBlock.value}),new j({value:[new ve({name:r.recipientInfos||"",value:nr.schema()})]}),Ve.schema(r.encryptedContentInfo||{}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ve({name:r.unprotectedAttrs||"",value:Ne.schema()})]})]})}fromSchema(e){const t=Ae(e,e,lr.schema({names:{version:"version",originatorInfo:"originatorInfo",recipientInfos:"recipientInfos",encryptedContentInfo:{names:{blockName:"encryptedContentInfo"}},unprotectedAttrs:"unprotectedAttrs"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CMS_ENVELOPED_DATA");this.version=t.result.version.valueBlock.valueDec,"originatorInfo"in t.result&&(t.result.originatorInfo.idBlock.tagClass=1,t.result.originatorInfo.idBlock.tagNumber=16,this.originatorInfo=new Ft({schema:t.result.originatorInfo})),this.recipientInfos=Array.from(t.result.recipientInfos,e=>new nr({schema:e})),this.encryptedContentInfo=new Ve({schema:t.result.encryptedContentInfo}),"unprotectedAttrs"in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,e=>new Ne({schema:e})))}toSchema(){const e=[];return e.push(new J({value:this.version})),"originatorInfo"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:this.originatorInfo.toSchema().valueBlock.value})),e.push(new j({value:Array.from(this.recipientInfos,e=>e.toSchema())})),e.push(this.encryptedContentInfo.toSchema()),"unprotectedAttrs"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,e=>e.toSchema())})),new O({value:e})}toJSON(){const e={version:this.version};return"originatorInfo"in this&&(e.originatorInfo=this.originatorInfo.toJSON()),e.recipientInfos=Array.from(this.recipientInfos,e=>e.toJSON()),e.encryptedContentInfo=this.encryptedContentInfo.toJSON(),"unprotectedAttrs"in this&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,e=>e.toJSON())),e}addRecipientByCertificate(e,t,r){const s=t||{};if(-1!==e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549"))r=1;else{if(-1===e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045"))throw new Error(`Unknown type of certificate's public key: ${e.subjectPublicKeyInfo.algorithm.algorithmId}`);r=2}switch("oaepHashAlgorithm"in s==!1&&(s.oaepHashAlgorithm="SHA-512"),"kdfAlgorithm"in s==!1&&(s.kdfAlgorithm="SHA-512"),"kekEncryptionLength"in s==!1&&(s.kekEncryptionLength=256),r){case 1:{const t=Je({name:"RSA-OAEP"});if(""===t)throw new Error("Can not find OID for OAEP");const r=Je({name:s.oaepHashAlgorithm});if(""===r)throw new Error(`Unknown OAEP hash algorithm: ${s.oaepHashAlgorithm}`);const a=new Be({algorithmId:r,algorithmParams:new H}),n=new ir({hashAlgorithm:a,maskGenAlgorithm:new Be({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:a.toSchema()})}),i=new qt({version:0,rid:new Mt({issuer:e.issuer,serialNumber:e.serialNumber}),keyEncryptionAlgorithm:new Be({algorithmId:t,algorithmParams:n.toSchema()}),recipientCertificate:e});this.recipientInfos.push(new nr({variant:1,value:i}))}break;case 2:{const t=new Yt({rid:new Zt({variant:1,value:new Mt({issuer:e.issuer,serialNumber:e.serialNumber})})}),r=Je({name:"AES-KW",length:s.kekEncryptionLength});if(""===r)throw new Error(`Unknown length for key encryption algorithm: ${s.kekEncryptionLength}`);const a=new Be({algorithmId:r,algorithmParams:new H}),n=Je({name:"ECDH",kdf:s.kdfAlgorithm});if(""===n)throw new Error(`Unknown KDF algorithm: ${s.kdfAlgorithm}`);const i=new ArrayBuffer(64);Te(new Uint8Array(i));const o=new er({version:3,ukm:new L({valueHex:i}),keyEncryptionAlgorithm:new Be({algorithmId:n,algorithmParams:a.toSchema()}),recipientEncryptedKeys:new Xt({encryptedKeys:[t]}),recipientCertificate:e});this.recipientInfos.push(new nr({variant:2,value:o}))}break;default:throw new Error(`Unknown "variant" value: ${r}`)}return!0}addRecipientByPreDefinedData(e,t,r){const s=t||{};if(e instanceof ArrayBuffer==!1)throw new Error('Please pass "preDefinedData" in ArrayBuffer type');if(0===e.byteLength)throw new Error("Pre-defined data could have zero length");if("keyIdentifier"in s==!1){const e=new ArrayBuffer(16);Te(new Uint8Array(e)),s.keyIdentifier=e}switch("hmacHashAlgorithm"in s==!1&&(s.hmacHashAlgorithm="SHA-512"),"iterationCount"in s==!1&&(s.iterationCount=2048),"keyEncryptionAlgorithm"in s==!1&&(s.keyEncryptionAlgorithm={name:"AES-KW",length:256}),"keyEncryptionAlgorithmParams"in s==!1&&(s.keyEncryptionAlgorithmParams=new H),r){case 1:{const t=Je(s.keyEncryptionAlgorithm);if(""===t)throw new Error('Incorrect value for "keyEncryptionAlgorithm"');const r=new rr({version:4,kekid:new tr({keyIdentifier:new L({valueHex:s.keyIdentifier})}),keyEncryptionAlgorithm:new Be({algorithmId:t,algorithmParams:s.keyEncryptionAlgorithmParams}),preDefinedKEK:e});this.recipientInfos.push(new nr({variant:3,value:r}))}break;case 2:{const t=Je({name:"PBKDF2"});if(""===t)throw new Error("Can not find OID for PBKDF2");const r=new ArrayBuffer(64);Te(new Uint8Array(r));const a=Je({name:"HMAC",hash:{name:s.hmacHashAlgorithm}});if(""===a)throw new Error(`Incorrect value for "hmacHashAlgorithm": ${s.hmacHashAlgorithm}`);const n=new je({salt:new L({valueHex:r}),iterationCount:s.iterationCount,prf:new Be({algorithmId:a,algorithmParams:new H})}),i=Je(s.keyEncryptionAlgorithm);if(""===i)throw new Error('Incorrect value for "keyEncryptionAlgorithm"');const o=new sr({version:0,keyDerivationAlgorithm:new Be({algorithmId:t,algorithmParams:n.toSchema()}),keyEncryptionAlgorithm:new Be({algorithmId:i,algorithmParams:s.keyEncryptionAlgorithmParams}),password:e});this.recipientInfos.push(new nr({variant:4,value:o}))}break;default:throw new Error(`Unknown value for "variant": ${r}`)}}encrypt(e,t){let r=Promise.resolve();const s=new ArrayBuffer(16),a=new Uint8Array(s);Te(a);const n=new Uint8Array(t);let i,o,l;const c=[],u=this,h=Je(e);if(""===h)return Promise.reject('Wrong "contentEncryptionAlgorithm" value');const m=Re();if(void 0===m)return Promise.reject("Unable to create WebCrypto object");function f(e){let t,r,s,a,n,o=Promise.resolve();return o=(o=(o=(o=(o=(o=(o=(o=(o=o.then(()=>{const t=u.recipientInfos[e].value.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(t instanceof W==!1)return Promise.reject(`Incorrect "recipientCertificate" for index ${e}`);switch(t.valueBlock.toString()){case"1.2.840.10045.3.1.7":s="P-256",a=256;break;case"1.3.132.0.34":s="P-384",a=384;break;case"1.3.132.0.35":s="P-521",a=528;break;default:return Promise.reject(`Incorrect curve OID for index ${e}`)}return s},e=>Promise.reject(e))).then(e=>m.generateKey({name:"ECDH",namedCurve:e},!0,["deriveBits"]),e=>Promise.reject(e))).then(e=>(t=e.publicKey,r=e.privateKey,m.exportKey("spki",t)),e=>Promise.reject(e))).then(t=>(n=t,u.recipientInfos[e].value.recipientCertificate.getPublicKey({algorithm:{algorithm:{name:"ECDH",namedCurve:s},usages:[]}})),e=>Promise.reject(e))).then(e=>m.deriveBits({name:"ECDH",public:e},r,a),e=>Promise.reject(e))).then(t=>{const r=new Be({schema:u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmParams}),s=We(r.algorithmId);if("name"in s==!1)return Promise.reject(`Incorrect OID for key encryption algorithm: ${r.algorithmId}`);let a=s.length;const n=new ArrayBuffer(4),i=new Uint8Array(n);for(let e=3;e>=0;e--)i[e]=a,a>>=8;const o=new or({keyInfo:new Be({algorithmId:r.algorithmId,algorithmParams:new H}),entityUInfo:u.recipientInfos[e].value.ukm,suppPubInfo:new L({valueHex:n})}).toSchema().toBER(!1),l=We(u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId);return"name"in l==!1?Promise.reject(`Incorrect OID for key encryption algorithm: ${u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId}`):Ge(l.kdf,t,s.length,o)},e=>Promise.reject(e))).then(e=>m.importKey("raw",e,{name:"AES-KW"},!0,["wrapKey"]),e=>Promise.reject(e))).then(e=>m.wrapKey("raw",i,e,{name:"AES-KW"}),e=>Promise.reject(e))).then(t=>{const r=ke(n),s=new Gt;s.variant=3,s.value=new _t({schema:r.result}),"algorithmParams"in s.value.algorithm&&delete s.value.algorithm.algorithmParams,u.recipientInfos[e].value.originator=s,u.recipientInfos[e].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey=new L({valueHex:t})},e=>Promise.reject(e))}function d(e){let t=Promise.resolve();return t=(t=(t=t.then(()=>{const t=u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmParams,r=new ir({schema:t}),s=We(r.hashAlgorithm.algorithmId);return"name"in s==!1?Promise.reject(`Incorrect OID for hash algorithm: ${r.hashAlgorithm.algorithmId}`):u.recipientInfos[e].value.recipientCertificate.getPublicKey({algorithm:{algorithm:{name:"RSA-OAEP",hash:{name:s.name}},usages:["encrypt","wrapKey"]}})},e=>Promise.reject(e))).then(e=>m.encrypt(e.algorithm,e,l),e=>Promise.reject(e))).then(t=>{u.recipientInfos[e].value.encryptedKey=new L({valueHex:t})},e=>Promise.reject(e))}function g(e){let t,r=Promise.resolve();return r=(r=(r=r.then(()=>"name"in(t=We(u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId))==!1?Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId}`):m.importKey("raw",new Uint8Array(u.recipientInfos[e].value.preDefinedKEK),t,!0,["wrapKey"]),e=>Promise.reject(e))).then(e=>m.wrapKey("raw",i,e,t),e=>Promise.reject(e))).then(t=>{u.recipientInfos[e].value.encryptedKey=new L({valueHex:t})},e=>Promise.reject(e))}function p(e){let t,r,s=Promise.resolve();return s=(s=(s=(s=(s=s.then(()=>{if("keyDerivationAlgorithm"in u.recipientInfos[e].value==!1)return Promise.reject('Please append encoded "keyDerivationAlgorithm"');if("algorithmParams"in u.recipientInfos[e].value.keyDerivationAlgorithm==!1)return Promise.reject('Incorrectly encoded "keyDerivationAlgorithm"');try{t=new je({schema:u.recipientInfos[e].value.keyDerivationAlgorithm.algorithmParams})}catch(e){return Promise.reject('Incorrectly encoded "keyDerivationAlgorithm"')}return Promise.resolve()},e=>Promise.reject(e))).then(()=>{const t=new Uint8Array(u.recipientInfos[e].value.password);return m.importKey("raw",t,"PBKDF2",!1,["deriveKey"])},e=>Promise.reject(e))).then(s=>{if("name"in(r=We(u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId))==!1)return Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId}`);let a="SHA-1";if("prf"in t){const e=We(t.prf.algorithmId);if("name"in e==!1)return Promise.reject("Incorrect OID for HMAC hash algorithm");a=e.hash.name}const n=new Uint8Array(t.salt.valueBlock.valueHex),i=t.iterationCount;return m.deriveKey({name:"PBKDF2",hash:{name:a},salt:n,iterations:i},s,r,!0,["wrapKey"])},e=>Promise.reject(e))).then(e=>m.wrapKey("raw",i,e,r),e=>Promise.reject(e))).then(t=>{u.recipientInfos[e].value.encryptedKey=new L({valueHex:t})},e=>Promise.reject(e))}return r=(r=(r=(r=(r=r.then(()=>m.generateKey(e,!0,["encrypt"]))).then(t=>(i=t,m.encrypt({name:e.name,iv:a},i,n)),e=>Promise.reject(e))).then(e=>(o=e,m.exportKey("raw",i)),e=>Promise.reject(e)).then(e=>(l=e,!0),e=>Promise.reject(e))).then(()=>{this.version=2,this.encryptedContentInfo=new Ve({contentType:"1.2.840.113549.1.7.1",contentEncryptionAlgorithm:new Be({algorithmId:h,algorithmParams:new L({valueHex:s})}),encryptedContent:new L({valueHex:o})})},e=>Promise.reject(e))).then(()=>{for(let e=0;e<this.recipientInfos.length;e++){let t=Promise.resolve();switch(this.recipientInfos[e].variant){case 1:t=d(e);break;case 2:t=f(e);break;case 3:t=g(e);break;case 4:t=p(e);break;default:return Promise.reject(`Uknown recipient type in array with index ${e}`)}c.push(t)}return Promise.all(c)},e=>Promise.reject(e))}decrypt(e,t){let r=Promise.resolve();const s=t||{},a=this;if(e+1>this.recipientInfos.length)return Promise.reject(`Maximum value for "index" is: ${this.recipientInfos.length-1}`);const n=Re();if(void 0===n)return Promise.reject("Unable to create WebCrypto object");function o(e){let t,r,i,o,l=Promise.resolve();return l=(l=(l=(l=(l=(l=l.then(()=>{if("recipientCertificate"in s==!1)return Promise.reject('Parameter "recipientCertificate" is mandatory for "KeyAgreeRecipientInfo"');if("recipientPrivateKey"in s==!1)return Promise.reject('Parameter "recipientPrivateKey" is mandatory for "KeyAgreeRecipientInfo"');const a=s.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(a instanceof W==!1)return Promise.reject(`Incorrect "recipientCertificate" for index ${e}`);switch(i=a.valueBlock.toString()){case"1.2.840.10045.3.1.7":t="P-256",r=256;break;case"1.3.132.0.34":t="P-384",r=384;break;case"1.3.132.0.35":t="P-521",r=528;break;default:return Promise.reject(`Incorrect curve OID for index ${e}`)}return n.importKey("pkcs8",s.recipientPrivateKey,{name:"ECDH",namedCurve:t},!0,["deriveBits"])},e=>Promise.reject(e))).then(r=>{o=r,"algorithmParams"in a.recipientInfos[e].value.originator.value.algorithm==!1&&(a.recipientInfos[e].value.originator.value.algorithm.algorithmParams=new W({value:i}));const s=a.recipientInfos[e].value.originator.value.toSchema().toBER(!1);return n.importKey("spki",s,{name:"ECDH",namedCurve:t},!0,[])},e=>Promise.reject(e))).then(e=>n.deriveBits({name:"ECDH",public:e},o,r),e=>Promise.reject(e))).then(t=>{const r=new Be({schema:a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmParams}),s=We(r.algorithmId);if("name"in s==!1)return Promise.reject(`Incorrect OID for key encryption algorithm: ${r.algorithmId}`);let n=s.length;const i=new ArrayBuffer(4),o=new Uint8Array(i);for(let e=3;e>=0;e--)o[e]=n,n>>=8;const l=new or({keyInfo:new Be({algorithmId:r.algorithmId,algorithmParams:new H}),entityUInfo:a.recipientInfos[e].value.ukm,suppPubInfo:new L({valueHex:i})}).toSchema().toBER(!1),c=We(a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId);return"name"in c==!1?Promise.reject(`Incorrect OID for key encryption algorithm: ${a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId}`):Ge(c.kdf,t,s.length,l)},e=>Promise.reject(e))).then(e=>n.importKey("raw",e,{name:"AES-KW"},!0,["unwrapKey"]),e=>Promise.reject(e))).then(t=>{const r=We(a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);return"name"in r==!1?Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`):n.unwrapKey("raw",a.recipientInfos[e].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHex,t,{name:"AES-KW"},r,!0,["decrypt"])},e=>Promise.reject(e))}function l(e){let t=Promise.resolve();return t=(t=(t=t.then(()=>{if("recipientPrivateKey"in s==!1)return Promise.reject('Parameter "recipientPrivateKey" is mandatory for "KeyTransRecipientInfo"');const t=a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmParams,r=new ir({schema:t}),i=We(r.hashAlgorithm.algorithmId);return"name"in i==!1?Promise.reject(`Incorrect OID for hash algorithm: ${r.hashAlgorithm.algorithmId}`):n.importKey("pkcs8",s.recipientPrivateKey,{name:"RSA-OAEP",hash:{name:i.name}},!0,["decrypt"])},e=>Promise.reject(e))).then(t=>n.decrypt(t.algorithm,t,a.recipientInfos[e].value.encryptedKey.valueBlock.valueHex),e=>Promise.reject(e))).then(e=>{const t=We(a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);return"name"in t==!1?Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`):n.importKey("raw",e,t,!0,["decrypt"])},e=>Promise.reject(e))}function c(e){let t,r=Promise.resolve();return r=(r=r.then(()=>"preDefinedData"in s==!1?Promise.reject('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"'):"name"in(t=We(a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId))==!1?Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId}`):n.importKey("raw",s.preDefinedData,t,!0,["unwrapKey"]),e=>Promise.reject(e))).then(r=>{const s=We(a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);return"name"in s==!1?Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`):n.unwrapKey("raw",a.recipientInfos[e].value.encryptedKey.valueBlock.valueHex,r,t,s,!0,["decrypt"])},e=>Promise.reject(e))}function u(e){let t,r,i=Promise.resolve();return i=(i=(i=i.then(()=>{if("preDefinedData"in s==!1)return Promise.reject('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');if("keyDerivationAlgorithm"in a.recipientInfos[e].value==!1)return Promise.reject('Please append encoded "keyDerivationAlgorithm"');if("algorithmParams"in a.recipientInfos[e].value.keyDerivationAlgorithm==!1)return Promise.reject('Incorrectly encoded "keyDerivationAlgorithm"');try{t=new je({schema:a.recipientInfos[e].value.keyDerivationAlgorithm.algorithmParams})}catch(e){return Promise.reject('Incorrectly encoded "keyDerivationAlgorithm"')}return n.importKey("raw",s.preDefinedData,"PBKDF2",!1,["deriveKey"])},e=>Promise.reject(e))).then(s=>{if("name"in(r=We(a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId))==!1)return Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId}`);let i="SHA-1";if("prf"in t){const e=We(t.prf.algorithmId);if("name"in e==!1)return Promise.reject("Incorrect OID for HMAC hash algorithm");i=e.hash.name}const o=new Uint8Array(t.salt.valueBlock.valueHex),l=t.iterationCount;return n.deriveKey({name:"PBKDF2",hash:{name:i},salt:o,iterations:l},s,r,!0,["unwrapKey"])},e=>Promise.reject(e))).then(t=>{const s=We(a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);return"name"in s==!1?Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`):n.unwrapKey("raw",a.recipientInfos[e].value.encryptedKey.valueBlock.valueHex,t,r,s,!0,["decrypt"])},e=>Promise.reject(e))}return r=(r=r.then(()=>{let t=Promise.resolve();switch(this.recipientInfos[e].variant){case 1:t=l(e);break;case 2:t=o(e);break;case 3:t=c(e);break;case 4:t=u(e);break;default:return Promise.reject(`Uknown recipient type in array with index ${e}`)}return t},e=>Promise.reject(e))).then(e=>{const t=We(this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);const r=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex,s=new Uint8Array(r);let a=new ArrayBuffer(0);if(!1===this.encryptedContentInfo.encryptedContent.idBlock.isConstructed)a=this.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else for(const e of this.encryptedContentInfo.encryptedContent.valueBlock.value)a=i(a,e.valueBlock.valueHex);return n.decrypt({name:t.name,iv:s},e,a)},e=>Promise.reject(e))}}class cr{constructor(e={}){this.safeContents=t(e,"safeContents",cr.defaultValues("safeContents")),"parsedValue"in e&&(this.parsedValue=t(e,"parsedValue",cr.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"safeContents":return[];case"parsedValue":return{};default:throw new Error(`Invalid member name for AuthenticatedSafe class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"safeContents":return 0===t.length;case"parsedValue":return t instanceof Object&&0===Object.keys(t).length;default:throw new Error(`Invalid member name for AuthenticatedSafe class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new ve({name:r.contentInfos||"",value:tt.schema()})]})}fromSchema(e){const t=Ae(e,e,cr.schema({names:{contentInfos:"contentInfos"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AuthenticatedSafe");this.safeContents=Array.from(t.result.contentInfos,e=>new tt({schema:e}))}toSchema(){return new O({value:Array.from(this.safeContents,e=>e.toSchema())})}toJSON(){return{safeContents:Array.from(this.safeContents,e=>e.toJSON())}}parseInternalValues(e){if(e instanceof Object==!1)return Promise.reject('The "parameters" must has "Object" type');if("safeContents"in e==!1)return Promise.reject('Absent mandatory parameter "safeContents"');if(e.safeContents instanceof Array==!1)return Promise.reject('The "parameters.safeContents" must has "Array" type');if(e.safeContents.length!==this.safeContents.length)return Promise.reject('Length of "parameters.safeContents" must be equal to "this.safeContents.length"');let t=Promise.resolve();this.parsedValue={safeContents:[]};for(const[r,s]of this.safeContents.entries())switch(s.contentType){case"1.2.840.113549.1.7.1":{if(s.content instanceof L==!1)return Promise.reject('Wrong type of "this.safeContents[j].content"');let e=new ArrayBuffer(0);if(s.content.valueBlock.isConstructed)for(const t of s.content.valueBlock.value)e=i(e,t.valueBlock.valueHex);else e=s.content.valueBlock.valueHex;const t=ke(e);if(-1===t.offset)return Promise.reject('Error during parsing of ASN.1 data inside "content.content"');this.parsedValue.safeContents.push({privacyMode:0,value:new Rt({schema:t.result})})}break;case"1.2.840.113549.1.7.3":{const a=new lr({schema:s.content});if("recipientCertificate"in e.safeContents[r]==!1)return Promise.reject('Absent mandatory parameter "recipientCertificate" in "parameters.safeContents[j]"');const n=e.safeContents[r].recipientCertificate;if("recipientKey"in e.safeContents[r]==!1)return Promise.reject('Absent mandatory parameter "recipientKey" in "parameters.safeContents[j]"');const i=e.safeContents[r].recipientKey;t=(t=t.then(()=>a.decrypt(0,{recipientCertificate:n,recipientPrivateKey:i}))).then(e=>{const t=ke(e);return-1===t.offset?Promise.reject("Error during parsing of decrypted data"):(this.parsedValue.safeContents.push({privacyMode:2,value:new Rt({schema:t.result})}),Promise.resolve())})}break;case"1.2.840.113549.1.7.6":{const a=new rt({schema:s.content});if("password"in e.safeContents[r]==!1)return Promise.reject('Absent mandatory parameter "password" in "parameters.safeContents[j]"');const n=e.safeContents[r].password;t=(t=t.then(()=>a.decrypt({password:n}),e=>Promise.reject(e))).then(e=>{const t=ke(e);return-1===t.offset?Promise.reject("Error during parsing of decrypted data"):(this.parsedValue.safeContents.push({privacyMode:1,value:new Rt({schema:t.result})}),Promise.resolve())},e=>Promise.reject(e))}break;default:throw new Error(`Unknown "contentType" for AuthenticatedSafe: " ${s.contentType}`)}return t}makeInternalValues(e){if("parsedValue"in this==!1)return Promise.reject('Please run "parseValues" first or add "parsedValue" manually');if(this.parsedValue instanceof Object==!1)return Promise.reject('The "this.parsedValue" must has "Object" type');if(this.parsedValue.safeContents instanceof Array==!1)return Promise.reject('The "this.parsedValue.safeContents" must has "Array" type');if(e instanceof Object==!1)return Promise.reject('The "parameters" must has "Object" type');if("safeContents"in e==!1)return Promise.reject('Absent mandatory parameter "safeContents"');if(e.safeContents instanceof Array==!1)return Promise.reject('The "parameters.safeContents" must has "Array" type');if(e.safeContents.length!==this.parsedValue.safeContents.length)return Promise.reject('Length of "parameters.safeContents" must be equal to "this.parsedValue.safeContents"');let t=Promise.resolve();this.safeContents=[];for(const[r,s]of this.parsedValue.safeContents.entries()){if("privacyMode"in s==!1)return Promise.reject('The "privacyMode" is a mandatory parameter for "content"');if("value"in s==!1)return Promise.reject('The "value" is a mandatory parameter for "content"');if(s.value instanceof Rt==!1)return Promise.reject('The "content.value" must has "SafeContents" type');switch(s.privacyMode){case 0:{const e=s.value.toSchema().toBER(!1);t=t.then(()=>{this.safeContents.push(new tt({contentType:"1.2.840.113549.1.7.1",content:new L({valueHex:e})}))})}break;case 1:{const a=new rt,n=e.safeContents[r];n.contentToEncrypt=s.value.toSchema().toBER(!1),t=(t=t.then(()=>a.encrypt(n),e=>Promise.reject(e))).then(()=>{this.safeContents.push(new tt({contentType:"1.2.840.113549.1.7.6",content:a.toSchema()}))},e=>Promise.reject(e))}break;case 2:{const a=new lr,n=s.value.toSchema().toBER(!1);if("encryptingCertificate"in e.safeContents[r]==!1)return Promise.reject('Absent mandatory parameter "encryptingCertificate" in "parameters.safeContents[i]"');if("encryptionAlgorithm"in e.safeContents[r]==!1)return Promise.reject('Absent mandatory parameter "encryptionAlgorithm" in "parameters.safeContents[i]"');switch(!0){case"aes-cbc"===e.safeContents[r].encryptionAlgorithm.name.toLowerCase():case"aes-gcm"===e.safeContents[r].encryptionAlgorithm.name.toLowerCase():break;default:return Promise.reject(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${e.safeContents[r].encryptionAlgorithm}`)}switch(!0){case 128===e.safeContents[r].encryptionAlgorithm.length:case 192===e.safeContents[r].encryptionAlgorithm.length:case 256===e.safeContents[r].encryptionAlgorithm.length:break;default:return Promise.reject(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${e.safeContents[r].encryptionAlgorithm.length}`)}const i=e.safeContents[r].encryptionAlgorithm;a.addRecipientByCertificate(e.safeContents[r].encryptingCertificate),t=(t=t.then(()=>a.encrypt(i,n))).then(()=>{this.safeContents.push(new tt({contentType:"1.2.840.113549.1.7.3",content:a.toSchema()}))})}break;default:return Promise.reject(`Incorrect value for "content.privacyMode": ${s.privacyMode}`)}}return t.then(()=>this,e=>Promise.reject(`Error during parsing: ${e}`))}}class ur{constructor(e={}){this.hashAlgorithm=t(e,"hashAlgorithm",ur.defaultValues("hashAlgorithm")),this.issuerNameHash=t(e,"issuerNameHash",ur.defaultValues("issuerNameHash")),this.issuerKeyHash=t(e,"issuerKeyHash",ur.defaultValues("issuerKeyHash")),this.serialNumber=t(e,"serialNumber",ur.defaultValues("serialNumber")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new Be;case"issuerNameHash":case"issuerKeyHash":return new L;case"serialNumber":return new J;default:throw new Error(`Invalid member name for CertID class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"hashAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"issuerNameHash":case"issuerKeyHash":case"serialNumber":return t.isEqual(ur.defaultValues(e));default:throw new Error(`Invalid member name for CertID class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Be.schema(r.hashAlgorithmObject||{names:{blockName:r.hashAlgorithm||""}}),new L({name:r.issuerNameHash||""}),new L({name:r.issuerKeyHash||""}),new J({name:r.serialNumber||""})]})}fromSchema(e){const t=Ae(e,e,ur.schema({names:{hashAlgorithm:"hashAlgorithm",issuerNameHash:"issuerNameHash",issuerKeyHash:"issuerKeyHash",serialNumber:"serialNumber"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertID");this.hashAlgorithm=new Be({schema:t.result.hashAlgorithm}),this.issuerNameHash=t.result.issuerNameHash,this.issuerKeyHash=t.result.issuerKeyHash,this.serialNumber=t.result.serialNumber}toSchema(){return new O({value:[this.hashAlgorithm.toSchema(),this.issuerNameHash,this.issuerKeyHash,this.serialNumber]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),issuerNameHash:this.issuerNameHash.toJSON(),issuerKeyHash:this.issuerKeyHash.toJSON(),serialNumber:this.serialNumber.toJSON()}}isEqual(e){return!this.hashAlgorithm.algorithmId!==e.hashAlgorithm.algorithmId&&(!1!==l(this.issuerNameHash.valueBlock.valueHex,e.issuerNameHash.valueBlock.valueHex)&&(!1!==l(this.issuerKeyHash.valueBlock.valueHex,e.issuerKeyHash.valueBlock.valueHex)&&!!this.serialNumber.isEqual(e.serialNumber)))}createForCertificate(e,t){let r,s=Promise.resolve();const a=Re();if(void 0===a)return Promise.reject("Unable to create WebCrypto object");if("hashAlgorithm"in t==!1)return Promise.reject('Parameter "hashAlgorithm" is mandatory for "OCSP_REQUEST.createForCertificate"');const n=Je({name:t.hashAlgorithm});return""===n?Promise.reject(`Incorrect "hashAlgorithm": ${this.hashAlgorithm}`):(this.hashAlgorithm=new Be({algorithmId:n,algorithmParams:new H}),"issuerCertificate"in t?(r=t.issuerCertificate,this.serialNumber=e.serialNumber,s=(s=s.then(()=>a.digest({name:t.hashAlgorithm},r.subject.toSchema().toBER(!1)),e=>Promise.reject(e))).then(e=>{this.issuerNameHash=new L({valueHex:e});const s=r.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex;return a.digest({name:t.hashAlgorithm},s)},e=>Promise.reject(e)).then(e=>{this.issuerKeyHash=new L({valueHex:e})},e=>Promise.reject(e))):Promise.reject('Parameter "issuerCertificate" is mandatory for "OCSP_REQUEST.createForCertificate"'))}}class hr{constructor(e={}){this.certID=t(e,"certID",hr.defaultValues("certID")),this.certStatus=t(e,"certStatus",hr.defaultValues("certStatus")),this.thisUpdate=t(e,"thisUpdate",hr.defaultValues("thisUpdate")),"nextUpdate"in e&&(this.nextUpdate=t(e,"nextUpdate",hr.defaultValues("nextUpdate"))),"singleExtensions"in e&&(this.singleExtensions=t(e,"singleExtensions",hr.defaultValues("singleExtensions"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certID":return new ur;case"certStatus":return{};case"thisUpdate":case"nextUpdate":return new Date(0,0,0);case"singleExtensions":return[];default:throw new Error(`Invalid member name for SingleResponse class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"certID":return ur.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&ur.compareWithDefault("issuerNameHash",t.issuerNameHash)&&ur.compareWithDefault("issuerKeyHash",t.issuerKeyHash)&&ur.compareWithDefault("serialNumber",t.serialNumber);case"certStatus":return 0===Object.keys(t).length;case"thisUpdate":case"nextUpdate":return t===hr.defaultValues(e);default:throw new Error(`Invalid member name for SingleResponse class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[ur.schema(r.certID||{}),new pe({value:[new I({name:r.certStatus||"",idBlock:{tagClass:3,tagNumber:0},lenBlockLength:1}),new E({name:r.certStatus||"",idBlock:{tagClass:3,tagNumber:1},value:[new ue,new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new $]})]}),new I({name:r.certStatus||"",idBlock:{tagClass:3,tagNumber:2},lenBlock:{length:1}})]}),new ue({name:r.thisUpdate||""}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ue({name:r.nextUpdate||""})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[St.schema(r.singleExtensions||{})]})]})}fromSchema(e){const t=Ae(e,e,hr.schema({names:{certID:{names:{blockName:"certID"}},certStatus:"certStatus",thisUpdate:"thisUpdate",nextUpdate:"nextUpdate",singleExtensions:{names:{blockName:"singleExtensions"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SingleResponse");this.certID=new ur({schema:t.result.certID}),this.certStatus=t.result.certStatus,this.thisUpdate=t.result.thisUpdate.toDate(),"nextUpdate"in t.result&&(this.nextUpdate=t.result.nextUpdate.toDate()),"singleExtensions"in t.result&&(this.singleExtensions=Array.from(t.result.singleExtensions.valueBlock.value,e=>new Bt({schema:e})))}toSchema(){const e=[];return e.push(this.certID.toSchema()),e.push(this.certStatus),e.push(new ue({valueDate:this.thisUpdate})),"nextUpdate"in this&&e.push(new ue({valueDate:this.nextUpdate})),"singleExtensions"in this&&e.push(new O({value:Array.from(this.singleExtensions,e=>e.toSchema())})),new O({value:e})}toJSON(){const e={certID:this.certID.toJSON(),certStatus:this.certStatus.toJSON(),thisUpdate:this.thisUpdate};return"nextUpdate"in this&&(e.nextUpdate=this.nextUpdate),"singleExtensions"in this&&(e.singleExtensions=Array.from(this.singleExtensions,e=>e.toJSON())),e}}class mr{constructor(e={}){this.tbs=t(e,"tbs",mr.defaultValues("tbs")),this.responderID=t(e,"responderID",mr.defaultValues("responderID")),this.producedAt=t(e,"producedAt",mr.defaultValues("producedAt")),this.responses=t(e,"responses",mr.defaultValues("responses")),"responseExtensions"in e&&(this.responseExtensions=t(e,"responseExtensions",mr.defaultValues("responseExtensions"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"responderID":return{};case"producedAt":return new Date(0,0,0);case"responses":case"responseExtensions":return[];default:throw new Error(`Invalid member name for ResponseData class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"tbs":return 0===t.byteLength;case"responderID":return 0===Object.keys(t).length;case"producedAt":return t===mr.defaultValues(e);case"responses":case"responseExtensions":return 0===t.length;default:throw new Error(`Invalid member name for ResponseData class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"ResponseData",value:[new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new J({name:r.version||"ResponseData.version"})]}),new pe({value:[new E({name:r.responderID||"ResponseData.responderID",idBlock:{tagClass:3,tagNumber:1},value:[ze.schema(r.ResponseDataByName||{names:{blockName:"ResponseData.byName"}})]}),new E({name:r.responderID||"ResponseData.responderID",idBlock:{tagClass:3,tagNumber:2},value:[new L({name:r.ResponseDataByKey||"ResponseData.byKey"})]})]}),new ue({name:r.producedAt||"ResponseData.producedAt"}),new O({value:[new ve({name:"ResponseData.responses",value:hr.schema(r.response||{})})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[St.schema(r.extensions||{names:{blockName:"ResponseData.responseExtensions"}})]})]})}fromSchema(e){const t=Ae(e,e,mr.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ocsp.ResponseData");this.tbs=t.result.ResponseData.valueBeforeDecode,"ResponseData.version"in t.result&&(this.version=t.result["ResponseData.version"].valueBlock.valueDec),1===t.result["ResponseData.responderID"].idBlock.tagNumber?this.responderID=new ze({schema:t.result["ResponseData.responderID"].valueBlock.value[0]}):this.responderID=t.result["ResponseData.responderID"].valueBlock.value[0],this.producedAt=t.result["ResponseData.producedAt"].toDate(),this.responses=Array.from(t.result["ResponseData.responses"],e=>new hr({schema:e})),"ResponseData.responseExtensions"in t.result&&(this.responseExtensions=Array.from(t.result["ResponseData.responseExtensions"].valueBlock.value,e=>new Bt({schema:e})))}toSchema(e=!1){let t;if(!1===e){if(0===this.tbs.length)return mr.schema();t=ke(this.tbs).result}else{const e=[];"version"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:[new J({value:this.version})]})),this.responderID instanceof ze?e.push(new E({idBlock:{tagClass:3,tagNumber:1},value:[this.responderID.toSchema()]})):e.push(new E({idBlock:{tagClass:3,tagNumber:2},value:[this.responderID]})),e.push(new ue({valueDate:this.producedAt})),e.push(new O({value:Array.from(this.responses,e=>e.toSchema())})),"responseExtensions"in this&&e.push(new O({value:Array.from(this.responseExtensions,e=>e.toSchema())})),t=new O({value:e})}return t}toJSON(){const e={};return"version"in this&&(e.version=this.version),"responderID"in this&&(e.responderID=this.responderID),"producedAt"in this&&(e.producedAt=this.producedAt),"responses"in this&&(e.responses=Array.from(this.responses,e=>e.toJSON())),"responseExtensions"in this&&(e.responseExtensions=Array.from(this.responseExtensions,e=>e.toJSON())),e}}class fr{constructor(e={}){this.trustedCerts=t(e,"trustedCerts",this.defaultValues("trustedCerts")),this.certs=t(e,"certs",this.defaultValues("certs")),this.crls=t(e,"crls",this.defaultValues("crls")),this.ocsps=t(e,"ocsps",this.defaultValues("ocsps")),this.checkDate=t(e,"checkDate",this.defaultValues("checkDate")),this.findOrigin=t(e,"findOrigin",this.defaultValues("findOrigin")),this.findIssuer=t(e,"findIssuer",this.defaultValues("findIssuer")),"schema"in e&&this.fromSchema(e.schema)}defaultFindOrigin(e,t){0===e.tbs.byteLength&&(e.tbs=e.encodeTBS());for(const r of t.certs)if(0===r.tbs.byteLength&&(r.tbs=r.encodeTBS()),l(e.tbs,r.tbs))return"Intermediate Certificates";for(const r of t.trustedCerts)if(0===r.tbs.byteLength&&(r.tbs=r.encodeTBS()),l(e.tbs,r.tbs))return"Trusted Certificates";return"Unknown"}async defaultFindIssuer(e,t){let r=[],s=null,a=null,n=null;if(e.subject.isEqual(e.issuer))try{if(!0===await e.verify())return[e]}catch(e){}if("extensions"in e)for(const t of e.extensions)if("2.5.29.35"===t.extnID){"keyIdentifier"in t.parsedValue?s=t.parsedValue.keyIdentifier:("authorityCertIssuer"in t.parsedValue&&(a=t.parsedValue.authorityCertIssuer),"authorityCertSerialNumber"in t.parsedValue&&(n=t.parsedValue.authorityCertSerialNumber));break}function i(t){if(null!==s&&"extensions"in t){let e=!1;for(const a of t.extensions)if("2.5.29.14"===a.extnID){e=!0,l(a.parsedValue.valueBlock.valueHex,s.valueBlock.valueHex)&&r.push(t);break}if(e)return}let i=!1;null!==n&&(i=t.serialNumber.isEqual(n)),null!==a?t.subject.isEqual(a)&&i&&r.push(t):e.issuer.isEqual(t.subject)&&r.push(t)}for(const e of t.trustedCerts)i(e);for(const e of t.certs)i(e);for(let t=0;t<r.length;t++)try{!1===await e.verify(r[t])&&r.splice(t,1)}catch(e){r.splice(t,1)}return r}defaultValues(e){switch(e){case"trustedCerts":case"certs":case"crls":case"ocsps":return[];case"checkDate":return new Date;case"findOrigin":return this.defaultFindOrigin;case"findIssuer":return this.defaultFindIssuer;default:throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${e}`)}}async sort(){const e=[],t=this;async function r(e){const s=[];function a(e){let t=!0;for(let r=0;r<e.length;r++){for(let s=0;s<e.length;s++)if(s!==r&&e[r]===e[s]){t=!1;break}if(!t)break}return t}const n=await t.findIssuer(e,t);if(0===n.length)throw new Error("No valid certificate paths found");for(let t=0;t<n.length;t++){if(l(n[t].tbs,e.tbs)){s.push([n[t]]);continue}const i=await r(n[t]);for(let e=0;e<i.length;e++){const r=i[e].slice();r.splice(0,0,n[t]),a(r)?s.push(r):s.push(i[e])}}return s}async function s(r){const s=[],a=[],n=[];if(s.push(...e.filter(e=>r.issuer.isEqual(e.subject))),0===s.length)return{status:1,statusMessage:"No certificate's issuers"};if(a.push(...t.crls.filter(e=>e.issuer.isEqual(r.issuer))),0===a.length)return{status:1,statusMessage:"No CRLs for specific certificate issuer"};for(let e=0;e<a.length;e++)if(!(a[e].nextUpdate.value<t.checkDate))for(let t=0;t<s.length;t++)try{if(await a[e].verify({issuerCertificate:s[t]})){n.push({crl:a[e],certificate:s[t]});break}}catch(e){}return n.length?{status:0,statusMessage:"",result:n}:{status:1,statusMessage:"No valid CRLs found"}}async function a(e,r){const s=We(e.signatureAlgorithm.algorithmId);if("name"in s==!1)return 1;if("hash"in s==!1)return 1;for(let s=0;s<t.ocsps.length;s++){const a=await t.ocsps[s].getCertificateStatus(e,r);if(a.isForCertificate)return 0===a.status?0:1}return 2}async function n(e,t=!1){let r=!1,s=!1,a=!1,n=!1;if("extensions"in e){for(let t=0;t<e.extensions.length;t++){if(!0===e.extensions[t].critical&&"parsedValue"in e.extensions[t]==!1)return{result:!1,resultCode:6,resultMessage:`Unable to parse critical certificate extension: ${e.extensions[t].extnID}`};if("2.5.29.15"===e.extensions[t].extnID){a=!0;const r=new Uint8Array(e.extensions[t].parsedValue.valueBlock.valueHex);4==(4&r[0])&&(s=!0),2==(2&r[0])&&(n=!0)}"2.5.29.19"===e.extensions[t].extnID&&"cA"in e.extensions[t].parsedValue&&!0===e.extensions[t].parsedValue.cA&&(r=!0)}if(!0===s&&!1===r)return{result:!1,resultCode:3,resultMessage:'Unable to build certificate chain - using "keyCertSign" flag set without BasicConstaints'};if(!0===a&&!0===r&&!1===s)return{result:!1,resultCode:4,resultMessage:'Unable to build certificate chain - "keyCertSign" flag was not set'};if(!0===r&&!0===a&&t&&!1===n)return{result:!1,resultCode:5,resultMessage:'Unable to build certificate chain - intermediate certificate must have "cRLSign" key usage flag'}}return!1===r?{result:!1,resultCode:7,resultMessage:"Unable to build certificate chain - more than one possible end-user certificate"}:{result:!0,resultCode:0,resultMessage:""}}async function i(e,r){for(let t=0;t<e.length;t++)if(e[t].notBefore.value>r||e[t].notAfter.value<r)return{result:!1,resultCode:8,resultMessage:"Certificate validity period is out of checking date"};if(e.length<2)return{result:!1,resultCode:9,resultMessage:"Too short certificate path"};for(let t=e.length-2;t>=0;t--)if(!1===e[t].issuer.isEqual(e[t].subject)&&!1===e[t].issuer.isEqual(e[t+1].subject))return{result:!1,resultCode:10,resultMessage:"Incorrect name chaining"};if(0!==t.crls.length||0!==t.ocsps.length)for(let r=0;r<e.length-2;r++){let i,o;if(0!==t.ocsps.length)switch(i=await a(e[r],e[r+1])){case 0:continue;case 1:return{result:!1,resultCode:12,resultMessage:"One of certificates was revoked via OCSP response"}}if(0!==t.crls.length){if((o=await s(e[r])).status)throw{result:!1,resultCode:11,resultMessage:`No revocation values found for one of certificates: ${o.statusMessage}`};for(let t=0;t<o.result.length;t++){if(o.result[t].crl.isCertificateRevoked(e[r]))return{result:!1,resultCode:12,resultMessage:"One of certificates had been revoked"};if(!1===(await n(o.result[t].certificate,!0)).result)return{result:!1,resultCode:13,resultMessage:"CRL issuer certificate is not a CA certificate or does not have crlSign flag"}}}else if(2===i)return{result:!1,resultCode:11,resultMessage:"No revocation values found for one of certificates"}}for(let t=1;t<e.length;t++){if(!1===(await n(e[t])).result)return{result:!1,resultCode:14,resultMessage:"One of intermediate certificates is not a CA certificate"}}return{result:!0}}e.push(...t.trustedCerts),e.push(...t.certs);for(let t=0;t<e.length;t++)for(let r=0;r<e.length;r++)if(t!==r&&l(e[t].tbs,e[r].tbs)){e.splice(r,1),t=0;break}let o;const c=[e[e.length-1]];if(0===(o=await r(e[e.length-1])).length)return{result:!1,resultCode:60,resultMessage:"Unable to find certificate path"};for(let e=0;e<o.length;e++){let r=!1;for(let s=0;s<o[e].length;s++){const a=o[e][s];for(let e=0;e<t.trustedCerts.length;e++)if(l(a.tbs,t.trustedCerts[e].tbs)){r=!0;break}if(r)break}r||(o.splice(e,1),e=0)}if(0===o.length)throw{result:!1,resultCode:97,resultMessage:"No valid certificate paths found"};let u=o[0].length,h=0;for(let e=0;e<o.length;e++)o[e].length<u&&(u=o[e].length,h=e);for(let e=0;e<o[h].length;e++)c.push(o[h][e]);if(!1===(o=await i(c,t.checkDate)).result)throw o;return c}async verify(e={}){try{if(0===this.certs.length)throw"Empty certificate array";let i=[];i.push("2.5.29.32.0");let o=!1,l=!1,c=!1,u=[],h=[],m=[];"initialPolicySet"in e&&(i=e.initialPolicySet),"initialExplicitPolicy"in e&&(o=e.initialExplicitPolicy),"initialPolicyMappingInhibit"in e&&(l=e.initialPolicyMappingInhibit),"initialInhibitPolicy"in e&&(c=e.initialInhibitPolicy),"initialPermittedSubtreesSet"in e&&(u=e.initialPermittedSubtreesSet),"initialExcludedSubtreesSet"in e&&(h=e.initialExcludedSubtreesSet),"initialRequiredNameForms"in e&&(m=e.initialRequiredNameForms);let f=o,d=l,g=c;const p=new Array(3);p[0]=!1,p[1]=!1,p[2]=!1;let y=0,v=0,b=0,w=u,k=h;const A=m;let B=1;this.certs=await this.sort();const S=[];S.push("2.5.29.32.0");const C=[],I=new Array(this.certs.length-1);for(let e=0;e<this.certs.length-1;e++)I[e]=!0;C.push(I);const N=new Array(this.certs.length-1),E=new Array(this.certs.length-1);let x=f?this.certs.length-1:-1;for(let e=this.certs.length-2;e>=0;e--,B++)if("extensions"in this.certs[e]){for(let t=0;t<this.certs[e].extensions.length;t++){if("2.5.29.32"===this.certs[e].extensions[t].extnID){E[e]=this.certs[e].extensions[t].parsedValue;for(let t=0;t<S.length;t++)if("2.5.29.32.0"===S[t]){delete C[t][e];break}for(let r=0;r<this.certs[e].extensions[t].parsedValue.certificatePolicies.length;r++){let s=-1;for(let a=0;a<S.length;a++)if(this.certs[e].extensions[t].parsedValue.certificatePolicies[r].policyIdentifier===S[a]){s=a;break}if(-1===s){S.push(this.certs[e].extensions[t].parsedValue.certificatePolicies[r].policyIdentifier);const s=new Array(this.certs.length-1);s[e]=!0,C.push(s)}else C[s][e]=!0}}if("2.5.29.33"===this.certs[e].extensions[t].extnID){if(d)return{result:!1,resultCode:98,resultMessage:"Policy mapping prohibited"};N[e]=this.certs[e].extensions[t].parsedValue}"2.5.29.36"===this.certs[e].extensions[t].extnID&&!1===f&&(0===this.certs[e].extensions[t].parsedValue.requireExplicitPolicy?(f=!0,x=e):!1===p[0]?(p[0]=!0,y=this.certs[e].extensions[t].parsedValue.requireExplicitPolicy):y=y>this.certs[e].extensions[t].parsedValue.requireExplicitPolicy?this.certs[e].extensions[t].parsedValue.requireExplicitPolicy:y,0===this.certs[e].extensions[t].parsedValue.inhibitPolicyMapping?d=!0:!1===p[1]?(p[1]=!0,v=this.certs[e].extensions[t].parsedValue.inhibitPolicyMapping+1):v=v>this.certs[e].extensions[t].parsedValue.inhibitPolicyMapping+1?this.certs[e].extensions[t].parsedValue.inhibitPolicyMapping+1:v),"2.5.29.54"===this.certs[e].extensions[t].extnID&&!1===g&&(0===this.certs[e].extensions[t].parsedValue.valueBlock.valueDec?g=!0:!1===p[2]?(p[2]=!0,b=this.certs[e].extensions[t].parsedValue.valueBlock.valueDec):b=b>this.certs[e].extensions[t].parsedValue.valueBlock.valueDec?this.certs[e].extensions[t].parsedValue.valueBlock.valueDec:b)}if(!0===g){let t=-1;for(let e=0;e<S.length;e++)if("2.5.29.32.0"===S[e]){t=e;break}-1!==t&&delete C[0][e]}!1===f&&!0===p[0]&&0===--y&&(f=!0,x=e,p[0]=!1),!1===d&&!0===p[1]&&0===--v&&(d=!0,p[1]=!1),!1===g&&!0===p[2]&&0===--b&&(g=!0,p[2]=!1)}for(let e=0;e<this.certs.length-1;e++)if(e<this.certs.length-2&&void 0!==N[e+1])for(let t=0;t<N[e+1].mappings.length;t++){if("2.5.29.32.0"===N[e+1].mappings[t].issuerDomainPolicy||"2.5.29.32.0"===N[e+1].mappings[t].subjectDomainPolicy)return{result:!1,resultCode:99,resultMessage:'The "anyPolicy" should not be a part of policy mapping scheme'};let r=-1,s=-1;for(let a=0;a<S.length;a++)S[a]===N[e+1].mappings[t].issuerDomainPolicy&&(r=a),S[a]===N[e+1].mappings[t].subjectDomainPolicy&&(s=a);void 0!==C[r][e]&&delete C[r][e];for(let a=0;a<E[e].certificatePolicies.length;a++)if(N[e+1].mappings[t].subjectDomainPolicy===E[e].certificatePolicies[a].policyIdentifier&&-1!==r&&-1!==s)for(let t=0;t<=e;t++)void 0!==C[s][t]&&(C[r][t]=!0,delete C[s][t])}for(let e=0;e<S.length;e++)if("2.5.29.32.0"===S[e])for(let t=0;t<x;t++)delete C[e][t];const P=[];for(let e=0;e<C.length;e++){let t=!0;for(let r=0;r<this.certs.length-1;r++){let s=!1;if(r<x&&"2.5.29.32.0"===S[e]&&S.length>1){t=!1;break}if(void 0===C[e][r]){if(r>=x)for(let e=0;e<S.length;e++)if("2.5.29.32.0"===S[e]){!0===C[e][r]&&(s=!0);break}if(!s){t=!1;break}}}!0===t&&P.push(S[e])}let D=[];if(1===i.length&&"2.5.29.32.0"===i[0]&&!1===f)D=i;else if(1===P.length&&"2.5.29.32.0"===P[0])D=i;else for(let e=0;e<P.length;e++)for(let t=0;t<i.length;t++)if(i[t]===P[e]||"2.5.29.32.0"===i[t]){D.push(P[e]);break}const V={result:D.length>0,resultCode:0,resultMessage:D.length>0?"":'Zero "userConstrPolicies" array, no intersections with "authConstrPolicies"',authConstrPolicies:P,userConstrPolicies:D,explicitPolicyIndicator:f,policyMappings:N,certificatePath:this.certs};if(0===D.length)return V;function t(e,t){const r=Fe(e),s=Fe(t),a=r.split("."),n=s.split("."),i=a.length,o=n.length;if(0===i||0===o||i<o)return!1;for(let e=0;e<i;e++)if(0===a[e].length)return!1;for(let e=0;e<o;e++)if(0===n[e].length){if(0===e){if(1===o)return!1;continue}return!1}for(let e=0;e<o;e++)if(0!==n[o-1-e].length&&0!==a[i-1-e].localeCompare(n[o-1-e]))return!1;return!0}function r(e,r){const s=Fe(e),a=Fe(r),n=s.split("@"),i=a.split("@");if(0===n.length||0===i.length||n.length<i.length)return!1;if(1===i.length){if(t(n[1],i[0])){const e=n[1].split("."),t=i[0].split(".");return 0===t[0].length||e.length===t.length}return!1}return 0===s.localeCompare(a)}function s(e,r){let s=Fe(e);const a=Fe(r),n=s.split("/");if(a.split("/").length>1)return!1;if(n.length>1)for(let e=0;e<n.length;e++)if(n[e].length>0&&":"!==n[e].charAt(n[e].length-1)){s=n[e].split(":")[0];break}if(t(s,a)){const e=s.split("."),t=a.split(".");return 0===t[0].length||e.length===t.length}return!1}function a(e,t){const r=new Uint8Array(e.valueBlock.valueHex),s=new Uint8Array(t.valueBlock.valueHex);if(4===r.length&&8===s.length){for(let e=0;e<4;e++)if((r[e]^s[e])&s[e+4])return!1;return!0}if(16===r.length&&32===s.length){for(let e=0;e<16;e++)if((r[e]^s[e])&s[e+16])return!1;return!0}return!1}function n(e,t){if(0===e.typesAndValues.length||0===t.typesAndValues.length)return!0;if(e.typesAndValues.length<t.typesAndValues.length)return!1;let r=!0,s=0;for(let a=0;a<t.typesAndValues.length;a++){let n=!1;for(let i=s;i<e.typesAndValues.length;i++)if(n=e.typesAndValues[i].isEqual(t.typesAndValues[a]),e.typesAndValues[i].type===t.typesAndValues[a].type&&(r=r&&n),!0===n){if(0===s||s===i){s=i+1;break}return!1}if(!1===n)return!1}return 0!==s&&r}if(!1===V.result)return V;B=1;for(let e=this.certs.length-2;e>=0;e--,B++){let i=[],o=[],l=[];if("extensions"in this.certs[e])for(let t=0;t<this.certs[e].extensions.length;t++)"2.5.29.30"===this.certs[e].extensions[t].extnID&&("permittedSubtrees"in this.certs[e].extensions[t].parsedValue&&(o=o.concat(this.certs[e].extensions[t].parsedValue.permittedSubtrees)),"excludedSubtrees"in this.certs[e].extensions[t].parsedValue&&(l=l.concat(this.certs[e].extensions[t].parsedValue.excludedSubtrees))),"2.5.29.17"===this.certs[e].extensions[t].extnID&&(i=i.concat(this.certs[e].extensions[t].parsedValue.altNames));let c=A.length<=0;for(let t=0;t<A.length;t++)switch(A[t].base.type){case 4:if(A[t].base.value.typesAndValues.length!==this.certs[e].subject.typesAndValues.length)continue;c=!0;for(let r=0;r<this.certs[e].subject.typesAndValues.length;r++)if(this.certs[e].subject.typesAndValues[r].type!==A[t].base.value.typesAndValues[r].type){c=!1;break}if(!0===c)break}if(!1===c)throw V.result=!1,V.resultCode=21,V.resultMessage="No neccessary name form found",V;const u=[];u[0]=[],u[1]=[],u[2]=[],u[3]=[],u[4]=[];for(let e=0;e<w.length;e++)switch(w[e].base.type){case 1:u[0].push(w[e]);break;case 2:u[1].push(w[e]);break;case 4:u[2].push(w[e]);break;case 6:u[3].push(w[e]);break;case 7:u[4].push(w[e])}for(let o=0;o<5;o++){let l=!1,c=!1;const h=u[o];for(let u=0;u<h.length;u++){switch(o){case 0:if(i.length>0)for(let e=0;e<i.length;e++)1===i[e].type&&(c=!0,l=l||r(i[e].value,h[u].base.value));else for(let t=0;t<this.certs[e].subject.typesAndValues.length;t++)"1.2.840.113549.1.9.1"!==this.certs[e].subject.typesAndValues[t].type&&"0.9.2342.19200300.100.1.3"!==this.certs[e].subject.typesAndValues[t].type||(c=!0,l=l||r(this.certs[e].subject.typesAndValues[t].value.valueBlock.value,h[u].base.value));break;case 1:if(i.length>0)for(let e=0;e<i.length;e++)2===i[e].type&&(c=!0,l=l||t(i[e].value,h[u].base.value));break;case 2:c=!0,l=n(this.certs[e].subject,h[u].base.value);break;case 3:if(i.length>0)for(let e=0;e<i.length;e++)6===i[e].type&&(c=!0,l=l||s(i[e].value,h[u].base.value));break;case 4:if(i.length>0)for(let e=0;e<i.length;e++)7===i[e].type&&(c=!0,l=l||a(i[e].value,h[u].base.value))}if(l)break}if(!1===l&&h.length>0&&c)throw V.result=!1,V.resultCode=41,V.resultMessage='Failed to meet "permitted sub-trees" name constraint',V}let h=!1;for(let o=0;o<k.length;o++){switch(k[o].base.type){case 1:if(i.length>=0)for(let e=0;e<i.length;e++)1===i[e].type&&(h=h||r(i[e].value,k[o].base.value));else for(let e=0;e<this.subject.typesAndValues.length;e++)"1.2.840.113549.1.9.1"!==this.subject.typesAndValues[e].type&&"0.9.2342.19200300.100.1.3"!==this.subject.typesAndValues[e].type||(h=h||r(this.subject.typesAndValues[e].value.valueBlock.value,k[o].base.value));break;case 2:if(i.length>0)for(let e=0;e<i.length;e++)2===i[e].type&&(h=h||t(i[e].value,k[o].base.value));break;case 4:h=h||n(this.certs[e].subject,k[o].base.value);break;case 6:if(i.length>0)for(let e=0;e<i.length;e++)6===i[e].type&&(h=h||s(i[e].value,k[o].base.value));break;case 7:if(i.length>0)for(let e=0;e<i.length;e++)7===i[e].type&&(h=h||a(i[e].value,k[o].base.value))}if(h)break}if(!0===h)throw V.result=!1,V.resultCode=42,V.resultMessage='Failed to meet "excluded sub-trees" name constraint',V;w=w.concat(o),k=k.concat(l)}return V}catch(e){if(e instanceof Object){if("resultMessage"in e)return e;if("message"in e)return{result:!1,resultCode:-1,resultMessage:e.message}}return{result:!1,resultCode:-1,resultMessage:e}}}}class dr{constructor(e={}){this.tbsResponseData=t(e,"tbsResponseData",dr.defaultValues("tbsResponseData")),this.signatureAlgorithm=t(e,"signatureAlgorithm",dr.defaultValues("signatureAlgorithm")),this.signature=t(e,"signature",dr.defaultValues("signature")),"certs"in e&&(this.certs=t(e,"certs",dr.defaultValues("certs"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"tbsResponseData":return new mr;case"signatureAlgorithm":return new Be;case"signature":return new R;case"certs":return[];default:throw new Error(`Invalid member name for BasicOCSPResponse class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"type":{let e=mr.compareWithDefault("tbs",t.tbs)&&mr.compareWithDefault("responderID",t.responderID)&&mr.compareWithDefault("producedAt",t.producedAt)&&mr.compareWithDefault("responses",t.responses);return"responseExtensions"in t&&(e=e&&mr.compareWithDefault("responseExtensions",t.responseExtensions)),e}case"signatureAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"signature":return t.isEqual(dr.defaultValues(e));case"certs":return 0===t.length;default:throw new Error(`Invalid member name for BasicOCSPResponse class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"BasicOCSPResponse",value:[mr.schema(r.tbsResponseData||{names:{blockName:"BasicOCSPResponse.tbsResponseData"}}),Be.schema(r.signatureAlgorithm||{names:{blockName:"BasicOCSPResponse.signatureAlgorithm"}}),new R({name:r.signature||"BasicOCSPResponse.signature"}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new O({value:[new ve({name:"BasicOCSPResponse.certs",value:Ct.schema(r.certs||{})})]})]})]})}fromSchema(e){const t=Ae(e,e,dr.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OCSP_BASIC_RESPONSE");this.tbsResponseData=new mr({schema:t.result["BasicOCSPResponse.tbsResponseData"]}),this.signatureAlgorithm=new Be({schema:t.result["BasicOCSPResponse.signatureAlgorithm"]}),this.signature=t.result["BasicOCSPResponse.signature"],"BasicOCSPResponse.certs"in t.result&&(this.certs=Array.from(t.result["BasicOCSPResponse.certs"],e=>new Ct({schema:e})))}toSchema(){const e=[];return e.push(this.tbsResponseData.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),"certs"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:0},value:[new O({value:Array.from(this.certs,e=>e.toSchema())})]})),new O({value:e})}toJSON(){const e={tbsResponseData:this.tbsResponseData.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return"certs"in this&&(e.certs=Array.from(this.certs,e=>e.toJSON())),e}getCertificateStatus(e,t){let r=Promise.resolve();const s={isForCertificate:!1,status:2},a={},n=[],i=[];for(const r of this.tbsResponseData.responses){const s=We(r.certID.hashAlgorithm.algorithmId);if("name"in s==!1)return Promise.reject(`Wrong CertID hashing algorithm: ${r.certID.hashAlgorithm.algorithmId}`);if(s.name in a==!1){a[s.name]=1;const r=new ur;n.push(r),i.push(r.createForCertificate(e,{hashAlgorithm:s.name,issuerCertificate:t}))}}return r=(r=r.then(()=>Promise.all(i))).then(()=>{for(const e of this.tbsResponseData.responses)for(const t of n)if(e.certID.isEqual(t)){s.isForCertificate=!0;try{switch(e.certStatus.idBlock.isConstructed){case!0:1===e.certStatus.idBlock.tagNumber&&(s.status=1);break;case!1:switch(e.certStatus.idBlock.tagNumber){case 0:s.status=0;break;case 2:s.status=2}}}catch(e){}return s}return s})}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let r,s=Promise.resolve();const a=Ke();return s=(s=(s=(s=(s=s.then(()=>a.subtle.getSignatureParameters(e,t))).then(e=>{r=e.parameters,this.signatureAlgorithm=e.signatureAlgorithm})).then(()=>{this.tbsResponseData.tbs=this.tbsResponseData.toSchema(!0).toBER(!1)})).then(()=>a.subtle.signWithPrivateKey(this.tbsResponseData.tbs,e,r))).then(e=>{this.signature=new R({valueHex:e})})}verify(e={}){if("certs"in this==!1)return Promise.reject("No certificates attached to the BasicOCSPResponce");let t=null;const r=new Uint8Array(this.tbsResponseData.tbs);let s=-1,a=Promise.resolve(),n="",i=[];"trustedCerts"in e&&(i=e.trustedCerts);const o=Re();if(void 0===o)return Promise.reject("Unable to create WebCrypto object");if(""===(n=qe(this.signatureAlgorithm)))return Promise.reject(`Unsupported signature algorithm: ${this.signatureAlgorithm.algorithmId}`);let c=0,u={};if(this.tbsResponseData.responderID instanceof ze)c=0,u=this.tbsResponseData.responderID;else{if(!(this.tbsResponseData.responderID instanceof L))return Promise.reject("Wrong value for responderID");c=1,u=this.tbsResponseData.responderID}function h(e){if(!0===e.issuer.isEqual(t.issuer)&&!0===e.serialNumber.isEqual(t.serialNumber))return null;let r=!1;for(const t of e.extensions)"2.5.29.19"===t.extnID&&"cA"in t.parsedValue&&!0===t.parsedValue.cA&&(r=!0);return r?e:null}return a=(a=(a=(a=0===c?a.then(()=>{for(const[e,t]of this.certs.entries())if(t.subject.isEqual(u)){s=e;break}}):a.then(()=>Promise.all(Array.from(this.certs,e=>o.digest({name:"sha-1"},new Uint8Array(e.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))).then(e=>{for(const[t,r]of this.certs.entries())if(l(e[t],u.valueBlock.valueHex)){s=t;break}}))).then(()=>-1===s?Promise.reject("Correct certificate was not found in OCSP response"):(t=this.certs[s],Promise.all(Array.from(this.certs,e=>h(e))).then(e=>{const r=[];r.push(t);for(const t of e)null!==t&&r.push(t);return new fr({certs:r,trustedCerts:i}).verify().then(e=>!0===e.result?Promise.resolve():Promise.reject("Validation of signer's certificate failed"),e=>Promise.reject(`Validation of signer's certificate failed with error: ${e instanceof Object?e.resultMessage:e}`))},e=>Promise.reject(`Error during checking certificates for CA flag: ${e}`))))).then(()=>{let e;const t=We(e="1.2.840.113549.1.1.10"===this.certs[s].signatureAlgorithm.algorithmId?this.certs[s].signatureAlgorithm.algorithmId:this.certs[s].subjectPublicKeyInfo.algorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Unsupported public key algorithm: ${e}`);const r=t.name,a=$e(r,"importkey");if("hash"in a.algorithm&&(a.algorithm.hash.name=n),"ECDSA"===r){if(this.certs[s].subjectPublicKeyInfo.algorithm.algorithmParams instanceof W==!1)return Promise.reject("Incorrect type for ECDSA public key parameters");const e=We(this.certs[s].subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString());if("name"in e==!1)return Promise.reject(`Unsupported named curve algorithm: ${this.certs[s].subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);a.algorithm.namedCurve=e.name}const i=this.certs[s].subjectPublicKeyInfo.toSchema().toBER(!1),l=new Uint8Array(i);return o.importKey("spki",l,a.algorithm,!0,a.usages)})).then(e=>{const t=$e(e.algorithm.name,"verify");"hash"in t.algorithm&&(t.algorithm.hash.name=n);let s=this.signature.valueBlock.valueHex;if("ECDSA"===e.algorithm.name){s=Me(ke(s).result)}if("RSA-PSS"===e.algorithm.name){let e;try{e=new Oe({schema:this.signatureAlgorithm.algorithmParams})}catch(e){return Promise.reject(e)}t.algorithm.saltLength="saltLength"in e?e.saltLength:20;let r="SHA-1";if("hashAlgorithm"in e){const t=We(e.hashAlgorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Unrecognized hash algorithm: ${e.hashAlgorithm.algorithmId}`);r=t.name}t.algorithm.hash.name=r}return o.verify(t.algorithm,e,new Uint8Array(s),r)})}}class gr{constructor(e={}){this.digestAlgorithm=t(e,"digestAlgorithm",gr.defaultValues("digestAlgorithm")),this.digest=t(e,"digest",gr.defaultValues("digest")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"digestAlgorithm":return new Be;case"digest":return new L;default:throw new Error(`Invalid member name for DigestInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"digestAlgorithm":return Be.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case"digest":return t.isEqual(this.constructor.defaultValues(e));default:throw new Error(`Invalid member name for DigestInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Be.schema(r.digestAlgorithm||{names:{blockName:"digestAlgorithm"}}),new L({name:r.digest||"digest"})]})}fromSchema(e){const t=Ae(e,e,gr.schema({names:{digestAlgorithm:{names:{blockName:"digestAlgorithm"}},digest:"digest"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for DigestInfo");this.digestAlgorithm=new Be({schema:t.result.digestAlgorithm}),this.digest=t.result.digest}toSchema(){return new O({value:[this.digestAlgorithm.toSchema(),this.digest]})}toJSON(){return{digestAlgorithm:this.digestAlgorithm.toJSON(),digest:this.digest.toJSON()}}}class pr{constructor(e={}){if(this.eContentType=t(e,"eContentType",pr.defaultValues("eContentType")),"eContent"in e&&(this.eContent=t(e,"eContent",pr.defaultValues("eContent")),1===this.eContent.idBlock.tagClass&&4===this.eContent.idBlock.tagNumber&&!1===this.eContent.idBlock.isConstructed)){const e=new L({idBlock:{isConstructed:!0},isConstructed:!0});let t=0,r=this.eContent.valueBlock.valueHex.byteLength;for(;r>0;){const s=new Uint8Array(this.eContent.valueBlock.valueHex,t,t+65536>this.eContent.valueBlock.valueHex.byteLength?this.eContent.valueBlock.valueHex.byteLength-t:65536),a=new ArrayBuffer(s.length),n=new Uint8Array(a);for(let e=0;e<n.length;e++)n[e]=s[e];e.valueBlock.value.push(new L({valueHex:a})),r-=s.length,t+=s.length}this.eContent=e}"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"eContentType":return"";case"eContent":return new L;default:throw new Error(`Invalid member name for EncapsulatedContentInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"eContentType":return""===t;case"eContent":return 1===t.idBlock.tagClass&&4===t.idBlock.tagNumber&&t.isEqual(pr.defaultValues("eContent"));default:throw new Error(`Invalid member name for EncapsulatedContentInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.eContentType||""}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ye({name:r.eContent||""})]})]})}fromSchema(e){const t=Ae(e,e,pr.schema({names:{eContentType:"eContentType",eContent:"eContent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EncapsulatedContentInfo");this.eContentType=t.result.eContentType.valueBlock.toString(),"eContent"in t.result&&(this.eContent=t.result.eContent)}toSchema(){const e=[];return e.push(new W({value:this.eContentType})),"eContent"in this&&!1===pr.compareWithDefault("eContent",this.eContent)&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.eContent]})),new O({value:e})}toJSON(){const e={eContentType:this.eContentType};return"eContent"in this&&!1===pr.compareWithDefault("eContent",this.eContent)&&(e.eContent=this.eContent.toJSON()),e}}class yr{constructor(e={}){this.mac=t(e,"mac",yr.defaultValues("mac")),this.macSalt=t(e,"macSalt",yr.defaultValues("macSalt")),"iterations"in e&&(this.iterations=t(e,"iterations",yr.defaultValues("iterations"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"mac":return new gr;case"macSalt":return new L;case"iterations":return 1;default:throw new Error(`Invalid member name for MacData class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"mac":return gr.compareWithDefault("digestAlgorithm",t.digestAlgorithm)&&gr.compareWithDefault("digest",t.digest);case"macSalt":return t.isEqual(yr.defaultValues(e));case"iterations":return t===yr.defaultValues(e);default:throw new Error(`Invalid member name for MacData class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",optional:r.optional||!0,value:[gr.schema(r.mac||{names:{blockName:"mac"}}),new L({name:r.macSalt||"macSalt"}),new J({optional:!0,name:r.iterations||"iterations"})]})}fromSchema(e){const t=Ae(e,e,yr.schema({names:{mac:{names:{blockName:"mac"}},macSalt:"macSalt",iterations:"iterations"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for MacData");this.mac=new gr({schema:t.result.mac}),this.macSalt=t.result.macSalt,"iterations"in t.result&&(this.iterations=t.result.iterations.valueBlock.valueDec)}toSchema(){const e=[this.mac.toSchema(),this.macSalt];return"iterations"in this&&e.push(new J({value:this.iterations})),new O({value:e})}toJSON(){const e={mac:this.mac.toJSON(),macSalt:this.macSalt.toJSON()};return"iterations"in this&&(e.iterations=this.iterations.toJSON()),e}}class vr{constructor(e={}){this.hashAlgorithm=t(e,"hashAlgorithm",vr.defaultValues("hashAlgorithm")),this.hashedMessage=t(e,"hashedMessage",vr.defaultValues("hashedMessage")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new Be;case"hashedMessage":return new L;default:throw new Error(`Invalid member name for MessageImprint class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"hashAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"hashedMessage":return 0===t.isEqual(vr.defaultValues(e));default:throw new Error(`Invalid member name for MessageImprint class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[Be.schema(r.hashAlgorithm||{}),new L({name:r.hashedMessage||""})]})}fromSchema(e){const t=Ae(e,e,vr.schema({names:{hashAlgorithm:{names:{blockName:"hashAlgorithm"}},hashedMessage:"hashedMessage"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for MessageImprint");this.hashAlgorithm=new Be({schema:t.result.hashAlgorithm}),this.hashedMessage=t.result.hashedMessage}toSchema(){return new O({value:[this.hashAlgorithm.toSchema(),this.hashedMessage]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),hashedMessage:this.hashedMessage.toJSON()}}}class br{constructor(e={}){this.otherCertFormat=t(e,"otherCertFormat",br.defaultValues("otherCertFormat")),this.otherCert=t(e,"otherCert",br.defaultValues("otherCert")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"otherCertFormat":return"";case"otherCert":return new ye;default:throw new Error(`Invalid member name for OtherCertificateFormat class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new W({name:r.otherCertFormat||"otherCertFormat"}),new ye({name:r.otherCert||"otherCert"})]})}fromSchema(e){const t=Ae(e,e,br.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherCertificateFormat");this.otherCertFormat=t.result.otherCertFormat.valueBlock.toString(),this.otherCert=t.result.otherCert}toSchema(){return new O({value:[new W({value:this.otherCertFormat}),this.otherCert]})}toJSON(){const e={otherCertFormat:this.otherCertFormat};return this.otherCert instanceof ye||(e.otherCert=this.otherCert.toJSON()),e}}class wr{constructor(e={}){this.type=t(e,"type",wr.defaultValues("type")),this.attributes=t(e,"attributes",wr.defaultValues("attributes")),this.encodedValue=t(e,"encodedValue",wr.defaultValues("encodedValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return-1;case"attributes":return[];case"encodedValue":return new ArrayBuffer(0);default:throw new Error(`Invalid member name for SignedAndUnsignedAttributes class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"type":return t===wr.defaultValues("type");case"attributes":return 0===t.length;case"encodedValue":return 0===t.byteLength;default:throw new Error(`Invalid member name for SignedAndUnsignedAttributes class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new E({name:r.blockName||"",optional:!0,idBlock:{tagClass:3,tagNumber:r.tagNumber},value:[new ve({name:r.attributes||"",value:Ne.schema()})]})}fromSchema(e){const t=Ae(e,e,wr.schema({names:{tagNumber:this.type,attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SignedUnsignedAttributes");this.type=t.result.idBlock.tagNumber,this.encodedValue=t.result.valueBeforeDecode;const r=new Uint8Array(this.encodedValue);if(r[0]=49,"attributes"in t.result!=!1)this.attributes=Array.from(t.result.attributes,e=>new Ne({schema:e}));else if(0===this.type)throw new Error("Wrong structure of SignedUnsignedAttributes")}toSchema(){if(wr.compareWithDefault("type",this.type)||wr.compareWithDefault("attributes",this.attributes))throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return new E({optional:!0,idBlock:{tagClass:3,tagNumber:this.type},value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){if(wr.compareWithDefault("type",this.type)||wr.compareWithDefault("attributes",this.attributes))throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return{type:this.type,attributes:Array.from(this.attributes,e=>e.toJSON())}}}class kr{constructor(e={}){this.version=t(e,"version",kr.defaultValues("version")),this.sid=t(e,"sid",kr.defaultValues("sid")),this.digestAlgorithm=t(e,"digestAlgorithm",kr.defaultValues("digestAlgorithm")),"signedAttrs"in e&&(this.signedAttrs=t(e,"signedAttrs",kr.defaultValues("signedAttrs"))),this.signatureAlgorithm=t(e,"signatureAlgorithm",kr.defaultValues("signatureAlgorithm")),this.signature=t(e,"signature",kr.defaultValues("signature")),"unsignedAttrs"in e&&(this.unsignedAttrs=t(e,"unsignedAttrs",kr.defaultValues("unsignedAttrs"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"sid":return new ye;case"digestAlgorithm":return new Be;case"signedAttrs":return new wr({type:0});case"signatureAlgorithm":return new Be;case"signature":return new L;case"unsignedAttrs":return new wr({type:1});default:throw new Error(`Invalid member name for SignerInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return kr.defaultValues("version")===t;case"sid":return t instanceof ye;case"digestAlgorithm":return t instanceof Be!=!1&&t.isEqual(kr.defaultValues("digestAlgorithm"));case"signedAttrs":return wr.compareWithDefault("type",t.type)&&wr.compareWithDefault("attributes",t.attributes)&&wr.compareWithDefault("encodedValue",t.encodedValue);case"signatureAlgorithm":return t instanceof Be!=!1&&t.isEqual(kr.defaultValues("signatureAlgorithm"));case"signature":case"unsignedAttrs":return wr.compareWithDefault("type",t.type)&&wr.compareWithDefault("attributes",t.attributes)&&wr.compareWithDefault("encodedValue",t.encodedValue);default:throw new Error(`Invalid member name for SignerInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:"SignerInfo",value:[new J({name:r.version||"SignerInfo.version"}),new pe({value:[Mt.schema(r.sid||{names:{blockName:"SignerInfo.sid"}}),new E({optional:!0,name:r.sid||"SignerInfo.sid",idBlock:{tagClass:3,tagNumber:0},value:[new L]})]}),Be.schema(r.digestAlgorithm||{names:{blockName:"SignerInfo.digestAlgorithm"}}),wr.schema(r.signedAttrs||{names:{blockName:"SignerInfo.signedAttrs",tagNumber:0}}),Be.schema(r.signatureAlgorithm||{names:{blockName:"SignerInfo.signatureAlgorithm"}}),new L({name:r.signature||"SignerInfo.signature"}),wr.schema(r.unsignedAttrs||{names:{blockName:"SignerInfo.unsignedAttrs",tagNumber:1}})]})}fromSchema(e){const t=Ae(e,e,kr.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CMS_SIGNER_INFO");this.version=t.result["SignerInfo.version"].valueBlock.valueDec;const r=t.result["SignerInfo.sid"];1===r.idBlock.tagClass?this.sid=new Mt({schema:r}):this.sid=r,this.digestAlgorithm=new Be({schema:t.result["SignerInfo.digestAlgorithm"]}),"SignerInfo.signedAttrs"in t.result&&(this.signedAttrs=new wr({type:0,schema:t.result["SignerInfo.signedAttrs"]})),this.signatureAlgorithm=new Be({schema:t.result["SignerInfo.signatureAlgorithm"]}),this.signature=t.result["SignerInfo.signature"],"SignerInfo.unsignedAttrs"in t.result&&(this.unsignedAttrs=new wr({type:1,schema:t.result["SignerInfo.unsignedAttrs"]}))}toSchema(){if(kr.compareWithDefault("sid",this.sid))throw new Error('Incorrectly initialized "SignerInfo" class');const e=[];return e.push(new J({value:this.version})),this.sid instanceof Mt?e.push(this.sid.toSchema()):e.push(this.sid),e.push(this.digestAlgorithm.toSchema()),"signedAttrs"in this&&!1===kr.compareWithDefault("signedAttrs",this.signedAttrs)&&e.push(this.signedAttrs.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),"unsignedAttrs"in this&&!1===kr.compareWithDefault("unsignedAttrs",this.unsignedAttrs)&&e.push(this.unsignedAttrs.toSchema()),new O({value:e})}toJSON(){if(kr.compareWithDefault("sid",this.sid))throw new Error('Incorrectly initialized "SignerInfo" class');const e={version:this.version};return this.sid instanceof ye||(e.sid=this.sid.toJSON()),e.digestAlgorithm=this.digestAlgorithm.toJSON(),!1===kr.compareWithDefault("signedAttrs",this.signedAttrs)&&(e.signedAttrs=this.signedAttrs.toJSON()),e.signatureAlgorithm=this.signatureAlgorithm.toJSON(),e.signature=this.signature.toJSON(),!1===kr.compareWithDefault("unsignedAttrs",this.unsignedAttrs)&&(e.unsignedAttrs=this.unsignedAttrs.toJSON()),e}}class Ar{constructor(e={}){this.version=t(e,"version",Ar.defaultValues("version")),this.policy=t(e,"policy",Ar.defaultValues("policy")),this.messageImprint=t(e,"messageImprint",Ar.defaultValues("messageImprint")),this.serialNumber=t(e,"serialNumber",Ar.defaultValues("serialNumber")),this.genTime=t(e,"genTime",Ar.defaultValues("genTime")),"accuracy"in e&&(this.accuracy=t(e,"accuracy",Ar.defaultValues("accuracy"))),"ordering"in e&&(this.ordering=t(e,"ordering",Ar.defaultValues("ordering"))),"nonce"in e&&(this.nonce=t(e,"nonce",Ar.defaultValues("nonce"))),"tsa"in e&&(this.tsa=t(e,"tsa",Ar.defaultValues("tsa"))),"extensions"in e&&(this.extensions=t(e,"extensions",Ar.defaultValues("extensions"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"policy":return"";case"messageImprint":return new vr;case"serialNumber":return new J;case"genTime":return new Date(0,0,0);case"accuracy":return new Xe;case"ordering":return!1;case"nonce":return new J;case"tsa":return new Ze;case"extensions":return[];default:throw new Error(`Invalid member name for TSTInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":case"policy":case"genTime":case"ordering":return t===Ar.defaultValues(e);case"messageImprint":return vr.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&vr.compareWithDefault("hashedMessage",t.hashedMessage);case"serialNumber":case"nonce":return t.isEqual(Ar.defaultValues(e));case"accuracy":return Xe.compareWithDefault("seconds",t.seconds)&&Xe.compareWithDefault("millis",t.millis)&&Xe.compareWithDefault("micros",t.micros);case"tsa":return Ze.compareWithDefault("type",t.type)&&Ze.compareWithDefault("value",t.value);case"extensions":return 0===t.length;default:throw new Error(`Invalid member name for TSTInfo class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"TSTInfo",value:[new J({name:r.version||"TSTInfo.version"}),new W({name:r.policy||"TSTInfo.policy"}),vr.schema(r.messageImprint||{names:{blockName:"TSTInfo.messageImprint"}}),new J({name:r.serialNumber||"TSTInfo.serialNumber"}),new ue({name:r.genTime||"TSTInfo.genTime"}),Xe.schema(r.accuracy||{names:{blockName:"TSTInfo.accuracy"}}),new V({name:r.ordering||"TSTInfo.ordering",optional:!0}),new J({name:r.nonce||"TSTInfo.nonce",optional:!0}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[Ze.schema(r.tsa||{names:{blockName:"TSTInfo.tsa"}})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ve({name:r.extensions||"TSTInfo.extensions",value:Bt.schema(r.extension||{})})]})]})}fromSchema(e){const t=Ae(e,e,Ar.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for TST_INFO");this.version=t.result["TSTInfo.version"].valueBlock.valueDec,this.policy=t.result["TSTInfo.policy"].valueBlock.toString(),this.messageImprint=new vr({schema:t.result["TSTInfo.messageImprint"]}),this.serialNumber=t.result["TSTInfo.serialNumber"],this.genTime=t.result["TSTInfo.genTime"].toDate(),"TSTInfo.accuracy"in t.result&&(this.accuracy=new Xe({schema:t.result["TSTInfo.accuracy"]})),"TSTInfo.ordering"in t.result&&(this.ordering=t.result["TSTInfo.ordering"].valueBlock.value),"TSTInfo.nonce"in t.result&&(this.nonce=t.result["TSTInfo.nonce"]),"TSTInfo.tsa"in t.result&&(this.tsa=new Ze({schema:t.result["TSTInfo.tsa"]})),"TSTInfo.extensions"in t.result&&(this.extensions=Array.from(t.result["TSTInfo.extensions"],e=>new Bt({schema:e})))}toSchema(){const e=[];return e.push(new J({value:this.version})),e.push(new W({value:this.policy})),e.push(this.messageImprint.toSchema()),e.push(this.serialNumber),e.push(new ue({valueDate:this.genTime})),"accuracy"in this&&e.push(this.accuracy.toSchema()),"ordering"in this&&e.push(new V({value:this.ordering})),"nonce"in this&&e.push(this.nonce),"tsa"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.tsa.toSchema()]})),"extensions"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.extensions,e=>e.toSchema())})),new O({value:e})}toJSON(){const e={version:this.version,policy:this.policy,messageImprint:this.messageImprint.toJSON(),serialNumber:this.serialNumber.toJSON(),genTime:this.genTime};return"accuracy"in this&&(e.accuracy=this.accuracy.toJSON()),"ordering"in this&&(e.ordering=this.ordering),"nonce"in this&&(e.nonce=this.nonce.toJSON()),"tsa"in this&&(e.tsa=this.tsa.toJSON()),"extensions"in this&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}verify(e={}){let t,r,s,a=Promise.resolve();const n=Re();if(void 0===n)return Promise.reject("Unable to create WebCrypto object");if(!("data"in e))return Promise.reject('"data" is a mandatory attribute for TST_INFO verification');t=e.data,"notBefore"in e&&(r=e.notBefore),"notAfter"in e&&(s=e.notAfter);const i=We(this.messageImprint.hashAlgorithm.algorithmId);return"name"in i==!1?Promise.reject(`Unsupported signature algorithm: ${this.messageImprint.hashAlgorithm.algorithmId}`):a=a.then(()=>n.digest(i.name,new Uint8Array(t))).then(e=>l(e,this.messageImprint.hashedMessage.valueBlock.valueHex))}}class Br{constructor(e={}){this.version={},this.holder={},this.issuer={},this.signature={},this.serialNumber={},this.attrCertValidityPeriod={},this.attributes={},this.issuerUniqueID={},this.extensions={}}fromSchema(e){}toSchema(){return new ye}toJSON(){return{}}}class Sr{constructor(e={}){this.version=t(e,"version",Sr.defaultValues("version")),this.digestAlgorithms=t(e,"digestAlgorithms",Sr.defaultValues("digestAlgorithms")),this.encapContentInfo=t(e,"encapContentInfo",Sr.defaultValues("encapContentInfo")),"certificates"in e&&(this.certificates=t(e,"certificates",Sr.defaultValues("certificates"))),"crls"in e&&(this.crls=t(e,"crls",Sr.defaultValues("crls"))),this.signerInfos=t(e,"signerInfos",Sr.defaultValues("signerInfos")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"digestAlgorithms":return[];case"encapContentInfo":return new pr;case"certificates":case"crls":case"signerInfos":return[];default:throw new Error(`Invalid member name for SignedData class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return t===Sr.defaultValues("version");case"encapContentInfo":return new pr;case"digestAlgorithms":case"certificates":case"crls":case"signerInfos":return 0===t.length;default:throw new Error(`Invalid member name for SignedData class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return"optional"in r==!1&&(r.optional=!1),new O({name:r.blockName||"SignedData",optional:r.optional,value:[new J({name:r.version||"SignedData.version"}),new j({value:[new ve({name:r.digestAlgorithms||"SignedData.digestAlgorithms",value:Be.schema()})]}),pr.schema(r.encapContentInfo||{names:{blockName:"SignedData.encapContentInfo"}}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Tt.schema(r.certificates||{names:{certificates:"SignedData.certificates"}}).valueBlock.value}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:$t.schema(r.crls||{names:{crls:"SignedData.crls"}}).valueBlock.value}),new j({value:[new ve({name:r.signerInfos||"SignedData.signerInfos",value:kr.schema()})]})]})}fromSchema(e){const t=Ae(e,e,Sr.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SignedData");this.version=t.result["SignedData.version"].valueBlock.valueDec,"SignedData.digestAlgorithms"in t.result&&(this.digestAlgorithms=Array.from(t.result["SignedData.digestAlgorithms"],e=>new Be({schema:e}))),this.encapContentInfo=new pr({schema:t.result["SignedData.encapContentInfo"]}),"SignedData.certificates"in t.result&&(this.certificates=Array.from(t.result["SignedData.certificates"],e=>{switch(e.idBlock.tagClass){case 1:return new Ct({schema:e});case 3:{const t=e.idBlock.tagNumber;switch(e.idBlock.tagClass=1,e.idBlock.tagNumber=16,t){case 0:break;case 1:return new Vt({schema:e});case 2:return new Br({schema:e});case 3:return new br({schema:e});default:throw new Error("Object's schema was not verified against input data for SignedData")}}break;default:throw new Error("Object's schema was not verified against input data for SignedData")}return new Ct})),"SignedData.crls"in t.result&&(this.crls=Array.from(t.result["SignedData.crls"],e=>1===e.idBlock.tagClass?new Ht({schema:e}):(e.idBlock.tagClass=1,e.idBlock.tagNumber=16,new Jt({schema:e})))),"SignedData.signerInfos"in t.result&&(this.signerInfos=Array.from(t.result["SignedData.signerInfos"],e=>new kr({schema:e})))}toSchema(e=!1){const t=[];return t.push(new J({value:this.version})),t.push(new j({value:Array.from(this.digestAlgorithms,t=>t.toSchema(e))})),t.push(this.encapContentInfo.toSchema()),"certificates"in this&&t.push(new E({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.certificates,t=>{if(t instanceof br){const r=t.toSchema(e);return r.idBlock.tagClass=3,r.idBlock.tagNumber=3,r}return t.toSchema(e)})})),"crls"in this&&t.push(new E({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.crls,t=>{if(t instanceof Jt){const r=t.toSchema(e);return r.idBlock.tagClass=3,r.idBlock.tagNumber=1,r}return t.toSchema(e)})})),t.push(new j({value:Array.from(this.signerInfos,t=>t.toSchema(e))})),new O({value:t})}toJSON(){const e={version:this.version,digestAlgorithms:Array.from(this.digestAlgorithms,e=>e.toJSON()),encapContentInfo:this.encapContentInfo.toJSON()};return"certificates"in this&&(e.certificates=Array.from(this.certificates,e=>e.toJSON())),"crls"in this&&(e.crls=Array.from(this.crls,e=>e.toJSON())),e.signerInfos=Array.from(this.signerInfos,e=>e.toJSON()),e}verify({signer:e=-1,data:t=new ArrayBuffer(0),trustedCerts:r=[],checkDate:s=new Date,checkChain:a=!1,includeSignerCertificate:n=!1,extendedMode:o=!1,findOrigin:c=null,findIssuer:u=null}={}){let h,m=Promise.resolve(),f=new ArrayBuffer(0),d="",g={},p=null,y=[];const v=Re();if(void 0===v)return Promise.reject("Unable to create WebCrypto object");if(-1===e)return o?Promise.reject({date:s,code:1,message:"Unable to get signer index from input parameters",signatureVerified:null,signerCertificate:null,signerCertificateVerified:null}):Promise.reject("Unable to get signer index from input parameters");if("certificates"in this==!1)return o?Promise.reject({date:s,code:2,message:"No certificates attached to this signed data",signatureVerified:null,signerCertificate:null,signerCertificateVerified:null}):Promise.reject("No certificates attached to this signed data");m=(m=this.signerInfos[e].sid instanceof Mt?m.then(()=>{for(const t of this.certificates)if(t instanceof Ct!=!1&&t.issuer.isEqual(this.signerInfos[e].sid.issuer)&&t.serialNumber.isEqual(this.signerInfos[e].sid.serialNumber))return g=t,Promise.resolve();return o?Promise.reject({date:s,code:3,message:"Unable to find signer certificate",signatureVerified:null,signerCertificate:null,signerCertificateVerified:null}):Promise.reject("Unable to find signer certificate")}):m.then(()=>Promise.all(Array.from(this.certificates.filter(e=>e instanceof Ct),e=>v.digest({name:"sha-1"},new Uint8Array(e.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))).then(t=>{for(const[r,s]of this.certificates.entries())if(s instanceof Ct!=!1&&l(t[r],this.signerInfos[e].sid.valueBlock.valueHex))return g=s,Promise.resolve();return o?Promise.reject({date:s,code:3,message:"Unable to find signer certificate",signatureVerified:null,signerCertificate:null,signerCertificateVerified:null}):Promise.reject("Unable to find signer certificate")},()=>o?Promise.reject({date:s,code:3,message:"Unable to find signer certificate",signatureVerified:null,signerCertificate:null,signerCertificateVerified:null}):Promise.reject("Unable to find signer certificate")))).then(()=>{if("1.2.840.113549.1.9.16.1.4"===this.encapContentInfo.eContentType){if("eContent"in this.encapContentInfo==!1)return!1;const e=ke(this.encapContentInfo.eContent.valueBlock.valueHex);let r;try{r=new Ar({schema:e.result})}catch(e){return!1}return s=r.genTime,p=r.serialNumber.valueBlock.valueHex,0===t.byteLength?o?Promise.reject({date:s,code:4,message:"Missed detached data input array",signatureVerified:null,signerCertificate:g,signerCertificateVerified:null}):Promise.reject("Missed detached data input array"):r.verify({data:t})}return!0});function b(e){if(!0===e.issuer.isEqual(g.issuer)&&!0===e.serialNumber.isEqual(g.serialNumber))return null;let t=!1;if("extensions"in e)for(const r of e.extensions)"2.5.29.19"===r.extnID&&"cA"in r.parsedValue&&!0===r.parsedValue.cA&&(t=!0);return t?e:null}return a&&(m=m.then(e=>{if(!1===e)return!1;const t=Array.from(this.certificates.filter(e=>e instanceof Ct),e=>b(e)),a={checkDate:s,certs:Array.from(t.filter(e=>null!==e)),trustedCerts:r};null!==u&&(a.findIssuer=u),null!==c&&(a.findOrigin=c);const n=new fr(a);if(n.certs.push(g),"crls"in this)for(const e of this.crls)e instanceof Ht?n.crls.push(e):"1.3.6.1.5.5.7.48.1.1"===e.otherRevInfoFormat&&n.ocsps.push(new dr({schema:e.otherRevInfo}));return"ocsps"in this&&n.ocsps.push(...this.ocsps),n.verify().then(e=>("certificatePath"in e&&(y=e.certificatePath),!0===e.result?Promise.resolve(!0):o?Promise.reject({date:s,code:5,message:`Validation of signer's certificate failed: ${e.resultMessage}`,signatureVerified:null,signerCertificate:g,signerCertificateVerified:!1}):Promise.reject("Validation of signer's certificate failed")),e=>o?Promise.reject({date:s,code:5,message:`Validation of signer's certificate failed with error: ${e instanceof Object?e.resultMessage:e}`,signatureVerified:null,signerCertificate:g,signerCertificateVerified:!1}):Promise.reject(`Validation of signer's certificate failed with error: ${e instanceof Object?e.resultMessage:e}`))})),m=(m=(m=(m=(m=m.then(t=>{if(!1===t)return!1;const r=We(this.signerInfos[e].digestAlgorithm.algorithmId);return"name"in r==!1?o?Promise.reject({date:s,code:7,message:`Unsupported signature algorithm: ${this.signerInfos[e].digestAlgorithm.algorithmId}`,signatureVerified:null,signerCertificate:g,signerCertificateVerified:!0}):Promise.reject(`Unsupported signature algorithm: ${this.signerInfos[e].digestAlgorithm.algorithmId}`):(d=r.name,!0)})).then(r=>{if(!1===r)return!1;if("eContent"in this.encapContentInfo)if(1===this.encapContentInfo.eContent.idBlock.tagClass&&4===this.encapContentInfo.eContent.idBlock.tagNumber)if(!1===this.encapContentInfo.eContent.idBlock.isConstructed)t=this.encapContentInfo.eContent.valueBlock.valueHex;else for(const e of this.encapContentInfo.eContent.valueBlock.value)t=i(t,e.valueBlock.valueHex);else t=this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;else if(0===t.byteLength)return o?Promise.reject({date:s,code:8,message:"Missed detached data input array",signatureVerified:null,signerCertificate:g,signerCertificateVerified:!0}):Promise.reject("Missed detached data input array");if("signedAttrs"in this.signerInfos[e]){let t=!1,r=!1;for(const s of this.signerInfos[e].signedAttrs.attributes)if("1.2.840.113549.1.9.3"===s.type&&(t=!0),"1.2.840.113549.1.9.4"===s.type&&(r=!0,f=s.values[0].valueBlock.valueHex),t&&r)break;if(!1===t)return o?Promise.reject({date:s,code:9,message:'Attribute "content-type" is a mandatory attribute for "signed attributes"',signatureVerified:null,signerCertificate:g,signerCertificateVerified:!0}):Promise.reject('Attribute "content-type" is a mandatory attribute for "signed attributes"');if(!1===r)return o?Promise.reject({date:s,code:10,message:'Attribute "message-digest" is a mandatory attribute for "signed attributes"',signatureVerified:null,signerCertificate:g,signerCertificateVerified:!0}):Promise.reject('Attribute "message-digest" is a mandatory attribute for "signed attributes"')}return!0})).then(e=>{if(!1===e)return!1;let t;const r=We(t="1.2.840.113549.1.1.10"===g.signatureAlgorithm.algorithmId?g.signatureAlgorithm.algorithmId:g.subjectPublicKeyInfo.algorithm.algorithmId);if("name"in r==!1)return o?Promise.reject({date:s,code:11,message:`Unsupported public key algorithm: ${t}`,signatureVerified:null,signerCertificate:g,signerCertificateVerified:!0}):Promise.reject(`Unsupported public key algorithm: ${t}`);const a=$e(r.name,"importkey");if("hash"in a.algorithm&&(a.algorithm.hash.name=d),"ECDSA"===r.name){let e=!1;if("algorithmParams"in g.subjectPublicKeyInfo.algorithm==!0&&"idBlock"in g.subjectPublicKeyInfo.algorithm.algorithmParams&&1===g.subjectPublicKeyInfo.algorithm.algorithmParams.idBlock.tagClass&&6===g.subjectPublicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)return Promise.reject("Incorrect type for ECDSA public key parameters");const t=We(g.subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString());if("name"in t==!1)return Promise.reject(`Unsupported named curve algorithm: ${g.subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);a.algorithm.namedCurve=t.name}const n=g.subjectPublicKeyInfo.toSchema().toBER(!1),i=new Uint8Array(n);return v.importKey("spki",i,a.algorithm,!0,a.usages)})).then(r=>"boolean"!=typeof r&&(h=r,!("signedAttrs"in this.signerInfos[e])||v.digest(d,new Uint8Array(t)))).then(r=>!1!==r&&(!("signedAttrs"in this.signerInfos[e])||!!l(r,f)&&(t=this.signerInfos[e].signedAttrs.encodedValue,!0))).then(r=>{if(!1===r)return!1;const a=$e(h.algorithm.name,"verify");if("hash"in a.algorithm&&(a.algorithm.hash.name=d),"RSA-PSS"===h.algorithm.name){let t;try{t=new Oe({schema:this.signerInfos[e].signatureAlgorithm.algorithmParams})}catch(e){return o?Promise.reject({date:s,code:12,message:e,signatureVerified:null,signerCertificate:g,signerCertificateVerified:!0}):Promise.reject(e)}a.algorithm.saltLength="saltLength"in t?t.saltLength:20;let r="SHA-1";if("hashAlgorithm"in t){const e=We(t.hashAlgorithm.algorithmId);if("name"in e==!1)return o?Promise.reject({date:s,code:13,message:`Unrecognized hash algorithm: ${t.hashAlgorithm.algorithmId}`,signatureVerified:null,signerCertificate:g,signerCertificateVerified:!0}):Promise.reject(`Unrecognized hash algorithm: ${t.hashAlgorithm.algorithmId}`);r=e.name}a.algorithm.hash.name=r}let n=this.signerInfos[e].signature.valueBlock.valueHex;if("ECDSA"===h.algorithm.name){n=Me(ke(n).result)}return v.verify(a.algorithm,h,new Uint8Array(n),new Uint8Array(t))})).then(e=>o?{date:s,code:14,message:"",signatureVerified:e,signerCertificate:g,timestampSerial:p,signerCertificateVerified:!0,certificatePath:y}:e,e=>o?"code"in e?Promise.reject(e):Promise.reject({date:s,code:15,message:`Error during verification: ${e.message}`,signatureVerified:null,signerCertificate:g,timestampSerial:p,signerCertificateVerified:!0}):Promise.reject(e))}sign(e,t,r="SHA-1",s=new ArrayBuffer(0)){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let a,n=Promise.resolve();const o=Ke(),l=Je({name:r});return""===l?Promise.reject(`Unsupported hash algorithm: ${r}`):(0===this.digestAlgorithms.filter(e=>e.algorithmId===l).length&&this.digestAlgorithms.push(new Be({algorithmId:l,algorithmParams:new H})),this.signerInfos[t].digestAlgorithm=new Be({algorithmId:l,algorithmParams:new H}),n=(n=(n=(n=(n=n.then(()=>o.subtle.getSignatureParameters(e,r))).then(e=>{a=e.parameters,this.signerInfos[t].signatureAlgorithm=e.signatureAlgorithm})).then(()=>{if("signedAttrs"in this.signerInfos[t])if(0!==this.signerInfos[t].signedAttrs.encodedValue.byteLength)s=this.signerInfos[t].signedAttrs.encodedValue;else{s=this.signerInfos[t].signedAttrs.toSchema(!0).toBER(!1);new Uint8Array(s)[0]=49}else if("eContent"in this.encapContentInfo)if(1===this.encapContentInfo.eContent.idBlock.tagClass&&4===this.encapContentInfo.eContent.idBlock.tagNumber)if(!1===this.encapContentInfo.eContent.idBlock.isConstructed)s=this.encapContentInfo.eContent.valueBlock.valueHex;else for(const e of this.encapContentInfo.eContent.valueBlock.value)s=i(s,e.valueBlock.valueHex);else s=this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;else if(0===s.byteLength)return Promise.reject("Missed detached data input array");return Promise.resolve()})).then(()=>o.subtle.signWithPrivateKey(s,e,a))).then(e=>(this.signerInfos[t].signature=new L({valueHex:e}),e)))}}class Cr{constructor(e={}){this.version=t(e,"version",Cr.defaultValues("version")),this.authSafe=t(e,"authSafe",Cr.defaultValues("authSafe")),"macData"in e&&(this.macData=t(e,"macData",Cr.defaultValues("macData"))),"parsedValue"in e&&(this.parsedValue=t(e,"parsedValue",Cr.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 3;case"authSafe":return new tt;case"macData":return new yr;case"parsedValue":return{};default:throw new Error(`Invalid member name for PFX class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return t===Cr.defaultValues(e);case"authSafe":return tt.compareWithDefault("contentType",t.contentType)&&tt.compareWithDefault("content",t.content);case"macData":return yr.compareWithDefault("mac",t.mac)&&yr.compareWithDefault("macSalt",t.macSalt)&&yr.compareWithDefault("iterations",t.iterations);case"parsedValue":return t instanceof Object&&0===Object.keys(t).length;default:throw new Error(`Invalid member name for PFX class: ${e}`)}}static schema(e={}){const r=t(e,"names",{});return new O({name:r.blockName||"",value:[new J({name:r.version||"version"}),tt.schema(r.authSafe||{names:{blockName:"authSafe"}}),yr.schema(r.macData||{names:{blockName:"macData",optional:!0}})]})}fromSchema(e){const t=Ae(e,e,Cr.schema({names:{version:"version",authSafe:{names:{blockName:"authSafe"}},macData:{names:{blockName:"macData"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PFX");this.version=t.result.version.valueBlock.valueDec,this.authSafe=new tt({schema:t.result.authSafe}),"macData"in t.result&&(this.macData=new yr({schema:t.result.macData}))}toSchema(){const e=[new J({value:this.version}),this.authSafe.toSchema()];return"macData"in this&&e.push(this.macData.toSchema()),new O({value:e})}toJSON(){const e={version:this.version,authSafe:this.authSafe.toJSON()};return"macData"in this&&(e.macData=this.macData.toJSON()),e}makeInternalValues(e={}){if(e instanceof Object==!1)return Promise.reject('The "parameters" must has "Object" type');if("parsedValue"in this==!1)return Promise.reject('Please call "parseValues" function first in order to make "parsedValue" data');if("integrityMode"in this.parsedValue==!1)return Promise.reject('Absent mandatory parameter "integrityMode" inside "parsedValue"');let t=Promise.resolve();const r=Re();if(void 0===r)return Promise.reject("Unable to create WebCrypto object");if("authenticatedSafe"in this.parsedValue==!1)return Promise.reject('Absent mandatory parameter "authenticatedSafe" in "parsedValue"');switch(this.parsedValue.integrityMode){case 0:{if("iterations"in e==!1)return Promise.reject('Absent mandatory parameter "iterations"');if("pbkdf2HashAlgorithm"in e==!1)return Promise.reject('Absent mandatory parameter "pbkdf2HashAlgorithm"');if("hmacHashAlgorithm"in e==!1)return Promise.reject('Absent mandatory parameter "hmacHashAlgorithm"');if("password"in e==!1)return Promise.reject('Absent mandatory parameter "password"');const r=new ArrayBuffer(64);Te(new Uint8Array(r));const s=this.parsedValue.authenticatedSafe.toSchema().toBER(!1);this.authSafe=new tt({contentType:"1.2.840.113549.1.7.1",content:new L({valueHex:s})});const a=Ke();if("stampDataWithPassword"in a.subtle==!1)return Promise.reject(`No support for "stampDataWithPassword" in current engine "${a.name}"`);t=(t=t.then(()=>a.subtle.stampDataWithPassword({password:e.password,hashAlgorithm:e.hmacHashAlgorithm,salt:r,iterationCount:e.iterations,contentToStamp:s}))).then(t=>{this.macData=new yr({mac:new gr({digestAlgorithm:new Be({algorithmId:Je({name:e.hmacHashAlgorithm})}),digest:new L({valueHex:t})}),macSalt:new L({valueHex:r}),iterations:e.iterations})},e=>Promise.reject(e))}break;case 1:{if("signingCertificate"in e==!1)return Promise.reject('Absent mandatory parameter "signingCertificate"');if("privateKey"in e==!1)return Promise.reject('Absent mandatory parameter "privateKey"');if("hashAlgorithm"in e==!1)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');const s=this.parsedValue.authenticatedSafe.toSchema().toBER(!1),a=new Sr({version:1,encapContentInfo:new pr({eContentType:"1.2.840.113549.1.7.1",eContent:new L({valueHex:s})}),certificates:[e.signingCertificate]});t=(t=(t=(t=t.then(()=>r.digest({name:e.hashAlgorithm},new Uint8Array(s)))).then(t=>{const r=[];r.push(new Ne({type:"1.2.840.113549.1.9.3",values:[new W({value:"1.2.840.113549.1.7.1"})]})),r.push(new Ne({type:"1.2.840.113549.1.9.5",values:[new ce({valueDate:new Date})]})),r.push(new Ne({type:"1.2.840.113549.1.9.4",values:[new L({valueHex:t})]})),a.signerInfos.push(new kr({version:1,sid:new Mt({issuer:e.signingCertificate.issuer,serialNumber:e.signingCertificate.serialNumber}),signedAttrs:new wr({type:0,attributes:r})}))},e=>Promise.reject(`Error during making digest for message: ${e}`))).then(()=>a.sign(e.privateKey,0,e.hashAlgorithm))).then(()=>{this.authSafe=new tt({contentType:"1.2.840.113549.1.7.2",content:a.toSchema(!0)})},e=>Promise.reject(`Error during making signature: ${e}`))}break;default:return Promise.reject(`Parameter "integrityMode" has unknown value: ${e.integrityMode}`)}return t}parseInternalValues(e){if(e instanceof Object==!1)return Promise.reject('The "parameters" must has "Object" type');"checkIntegrity"in e==!1&&(e.checkIntegrity=!0);let t=Promise.resolve();const r=Re();if(void 0===r)return Promise.reject("Unable to create WebCrypto object");switch(this.parsedValue={},this.authSafe.contentType){case"1.2.840.113549.1.7.1":{if("password"in e==!1)return Promise.reject('Absent mandatory parameter "password"');if(this.parsedValue.integrityMode=0,this.authSafe.content instanceof L==!1)return Promise.reject('Wrong type of "this.authSafe.content"');let r=new ArrayBuffer(0);if(this.authSafe.content.valueBlock.isConstructed)for(const e of this.authSafe.content.valueBlock.value)r=i(r,e.valueBlock.valueHex);else r=this.authSafe.content.valueBlock.valueHex;const s=ke(r);if(-1===s.offset)return Promise.reject('Error during parsing of ASN.1 data inside "this.authSafe.content"');if(this.parsedValue.authenticatedSafe=new cr({schema:s.result}),e.checkIntegrity){if("macData"in this==!1)return Promise.reject('Absent "macData" value, can not check PKCS#12 data integrity');const s=We(this.macData.mac.digestAlgorithm.algorithmId);if("name"in s==!1)return Promise.reject(`Unsupported digest algorithm: ${this.macData.mac.digestAlgorithm.algorithmId}`);const a=Ke();t=(t=t.then(()=>a.subtle.verifyDataStampedWithPassword({password:e.password,hashAlgorithm:s.name,salt:this.macData.macSalt.valueBlock.valueHex,iterationCount:this.macData.iterations,contentToVerify:r,signatureToVerify:this.macData.mac.digest.valueBlock.valueHex}))).then(e=>{if(!1===e)return Promise.reject("Integrity for the PKCS#12 data is broken!")},e=>Promise.reject(e))}}break;case"1.2.840.113549.1.7.2":{this.parsedValue.integrityMode=1;const e=new Sr({schema:this.authSafe.content});if("eContent"in e.encapContentInfo==!1)return Promise.reject('Absent of attached data in "cmsSigned.encapContentInfo"');if(e.encapContentInfo.eContent instanceof L==!1)return Promise.reject('Wrong type of "cmsSigned.encapContentInfo.eContent"');let r=new ArrayBuffer(0);if(!1===e.encapContentInfo.eContent.idBlock.isConstructed)r=e.encapContentInfo.eContent.valueBlock.valueHex;else for(let t=0;t<e.encapContentInfo.eContent.valueBlock.value.length;t++)r=i(r,e.encapContentInfo.eContent.valueBlock.value[t].valueBlock.valueHex);const s=ke(r);if(-1===s.offset)return Promise.reject('Error during parsing of ASN.1 data inside "this.authSafe.content"');this.parsedValue.authenticatedSafe=new cr({schema:s.result}),t=t.then(()=>e.verify({signer:0,checkChain:!1})).then(e=>{if(!1===e)return Promise.reject("Integrity for the PKCS#12 data is broken!")},e=>Promise.reject(`Error during integrity verification: ${e}`))}break;default:return Promise.reject(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`)}return t.then(()=>this,e=>Promise.reject(`Error during parsing: ${e}`))}}function Ir(e,t,r){return e instanceof Object==!1?r:t in e?e[t]:r}function Nr(e,t=0,r=e.byteLength){let s="";for(const a of new Uint8Array(e,t,r)){const e=a.toString(16).toUpperCase();s=s+(1===e.length?"0":"")+e}return s}function Er(e,t,r,s){return t instanceof ArrayBuffer==!1?(e.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===t.byteLength?(e.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):s<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-s<0)||(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1)}function xr(e,t){let r=0;for(let s=e.length-1;s>=0;s--)r+=e[e.length-1-s]*Math.pow(2,t*s);return r}function Pr(e,t,r=0){const s=r||-1;let a=e,n=0,i=Math.pow(2,t);for(let r=1;r<8;r++){if(e<i){let e;if(s<0)e=new ArrayBuffer(r),n=r;else{if(s<r)return new ArrayBuffer(0);e=new ArrayBuffer(s),n=s}const i=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);i[n-e-1]=Math.floor(a/r),a-=i[n-e-1]*r}return e}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function Dr(...e){let t=0,r=0;for(const r of e)t+=r.byteLength;const s=new ArrayBuffer(t),a=new Uint8Array(s);for(const t of e)a.set(new Uint8Array(t),r),r+=t.byteLength;return s}function Vr(...e){let t=0,r=0;for(const r of e)t+=r.length;const s=new ArrayBuffer(t),a=new Uint8Array(s);for(const t of e)a.set(t,r),r+=t.length;return a}function Or(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),s=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==s[e])return!1;return!0}function jr(e,t){const r=e.toString(10),s=t-r.length,a=new Array(s);for(let e=0;e<s;e++)a[e]="0";return a.join("").concat(r)}const Hr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",Ur="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function Lr(e,t=!1,r=!1){const s=t?Ur:Hr;function a(e){for(let t=0;t<64;t++)if(s.charAt(t)===e)return t;return 64}function n(e){return 64===e?0:e}let i=0,o="";for(;i<e.length;){const t=a(e.charAt(i++)),r=i>=e.length?0:a(e.charAt(i++)),s=i>=e.length?0:a(e.charAt(i++)),l=i>=e.length?0:a(e.charAt(i++)),c=n(t)<<2|n(r)>>4,u=(15&n(r))<<4|n(s)>>2,h=(3&n(s))<<6|n(l);o+=String.fromCharCode(c),64!==s&&(o+=String.fromCharCode(u)),64!==l&&(o+=String.fromCharCode(h))}if(r){let e=-1;for(let t=o.length-1;t>=0;t--)if(0!==o.charCodeAt(t)){e=t;break}-1!==e&&(o=o.slice(0,e+1))}return o}function Kr(e){const t=e.length,r=new ArrayBuffer(t),s=new Uint8Array(r);for(let r=0;r<t;r++)s[r]=e.charCodeAt(r);return r}const Rr=[new Uint8Array([1])],Tr="0123456789";class Jr{constructor(e={}){this.blockLength=Ir(e,"blockLength",0),this.error=Ir(e,"error",""),this.warnings=Ir(e,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in e?e.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:Nr(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const $r=e=>(class extends e{constructor(e={}){super(e),this.isHexOnly=Ir(e,"isHexOnly",!1),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(e,t,r){if(!1===Er(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);return 0===s.length?(this.warnings.push("Zero buffer length"),t):(this.valueHex=e.slice(t,t+r),this.blockLength=r,t+r)}toBER(e=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===e?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isHexOnly=this.isHexOnly,e.valueHex=Nr(this.valueHex,0,this.valueHex.byteLength),e}});class Fr extends($r(Jr)){constructor(e={}){super(),"idBlock"in e?(this.isHexOnly=Ir(e.idBlock,"isHexOnly",!1),this.valueHex=Ir(e.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=Ir(e.idBlock,"tagClass",-1),this.tagNumber=Ir(e.idBlock,"tagNumber",-1),this.isConstructed=Ir(e.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(e=!1){let t,r,s=0;switch(this.tagClass){case 1:s|=0;break;case 2:s|=64;break;case 3:s|=128;break;case 4:s|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(s|=32),this.tagNumber<31&&!this.isHexOnly){if(t=new ArrayBuffer(1),r=new Uint8Array(t),!e){let e=this.tagNumber;s|=e&=31,r[0]=s}return t}if(!1===this.isHexOnly){const a=Pr(this.tagNumber,7),n=new Uint8Array(a),i=a.byteLength;if(t=new ArrayBuffer(i+1),(r=new Uint8Array(t))[0]=31|s,!e){for(let e=0;e<i-1;e++)r[e+1]=128|n[e];r[i]=n[i-1]}return t}if(t=new ArrayBuffer(this.valueHex.byteLength+1),(r=new Uint8Array(t))[0]=31|s,!1===e){const e=new Uint8Array(this.valueHex);for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHex.byteLength]=e[e.length-1]}return t}fromBER(e,t,r){if(!1===Er(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);if(0===s.length)return this.error="Zero buffer length",-1;const a=192&s[0];switch(a){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&s[0]),this.isHexOnly=!1;const n=31&s[0];if(31!==n)this.tagNumber=n,this.blockLength=1;else{let e=1;this.valueHex=new ArrayBuffer(255);let t=255,r=new Uint8Array(this.valueHex);for(;128&s[e];){if(r[e-1]=127&s[e],++e>=s.length)return this.error="End of input reached before message was fully decoded",-1;if(e===t){t+=255;const e=new ArrayBuffer(t),s=new Uint8Array(e);for(let e=0;e<r.length;e++)s[e]=r[e];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex)}}this.blockLength=e+1,r[e-1]=127&s[e];const a=new ArrayBuffer(e),n=new Uint8Array(a);for(let t=0;t<e;t++)n[t]=r[t];this.valueHex=new ArrayBuffer(e),(r=new Uint8Array(this.valueHex)).set(n),this.blockLength<=9?this.tagNumber=xr(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.tagClass=this.tagClass,e.tagNumber=this.tagNumber,e.isConstructed=this.isConstructed,e}}class Mr extends Jr{constructor(e={}){super(),"lenBlock"in e?(this.isIndefiniteForm=Ir(e.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=Ir(e.lenBlock,"longFormUsed",!1),this.length=Ir(e.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(e,t,r){if(!1===Er(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);if(0===s.length)return this.error="Zero buffer length",-1;if(255===s[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===s[0],!0===this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&s[0]),!1===this.longFormUsed)return this.length=s[0],this.blockLength=1,t+this.blockLength;const a=127&s[0];if(a>8)return this.error="Too big integer",-1;if(a+1>s.length)return this.error="End of input reached before message was fully decoded",-1;const n=new Uint8Array(a);for(let e=0;e<a;e++)n[e]=s[e+1];return 0===n[a-1]&&this.warnings.push("Needlessly long encoded length"),this.length=xr(n,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=a+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=128),t;if(!0===this.longFormUsed){const s=Pr(this.length,8);if(s.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength+1),!0===e)return t;const a=new Uint8Array(s);(r=new Uint8Array(t))[0]=128|s.byteLength;for(let e=0;e<s.byteLength;e++)r[e+1]=a[e];return t}return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=this.length),t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isIndefiniteForm=this.isIndefiniteForm,e.longFormUsed=this.longFormUsed,e.length=this.length,e}}class Wr extends Jr{constructor(e={}){super(e)}static blockName(){return"valueBlock"}fromBER(e,t,r){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}toBER(e=!1){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}}class qr extends Jr{constructor(e={},t=Wr){super(e),"name"in e&&(this.name=e.name),"optional"in e&&(this.optional=e.optional),"primitiveSchema"in e&&(this.primitiveSchema=e.primitiveSchema),this.idBlock=new Fr(e),this.lenBlock=new Mr(e),this.valueBlock=new t(e)}static blockName(){return"BaseBlock"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e=!1){let t;const r=this.idBlock.toBER(e),s=this.valueBlock.toBER(!0);this.lenBlock.length=s.byteLength;const a=this.lenBlock.toBER(e);let n;if(t=Dr(t=Dr(r,a),n=!1===e?this.valueBlock.toBER(e):new ArrayBuffer(this.lenBlock.length)),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===e){const e=new Uint8Array(r);e[0]=0,e[1]=0}t=Dr(t,r)}return t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.idBlock=this.idBlock.toJSON(),e.lenBlock=this.lenBlock.toJSON(),e.valueBlock=this.valueBlock.toJSON(),"name"in this&&(e.name=this.name),"optional"in this&&(e.optional=this.optional),"primitiveSchema"in this&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}}class _r extends Wr{constructor(e={}){super(e),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=Ir(e,"isHexOnly",!0)}fromBER(e,t,r){if(!1===Er(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);if(0===s.length)return this.warnings.push("Zero buffer length"),t;this.valueHex=new ArrayBuffer(s.length);const a=new Uint8Array(this.valueHex);for(let e=0;e<s.length;e++)a[e]=s[e];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueHex=Nr(this.valueHex,0,this.valueHex.byteLength),e.isHexOnly=this.isHexOnly,e}}class Gr extends qr{constructor(e={}){super(e,_r),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}class Qr extends Wr{constructor(e={}){super(e),this.value=Ir(e,"value",[]),this.isIndefiniteForm=Ir(e,"isIndefiniteForm",!1)}fromBER(e,t,r){const s=t,a=r;if(!1===Er(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.warnings.push("Zero buffer length"),t;function i(e,t){return!0===e?1:t}let o=t;for(;i(this.isIndefiniteForm,r)>0;){const t=Ks(e,o,r);if(-1===t.offset)return this.error=t.result.error,this.warnings.concat(t.result.warnings),-1;if(o=t.offset,this.blockLength+=t.result.blockLength,r-=t.result.blockLength,this.value.push(t.result),!0===this.isIndefiniteForm&&t.result.constructor.blockName()===Yr.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===Yr.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=e.slice(s,s+a),o}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){t=Dr(t,this.value[r].toBER(e))}return t}static blockName(){return"ConstructedValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.isIndefiniteForm=this.isIndefiniteForm,e.value=[];for(let t=0;t<this.value.length;t++)e.value.push(this.value[t].toJSON());return e}}class zr extends qr{constructor(e={}){super(e,Qr),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}}class Zr extends Wr{constructor(e={}){super(e)}fromBER(e,t,r){return t}toBER(e=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class Yr extends qr{constructor(e={}){super(e,Zr),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}class Xr extends Wr{constructor(e={}){if(super(e),this.value=Ir(e,"value",!1),this.isHexOnly=Ir(e,"isHexOnly",!1),"valueHex"in e)this.valueHex=e.valueHex.slice(0);else if(this.valueHex=new ArrayBuffer(1),!0===this.value){var t=new Uint8Array(this.valueHex);t[0]=255}}fromBER(e,t,r){if(!1===Er(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.value=0!==s[0],this.isHexOnly=!0,this.valueHex=new ArrayBuffer(s.length);const a=new Uint8Array(this.valueHex);for(let e=0;e<s.length;e++)a[e]=s[e];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e.isHexOnly=this.isHexOnly,e.valueHex=Nr(this.valueHex,0,this.valueHex.byteLength),e}}class es extends qr{constructor(e={}){super(e,Xr),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}class ts extends zr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}class rs extends zr{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}class ss extends qr{constructor(e={}){super(e,Jr),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r}toBER(e=!1){const t=new ArrayBuffer(2);if(!0===e)return t;const r=new Uint8Array(t);return r[0]=5,r[1]=0,t}}class as extends($r(Qr)){constructor(e={}){super(e),this.isConstructed=Ir(e,"isConstructed",!1)}fromBER(e,t,r){let s=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,-1===(s=Qr.prototype.fromBER.call(this,e,t,r)))return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===Yr.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==ns.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e=!1){if(!0===this.isConstructed)return Qr.prototype.toBER.call(this,e);let t=new ArrayBuffer(this.valueHex.byteLength);return!0===e?t:0===this.valueHex.byteLength?t:t=this.valueHex.slice(0)}static blockName(){return"OctetStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=Nr(this.valueHex,0,this.valueHex.byteLength),e}}class ns extends qr{constructor(e={}){super(e,as),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t):super.fromBER(e,t,r)}static blockName(){return"OctetString"}isEqual(e){return e instanceof ns!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class is extends($r(Qr)){constructor(e={}){super(e),this.unusedBits=Ir(e,"unusedBits",0),this.isConstructed=Ir(e,"isConstructed",!1),this.blockLength=this.valueHex.byteLength+1}fromBER(e,t,r){if(0===r)return t;let s=-1;if(!0===this.isConstructed){if(-1===(s=Qr.prototype.fromBER.call(this,e,t,r)))return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===Yr.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==os.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[e].unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[e].unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return s}if(!1===Er(this,e,t,r))return-1;const a=new Uint8Array(e,t,r);if(this.unusedBits=a[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(a.length-1);const n=new Uint8Array(this.valueHex);for(let e=0;e<r-1;e++)n[e]=a[e+1];return this.blockLength=a.length,t+r}toBER(e=!1){if(!0===this.isConstructed)return Qr.prototype.toBER.call(this,e);if(!0===e)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const t=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),s=new Uint8Array(r);s[0]=this.unusedBits;for(let e=0;e<this.valueHex.byteLength;e++)s[e+1]=t[e];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.unusedBits=this.unusedBits,e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=Nr(this.valueHex,0,this.valueHex.byteLength),e}}class os extends qr{constructor(e={}){super(e,is),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(e,t,r){return 0===r?t:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r))}isEqual(e){return e instanceof os!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class ls extends($r(Wr)){constructor(e={}){super(e),"value"in e&&(this.valueDec=e.value)}set valueHex(e){this._valueHex=e.slice(0),e.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,e.byteLength>0&&(this._valueDec=function(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&0==(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const s=xr(r,8),a=new ArrayBuffer(this.valueHex.byteLength),n=new Uint8Array(a);for(let t=0;t<this.valueHex.byteLength;t++)n[t]=e[t];return n[0]&=127,xr(n,8)-s}.call(this)))}get valueHex(){return this._valueHex}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this._valueHex=function(e){const t=e<0?-1*e:e;let r=128;for(let s=1;s<8;s++){if(t<=r){if(e<0){const e=Pr(r-t,8,s);return new Uint8Array(e)[0]|=128,e}let a=Pr(t,8,s),n=new Uint8Array(a);if(128&n[0]){const e=a.slice(0),t=new Uint8Array(e);a=new ArrayBuffer(a.byteLength+1),n=new Uint8Array(a);for(let r=0;r<e.byteLength;r++)n[r+1]=t[r];n[0]=0}return a}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(e)}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const a=this.fromBER(e,t,r);if(-1===a)return a;const n=new Uint8Array(this._valueHex);if(0===n[0]&&0!=(128&n[1])){const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}else if(0!==s&&this._valueHex.byteLength<s){s-this._valueHex.byteLength>1&&(s=this._valueHex.byteLength+1);const e=new ArrayBuffer(s);new Uint8Array(e).set(n,s-this._valueHex.byteLength),this._valueHex=e.slice(0)}return a}toDER(e=!1){const t=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&t[0]):{const e=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(e);r[0]=0,r.set(t,1),this._valueHex=e.slice(0)}break;case 0===t[0]&&0==(128&t[1]):{const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return-1===s?s:(this.blockLength=r,t+r)}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e}toString(){function e(e,t){const r=new Uint8Array([0]);let s=new Uint8Array(e),a=new Uint8Array(t),n=s.slice(0);const i=n.length-1;let o=a.slice(0);const l=o.length-1;let c=0;let u=0;for(let e=l<i?i:l;e>=0;e--,u++){switch(!0){case u<o.length:c=n[i-u]+o[l-u]+r[0];break;default:c=n[i-u]+r[0]}switch(r[0]=c/10,!0){case u>=n.length:n=Vr(new Uint8Array([c%10]),n);break;default:n[i-u]=c%10}}return r[0]>0&&(n=Vr(r,n)),n.slice(0)}function t(e){if(e>=Rr.length)for(let t=Rr.length;t<=e;t++){const e=new Uint8Array([0]);let r=Rr[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const s=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=s[0]/10,r[t]=s[0]%10}e[0]>0&&(r=Vr(e,r)),Rr.push(r)}return Rr[e]}function r(e,t){let r=0,s=new Uint8Array(e),a=new Uint8Array(t),n=s.slice(0);const i=n.length-1;let o=a.slice(0);const l=o.length-1;let c,u=0;for(let e=l;e>=0;e--,u++)switch(c=n[i-u]-o[l-u]-r,!0){case c<0:r=1,n[i-u]=c+10;break;default:r=0,n[i-u]=c}if(r>0)for(let e=i-l+1;e>=0;e--,u++){if(!((c=n[i-u]-r)<0)){r=0,n[i-u]=c;break}r=1,n[i-u]=c+10}return n.slice()}const s=8*this._valueHex.byteLength-1;let a,n=new Uint8Array(8*this._valueHex.byteLength/3),i=0;const o=new Uint8Array(this._valueHex);let l="",c=!1;for(let c=this._valueHex.byteLength-1;c>=0;c--){a=o[c];for(let o=0;o<8;o++){if(1==(1&a))switch(i){case s:n=r(t(i),n),l="-";break;default:n=e(n,t(i))}i++,a>>=1}}for(let e=0;e<n.length;e++)n[e]&&(c=!0),c&&(l+=Tr.charAt(n[e]));return!1===c&&(l+=Tr.charAt(0)),l}}class cs extends qr{constructor(e={}){super(e,ls),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(e){return e instanceof cs?this.valueBlock.isHexOnly&&e.valueBlock.isHexOnly?Or(this.valueBlock.valueHex,e.valueBlock.valueHex):this.valueBlock.isHexOnly===e.valueBlock.isHexOnly&&this.valueBlock.valueDec===e.valueBlock.valueDec:e instanceof ArrayBuffer&&Or(this.valueBlock.valueHex,e)}convertToDER(){const e=new cs({valueHex:this.valueBlock.valueHex});return e.valueBlock.toDER(),e}convertFromDER(){const e=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,t=new cs({valueHex:this.valueBlock.valueHex});return t.valueBlock.fromDER(t.valueBlock.valueHex,0,t.valueBlock.valueHex.byteLength,e),t}}class us extends cs{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}class hs extends($r(Jr)){constructor(e={}){super(e),this.valueDec=Ir(e,"valueDec",-1),this.isFirstSid=Ir(e,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(e,t,r){if(0===r)return t;if(!1===Er(this,e,t,r))return-1;const s=new Uint8Array(e,t,r);this.valueHex=new ArrayBuffer(r);let a=new Uint8Array(this.valueHex);for(let e=0;e<r&&(a[e]=127&s[e],this.blockLength++,0!=(128&s[e]));e++);const n=new ArrayBuffer(this.blockLength),i=new Uint8Array(n);for(let e=0;e<this.blockLength;e++)i[e]=a[e];return this.valueHex=n.slice(0),a=new Uint8Array(this.valueHex),0!=(128&s[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===a[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=xr(a,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|s[e];return r[this.blockLength-1]=s[this.blockLength-1],t}const s=Pr(this.valueDec,7);if(0===s.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength),!1===e){const e=new Uint8Array(s);r=new Uint8Array(t);for(let t=0;t<s.byteLength-1;t++)r[t]=128|e[t];r[s.byteLength-1]=e[s.byteLength-1]}return t}toString(){let e="";if(!0===this.isHexOnly)e=Nr(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e.isFirstSid=this.isFirstSid,e}}class ms extends Wr{constructor(e={}){super(e),this.fromString(Ir(e,"value",""))}fromBER(e,t,r){let s=t;for(;r>0;){const t=new hs;if(-1===(s=t.fromBER(e,s,r)))return this.blockLength=0,this.error=t.error,s;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(0===s.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=Dr(t,s)}return t}fromString(e){this.value=[];let t=0,r=0,s="",a=!1;do{if(s=-1===(r=e.indexOf(".",t))?e.substr(t):e.substr(t,r-t),t=r+1,a){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return this.value=[],!1}const r=parseInt(s,10);if(isNaN(r))return!0;e.valueDec=r+t,a=!1}else{const e=new hs;if(e.valueDec=parseInt(s,10),isNaN(e.valueDec))return!0;0===this.value.length&&(e.isFirstSid=!0,a=!0),this.value.push(e)}}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e=`${e}.`),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.value=this.toString(),e.sidArray=[];for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}class fs extends qr{constructor(e={}){super(e,ms),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}class ds extends($r(Jr)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class gs extends qr{constructor(e={}){super(e,ds),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(e){const t=unescape(encodeURIComponent(e)),r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r);const s=new Uint8Array(this.valueBlock.valueHex);for(let e=0;e<r;e++)s[e]=t.charCodeAt(e);this.valueBlock.value=e}}class ps extends($r(Jr)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class ys extends qr{constructor(e={}){super(e,ps),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=2){const t=r[e];r[e]=r[e+1],r[e+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(2*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=Pr(e.charCodeAt(s),8),a=new Uint8Array(t);if(a.length>2)continue;const n=2-a.length;for(let e=a.length-1;e>=0;e--)r[2*s+e+n]=a[e]}this.valueBlock.value=e}}class vs extends($r(Jr)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class bs extends qr{constructor(e={}){super(e,vs),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(4*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=Pr(e.charCodeAt(s),8),a=new Uint8Array(t);if(a.length>4)continue;const n=4-a.length;for(let e=a.length-1;e>=0;e--)r[4*s+e+n]=a[e]}this.valueBlock.value=e}}class ws extends($r(Jr)){constructor(e={}){super(e),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class ks extends qr{constructor(e={}){super(e,ws),"value"in e&&this.fromString(e.value)}static blockName(){return"SIMPLESTRING"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}class As extends ks{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}class Bs extends ks{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}class Ss extends ks{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}class Cs extends ks{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}class Is extends ks{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}class Ns extends ks{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}class Es extends ks{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}class xs extends ks{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}class Ps extends ks{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}class Ds extends Es{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi,r=t.exec(e);if(null===r)return void(this.error="Wrong input string for convertion");const s=parseInt(r[1],10);this.year=s>=50?1900+s:2e3+s,this.month=parseInt(r[2],10),this.day=parseInt(r[3],10),this.hour=parseInt(r[4],10),this.minute=parseInt(r[5],10),this.second=parseInt(r[6],10)}toString(){const e=new Array(7);return e[0]=jr(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=jr(this.month,2),e[2]=jr(this.day,2),e[3]=jr(this.hour,2),e[4]=jr(this.minute,2),e[5]=jr(this.second,2),e[6]="Z",e.join("")}static blockName(){return"UTCTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e}}class Vs extends Es{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,s="",a="",n=0,i=0,o=0;if("Z"===e[e.length-1])s=e.substr(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");s=e}if(r){if(-1!==s.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==s.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let e=1,t=s.indexOf("+"),r="";if(-1===t&&(t=s.indexOf("-"),e=-1),-1!==t){if(r=s.substr(t+1),s=s.substr(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let a=new Number(r.substr(0,2));if(isNaN(a.valueOf()))throw new Error("Wrong input string for convertion");if(i=e*a,4===r.length){if(a=new Number(r.substr(2,2)),isNaN(a.valueOf()))throw new Error("Wrong input string for convertion");o=e*a}}}let l=s.indexOf(".");if(-1===l&&(l=s.indexOf(",")),-1!==l){const e=new Number(`0${s.substr(l)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");n=e.valueOf(),a=s.substr(0,l)}else a=s;switch(!0){case 8===a.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==l)throw new Error("Wrong input string for convertion");break;case 10===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*n;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*n;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){const e=1e3*n;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for convertion")}const c=t.exec(a);if(null===c)throw new Error("Wrong input string for convertion");for(let e=1;e<c.length;e++)switch(e){case 1:this.year=parseInt(c[e],10);break;case 2:this.month=parseInt(c[e],10);break;case 3:this.day=parseInt(c[e],10);break;case 4:this.hour=parseInt(c[e],10)+i;break;case 5:this.minute=parseInt(c[e],10)+o;break;case 6:this.second=parseInt(c[e],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(){const e=[];return e.push(jr(this.year,4)),e.push(jr(this.month,2)),e.push(jr(this.day,2)),e.push(jr(this.hour,2)),e.push(jr(this.minute,2)),e.push(jr(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(jr(this.millisecond,3))),e.push("Z"),e.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e.millisecond=this.millisecond,e}}class Os extends gs{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}class js extends gs{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}class Hs extends gs{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}class Us extends gs{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}class Ls extends gs{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}function Ks(e,t,r){const s=t;let a=new qr({},Object);if(!1===Er(new Jr,e,t,r))return a.error="Wrong input parameters",{offset:-1,result:a};if(0===new Uint8Array(e,t,r).length)return this.error="Zero buffer length",{offset:-1,result:a};let n=a.idBlock.fromBER(e,t,r);if(a.warnings.concat(a.idBlock.warnings),-1===n)return a.error=a.idBlock.error,{offset:-1,result:a};if(t=n,r-=a.idBlock.blockLength,n=a.lenBlock.fromBER(e,t,r),a.warnings.concat(a.lenBlock.warnings),-1===n)return a.error=a.lenBlock.error,{offset:-1,result:a};if(t=n,r-=a.lenBlock.blockLength,!1===a.idBlock.isConstructed&&!0===a.lenBlock.isIndefiniteForm)return a.error="Indefinite length form used for primitive encoding form",{offset:-1,result:a};let i=qr;switch(a.idBlock.tagClass){case 1:if(a.idBlock.tagNumber>=37&&!1===a.idBlock.isHexOnly)return a.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:a};switch(a.idBlock.tagNumber){case 0:if(!0===a.idBlock.isConstructed&&a.lenBlock.length>0)return a.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:a};i=Yr;break;case 1:i=es;break;case 2:i=cs;break;case 3:i=os;break;case 4:i=ns;break;case 5:i=ss;break;case 6:i=fs;break;case 10:i=us;break;case 12:i=gs;break;case 14:i=Ls;break;case 15:return a.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:a};case 16:i=ts;break;case 17:i=rs;break;case 18:i=As;break;case 19:i=Bs;break;case 20:i=Ss;break;case 21:i=Cs;break;case 22:i=Is;break;case 23:i=Ds;break;case 24:i=Vs;break;case 25:i=Ns;break;case 26:i=Es;break;case 27:i=xs;break;case 28:i=bs;break;case 29:i=Ps;break;case 30:i=ys;break;case 31:i=Os;break;case 32:i=js;break;case 33:i=Hs;break;case 34:i=Us;break;default:{let s;(s=!0===a.idBlock.isConstructed?new zr:new Gr).idBlock=a.idBlock,s.lenBlock=a.lenBlock,s.warnings=a.warnings,n=(a=s).fromBER(e,t,r)}}break;case 2:case 3:case 4:default:i=!0===a.idBlock.isConstructed?zr:Gr}return n=(a=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecode=e.valueBeforeDecode.slice(0),r}(a,i)).fromBER(e,t,!0===a.lenBlock.isIndefiniteForm?r:a.lenBlock.length),a.valueBeforeDecode=e.slice(s,s+a.blockLength),{offset:n,result:a}}function Rs(e){if(0===e.byteLength){const e=new qr({},Object);return e.error="Input buffer has zero length",{offset:-1,result:e}}return Ks(e,0,e.byteLength)}function Ts(e){document.body.removeChild(e.target)}function Js(e,t,r){var s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;return Promise.resolve().then(function(){return function(e,t,r){var s=Promise.resolve(),a=Rs(Kr(Lr(t))),n=new De({schema:a.result}),i=[];i.push(new Kt({bagId:"1.2.840.113549.1.12.10.1.1",bagValue:n})),e.forEach(function(e){a=Rs(Kr(Lr(e)));var t=new Ct({schema:a.result});i.push(new Kt({bagId:"1.2.840.113549.1.12.10.1.3",bagValue:new Ot({parsedValue:t})}))});var o=new Cr({parsedValue:{integrityMode:0,authenticatedSafe:new cr({parsedValue:{safeContents:[{privacyMode:0,value:new Rt({safeBags:i})}]}})}});return s=(s=(s=s.then(function(){return o.parsedValue.authenticatedSafe.makeInternalValues({safeContents:[{}]})})).then(function(){return o.makeInternalValues({password:Kr(r),iterations:1e5,pbkdf2HashAlgorithm:"SHA-256",hmacHashAlgorithm:"SHA-256"})})).then(function(){return o.toSchema().toBER(!1)})}(e,t,r)}).then(function(e){var t=new Blob([e],{type:"application/x-pkcs12"}),r=document.createElement("a");return r.download="sslcom_cscert.p12",r.innerHTML="Download File",r.href=window.URL.createObjectURL(t),r.onclick=Ts,r.style.display="none",document.body.appendChild(r),r.click(),s()})}e.passwordBasedIntegrity=Js,Object.defineProperty(e,"__esModule",{value:!0}),window.passwordBasedIntegrity=Js});
