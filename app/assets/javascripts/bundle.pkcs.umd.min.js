!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.pkcs12download={})}(this,function(e){"use strict";function t(e,t,r){return e instanceof Object==!1?r:t in e?e[t]:r}function r(e,t=0,r=e.byteLength){let s="";for(const a of new Uint8Array(e,t,r)){const e=a.toString(16).toUpperCase();s=s+(1===e.length?"0":"")+e}return s}function s(e,t,r,s){return t instanceof ArrayBuffer==!1?(e.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===t.byteLength?(e.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(e.error="Wrong parameter: inputOffset less than zero",!1):s<0?(e.error="Wrong parameter: inputLength less than zero",!1):!(t.byteLength-r-s<0)||(e.error="End of input reached before message was fully decoded (inconsistent offset and length values)",!1)}function a(e,t){let r=0;for(let s=e.length-1;s>=0;s--)r+=e[e.length-1-s]*Math.pow(2,t*s);return r}function n(e,t,r=0){const s=r||-1;let a=e,n=0,i=Math.pow(2,t);for(let r=1;r<8;r++){if(e<i){let e;if(s<0)e=new ArrayBuffer(r),n=r;else{if(s<r)return new ArrayBuffer(0);e=new ArrayBuffer(s),n=s}const i=new Uint8Array(e);for(let e=r-1;e>=0;e--){const r=Math.pow(2,e*t);i[n-e-1]=Math.floor(a/r),a-=i[n-e-1]*r}return e}i*=Math.pow(2,t)}return new ArrayBuffer(0)}function i(...e){let t=0,r=0;for(const r of e)t+=r.byteLength;const s=new ArrayBuffer(t),a=new Uint8Array(s);for(const t of e)a.set(new Uint8Array(t),r),r+=t.byteLength;return s}function o(...e){let t=0,r=0;for(const r of e)t+=r.length;const s=new ArrayBuffer(t),a=new Uint8Array(s);for(const t of e)a.set(t,r),r+=t.length;return a}function l(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),s=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==s[e])return!1;return!0}function c(e,t){const r=e.toString(10),s=t-r.length,a=new Array(s);for(let e=0;e<s;e++)a[e]="0";return a.join("").concat(r)}const u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",h="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function m(e,t=!1,r=!1){const s=t?h:u;function a(e){for(let t=0;t<64;t++)if(s.charAt(t)===e)return t;return 64}function n(e){return 64===e?0:e}let i=0,o="";for(;i<e.length;){const t=a(e.charAt(i++)),r=i>=e.length?0:a(e.charAt(i++)),s=i>=e.length?0:a(e.charAt(i++)),l=i>=e.length?0:a(e.charAt(i++)),c=n(t)<<2|n(r)>>4,u=(15&n(r))<<4|n(s)>>2,h=(3&n(s))<<6|n(l);o+=String.fromCharCode(c),64!==s&&(o+=String.fromCharCode(u)),64!==l&&(o+=String.fromCharCode(h))}if(r){let e=-1;for(let t=o.length-1;t>=0;t--)if(0!==o.charCodeAt(t)){e=t;break}-1!==e&&(o=o.slice(0,e+1))}return o}function f(e){const t=e.length,r=new ArrayBuffer(t),s=new Uint8Array(r);for(let r=0;r<t;r++)s[r]=e.charCodeAt(r);return r}const d=[new Uint8Array([1])],g="0123456789";class p{constructor(e={}){this.blockLength=t(e,"blockLength",0),this.error=t(e,"error",""),this.warnings=t(e,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in e?e.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:r(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const y=e=>(class extends e{constructor(e={}){super(e),this.isHexOnly=t(e,"isHexOnly",!1),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const a=new Uint8Array(e,t,r);return 0===a.length?(this.warnings.push("Zero buffer length"),t):(this.valueHex=e.slice(t,t+r),this.blockLength=r,t+r)}toBER(e=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===e?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isHexOnly=this.isHexOnly,e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e}});class v extends(y(p)){constructor(e={}){super(),"idBlock"in e?(this.isHexOnly=t(e.idBlock,"isHexOnly",!1),this.valueHex=t(e.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=t(e.idBlock,"tagClass",-1),this.tagNumber=t(e.idBlock,"tagNumber",-1),this.isConstructed=t(e.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(e=!1){let t,r,s=0;switch(this.tagClass){case 1:s|=0;break;case 2:s|=64;break;case 3:s|=128;break;case 4:s|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(s|=32),this.tagNumber<31&&!this.isHexOnly){if(t=new ArrayBuffer(1),r=new Uint8Array(t),!e){let e=this.tagNumber;s|=e&=31,r[0]=s}return t}if(!1===this.isHexOnly){const a=n(this.tagNumber,7),i=new Uint8Array(a),o=a.byteLength;if(t=new ArrayBuffer(o+1),(r=new Uint8Array(t))[0]=31|s,!e){for(let e=0;e<o-1;e++)r[e+1]=128|i[e];r[o]=i[o-1]}return t}if(t=new ArrayBuffer(this.valueHex.byteLength+1),(r=new Uint8Array(t))[0]=31|s,!1===e){const e=new Uint8Array(this.valueHex);for(let t=0;t<e.length-1;t++)r[t+1]=128|e[t];r[this.valueHex.byteLength]=e[e.length-1]}return t}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.error="Zero buffer length",-1;const i=192&n[0];switch(i){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&n[0]),this.isHexOnly=!1;const o=31&n[0];if(31!==o)this.tagNumber=o,this.blockLength=1;else{let e=1;this.valueHex=new ArrayBuffer(255);let t=255,r=new Uint8Array(this.valueHex);for(;128&n[e];){if(r[e-1]=127&n[e],++e>=n.length)return this.error="End of input reached before message was fully decoded",-1;if(e===t){t+=255;const e=new ArrayBuffer(t),s=new Uint8Array(e);for(let e=0;e<r.length;e++)s[e]=r[e];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex)}}this.blockLength=e+1,r[e-1]=127&n[e];const s=new ArrayBuffer(e),i=new Uint8Array(s);for(let t=0;t<e;t++)i[t]=r[t];this.valueHex=new ArrayBuffer(e),(r=new Uint8Array(this.valueHex)).set(i),this.blockLength<=9?this.tagNumber=a(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return t+this.blockLength}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.tagClass=this.tagClass,e.tagNumber=this.tagNumber,e.isConstructed=this.isConstructed,e}}class w extends p{constructor(e={}){super(),"lenBlock"in e?(this.isIndefiniteForm=t(e.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=t(e.lenBlock,"longFormUsed",!1),this.length=t(e.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(0===n.length)return this.error="Zero buffer length",-1;if(255===n[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===n[0],!0===this.isIndefiniteForm)return this.blockLength=1,t+this.blockLength;if(this.longFormUsed=!!(128&n[0]),!1===this.longFormUsed)return this.length=n[0],this.blockLength=1,t+this.blockLength;const i=127&n[0];if(i>8)return this.error="Too big integer",-1;if(i+1>n.length)return this.error="End of input reached before message was fully decoded",-1;const o=new Uint8Array(i);for(let e=0;e<i;e++)o[e]=n[e+1];return 0===o[i-1]&&this.warnings.push("Needlessly long encoded length"),this.length=a(o,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=i+1,t+this.blockLength}toBER(e=!1){let t,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=128),t;if(!0===this.longFormUsed){const s=n(this.length,8);if(s.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength+1),!0===e)return t;const a=new Uint8Array(s);(r=new Uint8Array(t))[0]=128|s.byteLength;for(let e=0;e<s.byteLength;e++)r[e+1]=a[e];return t}return t=new ArrayBuffer(1),!1===e&&((r=new Uint8Array(t))[0]=this.length),t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.blockName=this.constructor.blockName(),e.isIndefiniteForm=this.isIndefiniteForm,e.longFormUsed=this.longFormUsed,e.length=this.length,e}}class b extends p{constructor(e={}){super(e)}static blockName(){return"valueBlock"}fromBER(e,t,r){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}toBER(e=!1){throw TypeError('User need to make a specific function in a class which extends "LocalValueBlock"')}}class k extends p{constructor(e={},t=b){super(e),"name"in e&&(this.name=e.name),"optional"in e&&(this.optional=e.optional),"primitiveSchema"in e&&(this.primitiveSchema=e.primitiveSchema),this.idBlock=new v(e),this.lenBlock=new w(e),this.valueBlock=new t(e)}static blockName(){return"BaseBlock"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}toBER(e=!1){let t;const r=this.idBlock.toBER(e),s=this.valueBlock.toBER(!0);this.lenBlock.length=s.byteLength;const a=this.lenBlock.toBER(e);let n;if(t=i(t=i(r,a),n=!1===e?this.valueBlock.toBER(e):new ArrayBuffer(this.lenBlock.length)),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===e){const e=new Uint8Array(r);e[0]=0,e[1]=0}t=i(t,r)}return t}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.idBlock=this.idBlock.toJSON(),e.lenBlock=this.lenBlock.toJSON(),e.valueBlock=this.valueBlock.toJSON(),"name"in this&&(e.name=this.name),"optional"in this&&(e.optional=this.optional),"primitiveSchema"in this&&(e.primitiveSchema=this.primitiveSchema.toJSON()),e}}class A extends b{constructor(e={}){super(e),this.valueHex="valueHex"in e?e.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=t(e,"isHexOnly",!0)}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const a=new Uint8Array(e,t,r);if(0===a.length)return this.warnings.push("Zero buffer length"),t;this.valueHex=new ArrayBuffer(a.length);const n=new Uint8Array(this.valueHex);for(let e=0;e<a.length;e++)n[e]=a[e];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e.isHexOnly=this.isHexOnly,e}}class S extends k{constructor(e={}){super(e,A),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}class C extends b{constructor(e={}){super(e),this.value=t(e,"value",[]),this.isIndefiniteForm=t(e,"isIndefiniteForm",!1)}fromBER(e,t,r){const a=t,n=r;if(!1===s(this,e,t,r))return-1;const i=new Uint8Array(e,t,r);if(0===i.length)return this.warnings.push("Zero buffer length"),t;function o(e,t){return!0===e?1:t}let l=t;for(;o(this.isIndefiniteForm,r)>0;){const t=ye(e,l,r);if(-1===t.offset)return this.error=t.result.error,this.warnings.concat(t.result.warnings),-1;if(l=t.offset,this.blockLength+=t.result.blockLength,r-=t.result.blockLength,this.value.push(t.result),!0===this.isIndefiniteForm&&t.result.constructor.blockName()===N.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===N.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=e.slice(a,a+n),l}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){t=i(t,this.value[r].toBER(e))}return t}static blockName(){return"ConstructedValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.isIndefiniteForm=this.isIndefiniteForm,e.value=[];for(let t=0;t<this.value.length;t++)e.value.push(this.value[t].toJSON());return e}}class I extends k{constructor(e={}){super(e,C),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(e,t,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}}class B extends b{constructor(e={}){super(e)}fromBER(e,t,r){return t}toBER(e=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class N extends k{constructor(e={}){super(e,B),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}class P extends b{constructor(e={}){if(super(e),this.value=t(e,"value",!1),this.isHexOnly=t(e,"isHexOnly",!1),"valueHex"in e)this.valueHex=e.valueHex.slice(0);else if(this.valueHex=new ArrayBuffer(1),!0===this.value){var r=new Uint8Array(this.valueHex);r[0]=255}}fromBER(e,t,r){if(!1===s(this,e,t,r))return-1;const a=new Uint8Array(e,t,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.value=0!==a[0],this.isHexOnly=!0,this.valueHex=new ArrayBuffer(a.length);const n=new Uint8Array(this.valueHex);for(let e=0;e<a.length;e++)n[e]=a[e];return this.blockLength=r,t+r}toBER(e=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e.isHexOnly=this.isHexOnly,e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e}}class E extends k{constructor(e={}){super(e,P),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}class x extends I{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}class V extends I{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}class D extends k{constructor(e={}){super(e,p),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(e,t,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,t+r}toBER(e=!1){const t=new ArrayBuffer(2);if(!0===e)return t;const r=new Uint8Array(t);return r[0]=5,r[1]=0,t}}class O extends(y(C)){constructor(e={}){super(e),this.isConstructed=t(e,"isConstructed",!1)}fromBER(e,t,r){let s=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,-1===(s=C.prototype.fromBER.call(this,e,t,r)))return s;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===N.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(t!==j.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,s=super.fromBER(e,t,r),this.blockLength=r;return s}toBER(e=!1){if(!0===this.isConstructed)return C.prototype.toBER.call(this,e);let t=new ArrayBuffer(this.valueHex.byteLength);return!0===e?t:0===this.valueHex.byteLength?t:t=this.valueHex.slice(0)}static blockName(){return"OctetStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e}}class j extends k{constructor(e={}){super(e,O),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(e,t,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),t):super.fromBER(e,t,r)}static blockName(){return"OctetString"}isEqual(e){return e instanceof j!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class H extends(y(C)){constructor(e={}){super(e),this.unusedBits=t(e,"unusedBits",0),this.isConstructed=t(e,"isConstructed",!1),this.blockLength=this.valueHex.byteLength+1}fromBER(e,t,r){if(0===r)return t;let a=-1;if(!0===this.isConstructed){if(-1===(a=C.prototype.fromBER.call(this,e,t,r)))return a;for(let e=0;e<this.value.length;e++){const t=this.value[e].constructor.blockName();if(t===N.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(t!==K.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[e].unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[e].unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return a}if(!1===s(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);if(this.unusedBits=n[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(n.length-1);const i=new Uint8Array(this.valueHex);for(let e=0;e<r-1;e++)i[e]=n[e+1];return this.blockLength=n.length,t+r}toBER(e=!1){if(!0===this.isConstructed)return C.prototype.toBER.call(this,e);if(!0===e)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const t=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),s=new Uint8Array(r);s[0]=this.unusedBits;for(let e=0;e<this.valueHex.byteLength;e++)s[e+1]=t[e];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.unusedBits=this.unusedBits,e.isConstructed=this.isConstructed,e.isHexOnly=this.isHexOnly,e.valueHex=r(this.valueHex,0,this.valueHex.byteLength),e}}class K extends k{constructor(e={}){super(e,H),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(e,t,r){return 0===r?t:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(e,t,r))}isEqual(e){return e instanceof K!=!1&&JSON.stringify(this)===JSON.stringify(e)}}class U extends(y(b)){constructor(e={}){super(e),"value"in e&&(this.valueDec=e.value)}set valueHex(e){this._valueHex=e.slice(0),e.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,e.byteLength>0&&(this._valueDec=function(){const e=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const t=255===e[0]&&128&e[1],r=0===e[0]&&0==(128&e[1]);(t||r)&&this.warnings.push("Needlessly long format")}const t=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(t);for(let e=0;e<this.valueHex.byteLength;e++)r[e]=0;r[0]=128&e[0];const s=a(r,8),n=new ArrayBuffer(this.valueHex.byteLength),i=new Uint8Array(n);for(let t=0;t<this.valueHex.byteLength;t++)i[t]=e[t];return i[0]&=127,a(i,8)-s}.call(this)))}get valueHex(){return this._valueHex}set valueDec(e){this._valueDec=e,this.isHexOnly=!1,this._valueHex=function(e){const t=e<0?-1*e:e;let r=128;for(let s=1;s<8;s++){if(t<=r){if(e<0){const e=n(r-t,8,s);return new Uint8Array(e)[0]|=128,e}let a=n(t,8,s),i=new Uint8Array(a);if(128&i[0]){const e=a.slice(0),t=new Uint8Array(e);a=new ArrayBuffer(a.byteLength+1),i=new Uint8Array(a);for(let r=0;r<e.byteLength;r++)i[r+1]=t[r];i[0]=0}return a}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(e)}get valueDec(){return this._valueDec}fromDER(e,t,r,s=0){const a=this.fromBER(e,t,r);if(-1===a)return a;const n=new Uint8Array(this._valueHex);if(0===n[0]&&0!=(128&n[1])){const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}else if(0!==s&&this._valueHex.byteLength<s){s-this._valueHex.byteLength>1&&(s=this._valueHex.byteLength+1);const e=new ArrayBuffer(s);new Uint8Array(e).set(n,s-this._valueHex.byteLength),this._valueHex=e.slice(0)}return a}toDER(e=!1){const t=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&t[0]):{const e=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(e);r[0]=0,r.set(t,1),this._valueHex=e.slice(0)}break;case 0===t[0]&&0==(128&t[1]):{const e=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(e).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=e.slice(0)}}return this.toBER(e)}fromBER(e,t,r){const s=super.fromBER(e,t,r);return-1===s?s:(this.blockLength=r,t+r)}toBER(e=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e}toString(){function e(e,t){const r=new Uint8Array([0]);let s=new Uint8Array(e),a=new Uint8Array(t),n=s.slice(0);const i=n.length-1;let l=a.slice(0);const c=l.length-1;let u=0;let h=0;for(let e=c<i?i:c;e>=0;e--,h++){switch(!0){case h<l.length:u=n[i-h]+l[c-h]+r[0];break;default:u=n[i-h]+r[0]}switch(r[0]=u/10,!0){case h>=n.length:n=o(new Uint8Array([u%10]),n);break;default:n[i-h]=u%10}}return r[0]>0&&(n=o(r,n)),n.slice(0)}function t(e){if(e>=d.length)for(let t=d.length;t<=e;t++){const e=new Uint8Array([0]);let r=d[t-1].slice(0);for(let t=r.length-1;t>=0;t--){const s=new Uint8Array([(r[t]<<1)+e[0]]);e[0]=s[0]/10,r[t]=s[0]%10}e[0]>0&&(r=o(e,r)),d.push(r)}return d[e]}function r(e,t){let r=0,s=new Uint8Array(e),a=new Uint8Array(t),n=s.slice(0);const i=n.length-1;let o=a.slice(0);const l=o.length-1;let c,u=0;for(let e=l;e>=0;e--,u++)switch(c=n[i-u]-o[l-u]-r,!0){case c<0:r=1,n[i-u]=c+10;break;default:r=0,n[i-u]=c}if(r>0)for(let e=i-l+1;e>=0;e--,u++){if(!((c=n[i-u]-r)<0)){r=0,n[i-u]=c;break}r=1,n[i-u]=c+10}return n.slice()}const s=8*this._valueHex.byteLength-1;let a,n=new Uint8Array(8*this._valueHex.byteLength/3),i=0;const l=new Uint8Array(this._valueHex);let c="",u=!1;for(let o=this._valueHex.byteLength-1;o>=0;o--){a=l[o];for(let o=0;o<8;o++){if(1==(1&a))switch(i){case s:n=r(t(i),n),c="-";break;default:n=e(n,t(i))}i++,a>>=1}}for(let e=0;e<n.length;e++)n[e]&&(u=!0),u&&(c+=g.charAt(n[e]));return!1===u&&(c+=g.charAt(0)),c}}class R extends k{constructor(e={}){super(e,U),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(e){return e instanceof R?this.valueBlock.isHexOnly&&e.valueBlock.isHexOnly?l(this.valueBlock.valueHex,e.valueBlock.valueHex):this.valueBlock.isHexOnly===e.valueBlock.isHexOnly&&this.valueBlock.valueDec===e.valueBlock.valueDec:e instanceof ArrayBuffer&&l(this.valueBlock.valueHex,e)}convertToDER(){const e=new R({valueHex:this.valueBlock.valueHex});return e.valueBlock.toDER(),e}convertFromDER(){const e=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,t=new R({valueHex:this.valueBlock.valueHex});return t.valueBlock.fromDER(t.valueBlock.valueHex,0,t.valueBlock.valueHex.byteLength,e),t}}class L extends R{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}class T extends(y(p)){constructor(e={}){super(e),this.valueDec=t(e,"valueDec",-1),this.isFirstSid=t(e,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(e,t,r){if(0===r)return t;if(!1===s(this,e,t,r))return-1;const n=new Uint8Array(e,t,r);this.valueHex=new ArrayBuffer(r);let i=new Uint8Array(this.valueHex);for(let e=0;e<r&&(i[e]=127&n[e],this.blockLength++,0!=(128&n[e]));e++);const o=new ArrayBuffer(this.blockLength),l=new Uint8Array(o);for(let e=0;e<this.blockLength;e++)l[e]=i[e];return this.valueHex=o.slice(0),i=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===i[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=a(i,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),t+this.blockLength)}toBER(e=!1){let t,r;if(this.isHexOnly){if(!0===e)return new ArrayBuffer(this.valueHex.byteLength);const s=new Uint8Array(this.valueHex);t=new ArrayBuffer(this.blockLength),r=new Uint8Array(t);for(let e=0;e<this.blockLength-1;e++)r[e]=128|s[e];return r[this.blockLength-1]=s[this.blockLength-1],t}const s=n(this.valueDec,7);if(0===s.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(t=new ArrayBuffer(s.byteLength),!1===e){const e=new Uint8Array(s);r=new Uint8Array(t);for(let t=0;t<s.byteLength-1;t++)r[t]=128|e[t];r[s.byteLength-1]=e[s.byteLength-1]}return t}toString(){let e="";if(!0===this.isHexOnly)e=r(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let t=this.valueDec;this.valueDec<=39?e="0.":this.valueDec<=79?(e="1.",t-=40):(e="2.",t-=80),e+=t.toString()}else e=this.valueDec.toString();return e}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.valueDec=this.valueDec,e.isFirstSid=this.isFirstSid,e}}class J extends b{constructor(e={}){super(e),this.fromString(t(e,"value",""))}fromBER(e,t,r){let s=t;for(;r>0;){const t=new T;if(-1===(s=t.fromBER(e,s,r)))return this.blockLength=0,this.error=t.error,s;0===this.value.length&&(t.isFirstSid=!0),this.blockLength+=t.blockLength,r-=t.blockLength,this.value.push(t)}return s}toBER(e=!1){let t=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const s=this.value[r].toBER(e);if(0===s.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);t=i(t,s)}return t}fromString(e){this.value=[];let t=0,r=0,s="",a=!1;do{if(s=-1===(r=e.indexOf(".",t))?e.substr(t):e.substr(t,r-t),t=r+1,a){const e=this.value[0];let t=0;switch(e.valueDec){case 0:break;case 1:t=40;break;case 2:t=80;break;default:return this.value=[],!1}const r=parseInt(s,10);if(isNaN(r))return!0;e.valueDec=r+t,a=!1}else{const e=new T;if(e.valueDec=parseInt(s,10),isNaN(e.valueDec))return!0;0===this.value.length&&(e.isFirstSid=!0,a=!0),this.value.push(e)}}while(-1!==r);return!0}toString(){let e="",t=!1;for(let r=0;r<this.value.length;r++){t=this.value[r].isHexOnly;let s=this.value[r].toString();0!==r&&(e=`${e}.`),t?(s=`{${s}}`,this.value[r].isFirstSid?e=`2.{${s} - 80}`:e+=s):e+=s}return e}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}e.value=this.toString(),e.sidArray=[];for(let t=0;t<this.value.length;t++)e.sidArray.push(this.value[t].toJSON());return e}}class $ extends k{constructor(e={}){super(e,J),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}class F extends(y(p)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class M extends k{constructor(e={}){super(e,F),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(e){const t=unescape(encodeURIComponent(e)),r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r);const s=new Uint8Array(this.valueBlock.valueHex);for(let e=0;e<r;e++)s[e]=t.charCodeAt(e);this.valueBlock.value=e}}class W extends(y(p)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class q extends k{constructor(e={}){super(e,W),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=2){const t=r[e];r[e]=r[e+1],r[e+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(2*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=n(e.charCodeAt(s),8),a=new Uint8Array(t);if(a.length>2)continue;const i=2-a.length;for(let e=a.length-1;e>=0;e--)r[2*s+e+i]=a[e]}this.valueBlock.value=e}}class _ extends(y(p)){constructor(e={}){super(e),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class G extends k{constructor(e={}){super(e,_),"value"in e&&this.fromString(e.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){const t=e.slice(0),r=new Uint8Array(t);for(let e=0;e<r.length;e+=4)r[e]=r[e+3],r[e+1]=r[e+2],r[e+2]=0,r[e+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(t))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(4*t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++){const t=n(e.charCodeAt(s),8),a=new Uint8Array(t);if(a.length>4)continue;const i=4-a.length;for(let e=a.length-1;e>=0;e--)r[4*s+e+i]=a[e]}this.valueBlock.value=e}}class Q extends(y(p)){constructor(e={}){super(e),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.value=this.value,e}}class z extends k{constructor(e={}){super(e,Q),"value"in e&&this.fromString(e.value)}static blockName(){return"SIMPLESTRING"}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(e))}fromString(e){const t=e.length;this.valueBlock.valueHex=new ArrayBuffer(t);const r=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);this.valueBlock.value=e}}class Z extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}class Y extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}class X extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}class ee extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}class te extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}class re extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}class se extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}class ae extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}class ne extends z{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}class ie extends se{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(e){const t=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi,r=t.exec(e);if(null===r)return void(this.error="Wrong input string for convertion");const s=parseInt(r[1],10);this.year=s>=50?1900+s:2e3+s,this.month=parseInt(r[2],10),this.day=parseInt(r[3],10),this.hour=parseInt(r[4],10),this.minute=parseInt(r[5],10),this.second=parseInt(r[6],10)}toString(){const e=new Array(7);return e[0]=c(this.year<2e3?this.year-1900:this.year-2e3,2),e[1]=c(this.month,2),e[2]=c(this.day,2),e[3]=c(this.hour,2),e[4]=c(this.minute,2),e[5]=c(this.second,2),e[6]="Z",e.join("")}static blockName(){return"UTCTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e}}class oe extends se{constructor(e={}){if(super(e),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in e){this.fromString(e.value),this.valueBlock.valueHex=new ArrayBuffer(e.value.length);const t=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<e.value.length;r++)t[r]=e.value.charCodeAt(r)}"valueDate"in e&&(this.fromDate(e.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(e,t,r){const s=this.valueBlock.fromBER(e,t,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===s?(this.error=this.valueBlock.error,s):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),s)}fromBuffer(e){this.fromString(String.fromCharCode.apply(null,new Uint8Array(e)))}toBuffer(){const e=this.toString(),t=new ArrayBuffer(e.length),r=new Uint8Array(t);for(let t=0;t<e.length;t++)r[t]=e.charCodeAt(t);return t}fromDate(e){this.year=e.getUTCFullYear(),this.month=e.getUTCMonth()+1,this.day=e.getUTCDate(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(e){let t,r=!1,s="",a="",n=0,i=0,o=0;if("Z"===e[e.length-1])s=e.substr(0,e.length-1),r=!0;else{const t=new Number(e[e.length-1]);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");s=e}if(r){if(-1!==s.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==s.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let e=1,t=s.indexOf("+"),r="";if(-1===t&&(t=s.indexOf("-"),e=-1),-1!==t){if(r=s.substr(t+1),s=s.substr(0,t),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let a=new Number(r.substr(0,2));if(isNaN(a.valueOf()))throw new Error("Wrong input string for convertion");if(i=e*a,4===r.length){if(a=new Number(r.substr(2,2)),isNaN(a.valueOf()))throw new Error("Wrong input string for convertion");o=e*a}}}let l=s.indexOf(".");if(-1===l&&(l=s.indexOf(",")),-1!==l){const e=new Number(`0${s.substr(l)}`);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");n=e.valueOf(),a=s.substr(0,l)}else a=s;switch(!0){case 8===a.length:if(t=/(\d{4})(\d{2})(\d{2})/gi,-1!==l)throw new Error("Wrong input string for convertion");break;case 10===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*n;this.minute=Math.floor(e),e=60*(e-this.minute),this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 12===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){let e=60*n;this.second=Math.floor(e),e=1e3*(e-this.second),this.millisecond=Math.floor(e)}break;case 14===a.length:if(t=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==l){const e=1e3*n;this.millisecond=Math.floor(e)}break;default:throw new Error("Wrong input string for convertion")}const c=t.exec(a);if(null===c)throw new Error("Wrong input string for convertion");for(let e=1;e<c.length;e++)switch(e){case 1:this.year=parseInt(c[e],10);break;case 2:this.month=parseInt(c[e],10);break;case 3:this.day=parseInt(c[e],10);break;case 4:this.hour=parseInt(c[e],10)+i;break;case 5:this.minute=parseInt(c[e],10)+o;break;case 6:this.second=parseInt(c[e],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const e=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=e.getUTCFullYear(),this.month=e.getUTCMonth(),this.day=e.getUTCDay(),this.hour=e.getUTCHours(),this.minute=e.getUTCMinutes(),this.second=e.getUTCSeconds(),this.millisecond=e.getUTCMilliseconds()}}toString(){const e=[];return e.push(c(this.year,4)),e.push(c(this.month,2)),e.push(c(this.day,2)),e.push(c(this.hour,2)),e.push(c(this.minute,2)),e.push(c(this.second,2)),0!==this.millisecond&&(e.push("."),e.push(c(this.millisecond,3))),e.push("Z"),e.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let e={};try{e=super.toJSON()}catch(e){}return e.year=this.year,e.month=this.month,e.day=this.day,e.hour=this.hour,e.minute=this.minute,e.second=this.second,e.millisecond=this.millisecond,e}}class le extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}class ce extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}class ue extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}class he extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}class me extends M{constructor(e={}){super(e),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}class fe{constructor(e={}){this.value=t(e,"value",[]),this.optional=t(e,"optional",!1)}}class de{constructor(e={}){this.name=t(e,"name",""),this.optional=t(e,"optional",!1)}}class ge{constructor(e={}){this.name=t(e,"name",""),this.optional=t(e,"optional",!1),this.value=t(e,"value",new de),this.local=t(e,"local",!1)}}class pe{constructor(e={}){this.data=t(e,"data",new ArrayBuffer(0))}fromBER(e,t,r){this.data=e.slice(t,r)}toBER(e=!1){return this.data}}function ye(e,t,r){const a=t;let n=new k({},Object);if(!1===s(new p,e,t,r))return n.error="Wrong input parameters",{offset:-1,result:n};if(0===new Uint8Array(e,t,r).length)return this.error="Zero buffer length",{offset:-1,result:n};let i=n.idBlock.fromBER(e,t,r);if(n.warnings.concat(n.idBlock.warnings),-1===i)return n.error=n.idBlock.error,{offset:-1,result:n};if(t=i,r-=n.idBlock.blockLength,i=n.lenBlock.fromBER(e,t,r),n.warnings.concat(n.lenBlock.warnings),-1===i)return n.error=n.lenBlock.error,{offset:-1,result:n};if(t=i,r-=n.lenBlock.blockLength,!1===n.idBlock.isConstructed&&!0===n.lenBlock.isIndefiniteForm)return n.error="Indefinite length form used for primitive encoding form",{offset:-1,result:n};let o=k;switch(n.idBlock.tagClass){case 1:if(n.idBlock.tagNumber>=37&&!1===n.idBlock.isHexOnly)return n.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:n};switch(n.idBlock.tagNumber){case 0:if(!0===n.idBlock.isConstructed&&n.lenBlock.length>0)return n.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:n};o=N;break;case 1:o=E;break;case 2:o=R;break;case 3:o=K;break;case 4:o=j;break;case 5:o=D;break;case 6:o=$;break;case 10:o=L;break;case 12:o=M;break;case 14:o=me;break;case 15:return n.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:n};case 16:o=x;break;case 17:o=V;break;case 18:o=Z;break;case 19:o=Y;break;case 20:o=X;break;case 21:o=ee;break;case 22:o=te;break;case 23:o=ie;break;case 24:o=oe;break;case 25:o=re;break;case 26:o=se;break;case 27:o=ae;break;case 28:o=G;break;case 29:o=ne;break;case 30:o=q;break;case 31:o=le;break;case 32:o=ce;break;case 33:o=ue;break;case 34:o=he;break;default:{let s;(s=!0===n.idBlock.isConstructed?new I:new S).idBlock=n.idBlock,s.lenBlock=n.lenBlock,s.warnings=n.warnings,i=(n=s).fromBER(e,t,r)}}break;case 2:case 3:case 4:default:o=!0===n.idBlock.isConstructed?I:S}return i=(n=function(e,t){if(e instanceof t)return e;const r=new t;return r.idBlock=e.idBlock,r.lenBlock=e.lenBlock,r.warnings=e.warnings,r.valueBeforeDecode=e.valueBeforeDecode.slice(0),r}(n,o)).fromBER(e,t,!0===n.lenBlock.isIndefiniteForm?r:n.lenBlock.length),n.valueBeforeDecode=e.slice(a,a+n.blockLength),{offset:i,result:n}}function ve(e){if(0===e.byteLength){const e=new k({},Object);return e.error="Input buffer has zero length",{offset:-1,result:e}}return ye(e,0,e.byteLength)}function we(e,t,r){if(r instanceof fe){for(let s=0;s<r.value.length;s++){if(!0===we(e,t,r.value[s]).verified)return{verified:!0,result:e}}{const e={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty("name")&&(e.name=r.name),e}}if(r instanceof de)return r.hasOwnProperty("name")&&(e[r.name]=t),{verified:!0,result:e};if(e instanceof Object==!1)return{verified:!1,result:{error:"Wrong root object"}};if(t instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=r.idBlock.toBER(!1);if(0===s.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(s,0,s.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==t.idBlock.tagClass)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==t.idBlock.tagNumber)return{verified:!1,result:e};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==t.idBlock.isConstructed)return{verified:!1,result:e};if("isHexOnly"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==t.idBlock.isHexOnly)return{verified:!1,result:e};if(!0===r.idBlock.isHexOnly){if("valueHex"in r.idBlock==!1)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const s=new Uint8Array(r.idBlock.valueHex),a=new Uint8Array(t.idBlock.valueHex);if(s.length!==a.length)return{verified:!1,result:e};for(let t=0;t<s.length;t++)if(s[t]!==a[1])return{verified:!1,result:e}}if(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(e[r.name]=t)),!0===r.idBlock.isConstructed){let s=0,a={verified:!1},n=r.valueBlock.value.length;if(n>0&&r.valueBlock.value[0]instanceof ge&&(n=t.valueBlock.value.length),0===n)return{verified:!0,result:e};if(0===t.valueBlock.value.length&&0!==r.valueBlock.value.length){let t=!0;for(let e=0;e<r.valueBlock.value.length;e++)t=t&&(r.valueBlock.value[e].optional||!1);return!0===t?{verified:!0,result:e}:(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),e.error="Inconsistent object length",{verified:!1,result:e})}for(let i=0;i<n;i++)if(i-s>=t.valueBlock.value.length){if(!1===r.valueBlock.value[i].optional){const t={verified:!1,result:e};return e.error="Inconsistent length between ASN.1 data and schema",r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}}else if(r.valueBlock.value[0]instanceof ge){if(!1===(a=we(e,t.valueBlock.value[i],r.valueBlock.value[0].value)).verified){if(!0!==r.valueBlock.value[0].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),a;s++}if("name"in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let s={};void 0===(s="local"in r.valueBlock.value[0]&&!0===r.valueBlock.value[0].local?t:e)[r.valueBlock.value[0].name]&&(s[r.valueBlock.value[0].name]=[]),s[r.valueBlock.value[0].name].push(t.valueBlock.value[i])}}else if(!1===(a=we(e,t.valueBlock.value[i-s],r.valueBlock.value[i])).verified){if(!0!==r.valueBlock.value[i].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete e[r.name]),a;s++}if(!1===a.verified){const t={verified:!1,result:e};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}return{verified:!0,result:e}}if("primitiveSchema"in r&&"valueHex"in t.valueBlock){const s=ve(t.valueBlock.valueHex);if(-1===s.offset){const t={verified:!1,result:s.result};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete e[r.name],t.name=r.name)),t}return we(e,s.result,r.primitiveSchema)}return{verified:!0,result:e}}function be(e,t,r){return e instanceof Object==!1?r:t in e?e[t]:r}function ke(e,t=0,r=e.byteLength){let s="";for(const a of new Uint8Array(e,t,r)){const e=a.toString(16).toUpperCase();s=s+(1===e.length?"0":"")+e}return s}function Ae(...e){let t=0,r=0;for(const r of e)t+=r.byteLength;const s=new ArrayBuffer(t),a=new Uint8Array(s);for(const t of e)a.set(new Uint8Array(t),r),r+=t.byteLength;return s}function Se(e,t){if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),s=new Uint8Array(t);for(let e=0;e<r.length;e++)if(r[e]!==s[e])return!1;return!0}const Ce="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",Ie="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function Be(e,t=!1,r=!1,s=!1){let a=0,n=0,i=0,o="";const l=t?Ie:Ce;if(s){let t=0;for(let r=0;r<e.length;r++)if(0!==e.charCodeAt(r)){t=r;break}e=e.slice(t)}for(;a<e.length;){const t=e.charCodeAt(a++);a>=e.length&&(n=1);const s=e.charCodeAt(a++);a>=e.length&&(i=1);const c=e.charCodeAt(a++),u=t>>2,h=(3&t)<<4|s>>4;let m=(15&s)<<2|c>>6,f=63&c;1===n?m=f=64:1===i&&(f=64),o+=r?64===m?`${l.charAt(u)}${l.charAt(h)}`:64===f?`${l.charAt(u)}${l.charAt(h)}${l.charAt(m)}`:`${l.charAt(u)}${l.charAt(h)}${l.charAt(m)}${l.charAt(f)}`:`${l.charAt(u)}${l.charAt(h)}${l.charAt(m)}${l.charAt(f)}`}return o}function Ne(e,t=!1,r=!1){const s=t?Ie:Ce;function a(e){for(let t=0;t<64;t++)if(s.charAt(t)===e)return t;return 64}function n(e){return 64===e?0:e}let i=0,o="";for(;i<e.length;){const t=a(e.charAt(i++)),r=i>=e.length?0:a(e.charAt(i++)),s=i>=e.length?0:a(e.charAt(i++)),l=i>=e.length?0:a(e.charAt(i++)),c=n(t)<<2|n(r)>>4,u=(15&n(r))<<4|n(s)>>2,h=(3&n(s))<<6|n(l);o+=String.fromCharCode(c),64!==s&&(o+=String.fromCharCode(u)),64!==l&&(o+=String.fromCharCode(h))}if(r){let e=-1;for(let t=o.length-1;t>=0;t--)if(0!==o.charCodeAt(t)){e=t;break}-1!==e&&(o=o.slice(0,e+1))}return o}function Pe(e){let t="";const r=new Uint8Array(e);for(const e of r)t+=String.fromCharCode(e);return t}function Ee(e){const t=e.length,r=new ArrayBuffer(t),s=new Uint8Array(r);for(let r=0;r<t;r++)s[r]=e.charCodeAt(r);return r}const xe=Math.log(2);class Ve{constructor(e={}){this.algorithmId=be(e,"algorithmId",Ve.defaultValues("algorithmId")),"algorithmParams"in e&&(this.algorithmParams=be(e,"algorithmParams",Ve.defaultValues("algorithmParams"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"algorithmId":return"";case"algorithmParams":return new de;default:throw new Error(`Invalid member name for AlgorithmIdentifier class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"algorithmId":return""===t;case"algorithmParams":return t instanceof de;default:throw new Error(`Invalid member name for AlgorithmIdentifier class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",optional:t.optional||!1,value:[new $({name:t.algorithmIdentifier||""}),new de({name:t.algorithmParams||"",optional:!0})]})}fromSchema(e){const t=we(e,e,Ve.schema({names:{algorithmIdentifier:"algorithm",algorithmParams:"params"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier");this.algorithmId=t.result.algorithm.valueBlock.toString(),"params"in t.result&&(this.algorithmParams=t.result.params)}toSchema(){const e=[];return e.push(new $({value:this.algorithmId})),"algorithmParams"in this&&this.algorithmParams instanceof de==!1&&e.push(this.algorithmParams),new x({value:e})}toJSON(){const e={algorithmId:this.algorithmId};return"algorithmParams"in this&&this.algorithmParams instanceof de==!1&&(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof Ve!=!1&&(this.algorithmId===e.algorithmId&&("algorithmParams"in this?"algorithmParams"in e&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!("algorithmParams"in e)))}}class De{constructor(e={}){this.x=be(e,"x",De.defaultValues("x")),this.y=be(e,"y",De.defaultValues("y")),this.namedCurve=be(e,"namedCurve",De.defaultValues("namedCurve")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"x":case"y":return new ArrayBuffer(0);case"namedCurve":return"";default:throw new Error(`Invalid member name for ECCPublicKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"x":case"y":return Se(t,De.defaultValues(e));case"namedCurve":return""===t;default:throw new Error(`Invalid member name for ECCPublicKey class: ${e}`)}}static schema(e={}){return new pe}fromSchema(e){if(e instanceof ArrayBuffer==!1)throw new Error("Object's schema was not verified against input data for ECPublicKey");const t=new Uint8Array(e);if(4!==t[0])throw new Error("Object's schema was not verified against input data for ECPublicKey");let r;switch(this.namedCurve){case"1.2.840.10045.3.1.7":r=32;break;case"1.3.132.0.34":r=48;break;case"1.3.132.0.35":r=66;break;default:throw new Error(`Incorrect curve OID: ${this.namedCurve}`)}if(e.byteLength!==2*r+1)throw new Error("Object's schema was not verified against input data for ECPublicKey");this.x=e.slice(1,r+1),this.y=e.slice(1+r,2*r+1)}toSchema(){return new pe({data:Ae(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}return{crv:e,x:Be(Pe(this.x),!0,!0,!1),y:Be(Pe(this.y),!0,!0,!1)}}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("x"in e))throw new Error('Absent mandatory parameter "x"');{const r=Ee(Ne(e.x,!0));if(r.byteLength<t){this.x=new ArrayBuffer(t);const e=new Uint8Array(this.x),s=new Uint8Array(r);e.set(1,s)}else this.x=r.slice(0,t)}if(!("y"in e))throw new Error('Absent mandatory parameter "y"');{const r=Ee(Ne(e.y,!0));if(r.byteLength<t){this.y=new ArrayBuffer(t);const e=new Uint8Array(this.y),s=new Uint8Array(r);e.set(1,s)}else this.y=r.slice(0,t)}}}class Oe{constructor(e={}){this.modulus=be(e,"modulus",Oe.defaultValues("modulus")),this.publicExponent=be(e,"publicExponent",Oe.defaultValues("publicExponent")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"modulus":case"publicExponent":return new R;default:throw new Error(`Invalid member name for RSAPublicKey class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.modulus||""}),new R({name:t.publicExponent||""})]})}fromSchema(e){const t=we(e,e,Oe.schema({names:{modulus:"modulus",publicExponent:"publicExponent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPublicKey");this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new x({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:Be(Pe(this.modulus.valueBlock.valueHex),!0,!0,!0),e:Be(Pe(this.publicExponent.valueBlock.valueHex),!0,!0,!0)}}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');{const t=Ee(Ne(e.n,!0));this.modulus=new R({valueHex:t.slice(0,Math.pow(2,function(e){const t=Math.log(e)/xe,r=Math.floor(t),s=Math.round(t);return r===s?r:s}(t.byteLength)))})}if(!("e"in e))throw new Error('Absent mandatory parameter "e"');this.publicExponent=new R({valueHex:Ee(Ne(e.e,!0)).slice(0,3)})}}class je{constructor(e={}){this.algorithm=be(e,"algorithm",je.defaultValues("algorithm")),this.subjectPublicKey=be(e,"subjectPublicKey",je.defaultValues("subjectPublicKey")),"parsedKey"in e&&(this.parsedKey=be(e,"parsedKey",je.defaultValues("parsedKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"algorithm":return new Ve;case"subjectPublicKey":return new K;default:throw new Error(`Invalid member name for PublicKeyInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[Ve.schema(t.algorithm||{}),new K({name:t.subjectPublicKey||""})]})}fromSchema(e){const t=we(e,e,je.schema({names:{algorithm:{names:{blockName:"algorithm"}},subjectPublicKey:"subjectPublicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PUBLIC_KEY_INFO");switch(this.algorithm=new Ve({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey,this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams instanceof $)try{this.parsedKey=new De({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHex})}catch(e){}break;case"1.2.840.113549.1.1.1":{const e=ve(this.subjectPublicKey.valueBlock.valueHex);if(-1!==e.offset)try{this.parsedKey=new Oe({schema:e.result})}catch(e){}}}}toSchema(){return new x({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if("parsedKey"in this==!1)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};const e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const r of Object.keys(t))e[r]=t[r];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new De({json:e}),this.algorithm=new Ve({algorithmId:"1.2.840.10045.2.1",algorithmParams:new $({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Oe({json:e}),this.algorithm=new Ve({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new D});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.subjectPublicKey=new K({valueHex:this.parsedKey.toSchema().toBER(!1)})}}importKey(e){let t=Promise.resolve();const r=this;if(void 0===e)return Promise.reject("Need to provide publicKey input parameter");const s=_e();return void 0===s?Promise.reject("Unable to create WebCrypto object"):t=(t=t.then(()=>s.exportKey("spki",e))).then(e=>{const t=ve(e);try{r.fromSchema(t.result)}catch(e){return Promise.reject("Error during initializing object from schema")}},e=>Promise.reject(`Error during exporting public key: ${e}`))}}class He{constructor(e={}){this.type=be(e,"type",He.defaultValues("type")),this.values=be(e,"values",He.defaultValues("values")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return"";case"values":return[];default:throw new Error(`Invalid member name for Attribute class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"type":return""===t;case"values":return 0===t.length;default:throw new Error(`Invalid member name for Attribute class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.type||""}),new V({name:t.setName||"",value:[new ge({name:t.values||"",value:new de})]})]})}fromSchema(e){const t=we(e,e,He.schema({names:{type:"type",values:"values"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ATTRIBUTE");this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new x({value:[new $({value:this.type}),new V({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,e=>e.toJSON())}}}class Ke{constructor(e={}){this.version=be(e,"version",Ke.defaultValues("version")),this.privateKey=be(e,"privateKey",Ke.defaultValues("privateKey")),"namedCurve"in e&&(this.namedCurve=be(e,"namedCurve",Ke.defaultValues("namedCurve"))),"publicKey"in e&&(this.publicKey=be(e,"publicKey",Ke.defaultValues("publicKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 1;case"privateKey":return new j;case"namedCurve":return"";case"publicKey":return new De;default:throw new Error(`Invalid member name for ECCPrivateKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return t===Ke.defaultValues(e);case"privateKey":return t.isEqual(Ke.defaultValues(e));case"namedCurve":return""===t;case"publicKey":return De.compareWithDefault("namedCurve",t.namedCurve)&&De.compareWithDefault("x",t.x)&&De.compareWithDefault("y",t.y);default:throw new Error(`Invalid member name for ECCPrivateKey class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.version||""}),new j({name:t.privateKey||""}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new $({name:t.namedCurve||""})]}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new K({name:t.publicKey||""})]})]})}fromSchema(e){const t=we(e,e,Ke.schema({names:{version:"version",privateKey:"privateKey",namedCurve:"namedCurve",publicKey:"publicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ECPrivateKey");if(this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,"namedCurve"in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),"publicKey"in t.result){const e={schema:t.result.publicKey.valueBlock.valueHex};"namedCurve"in this&&(e.namedCurve=this.namedCurve),this.publicKey=new De(e)}}toSchema(){const e=[new R({value:this.version}),this.privateKey];return"namedCurve"in this&&e.push(new I({idBlock:{tagClass:3,tagNumber:0},value:[new $({value:this.namedCurve})]})),"publicKey"in this&&e.push(new I({idBlock:{tagClass:3,tagNumber:1},value:[new K({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new x({value:e})}toJSON(){if("namedCurve"in this==!1||Ke.compareWithDefault("namedCurve",this.namedCurve))throw new Error('Not enough information for making JSON: absent "namedCurve" value');let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}const t={crv:e,d:Be(Pe(this.privateKey.valueBlock.valueHex),!0,!0,!1)};if("publicKey"in this){const e=this.publicKey.toJSON();t.x=e.x,t.y=e.y}return t}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("d"in e))throw new Error('Absent mandatory parameter "d"');{const r=Ee(Ne(e.d,!0));if(r.byteLength<t){const e=new ArrayBuffer(t),s=new Uint8Array(e),a=new Uint8Array(r);s.set(1,a),this.privateKey=new j({valueHex:e})}else this.privateKey=new j({valueHex:r.slice(0,t)})}"x"in e&&"y"in e&&(this.publicKey=new De({json:e}))}}class Ue{constructor(e={}){this.prime=be(e,"prime",Ue.defaultValues("prime")),this.exponent=be(e,"exponent",Ue.defaultValues("exponent")),this.coefficient=be(e,"coefficient",Ue.defaultValues("coefficient")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"prime":case"exponent":case"coefficient":return new R;default:throw new Error(`Invalid member name for OtherPrimeInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.prime||""}),new R({name:t.exponent||""}),new R({name:t.coefficient||""})]})}fromSchema(e){const t=we(e,e,Ue.schema({names:{prime:"prime",exponent:"exponent",coefficient:"coefficient"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherPrimeInfo");this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new x({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:Be(Pe(this.prime.valueBlock.valueHex),!0,!0),d:Be(Pe(this.exponent.valueBlock.valueHex),!0,!0),t:Be(Pe(this.coefficient.valueBlock.valueHex),!0,!0)}}fromJSON(e){if(!("r"in e))throw new Error('Absent mandatory parameter "r"');if(this.prime=new R({valueHex:Ee(Ne(e.r,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.exponent=new R({valueHex:Ee(Ne(e.d,!0))}),!("t"in e))throw new Error('Absent mandatory parameter "t"');this.coefficient=new R({valueHex:Ee(Ne(e.t,!0))})}}class Re{constructor(e={}){this.version=be(e,"version",Re.defaultValues("version")),this.modulus=be(e,"modulus",Re.defaultValues("modulus")),this.publicExponent=be(e,"publicExponent",Re.defaultValues("publicExponent")),this.privateExponent=be(e,"privateExponent",Re.defaultValues("privateExponent")),this.prime1=be(e,"prime1",Re.defaultValues("prime1")),this.prime2=be(e,"prime2",Re.defaultValues("prime2")),this.exponent1=be(e,"exponent1",Re.defaultValues("exponent1")),this.exponent2=be(e,"exponent2",Re.defaultValues("exponent2")),this.coefficient=be(e,"coefficient",Re.defaultValues("coefficient")),"otherPrimeInfos"in e&&(this.otherPrimeInfos=be(e,"otherPrimeInfos",Re.defaultValues("otherPrimeInfos"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 0;case"modulus":case"publicExponent":case"privateExponent":case"prime1":case"prime2":case"exponent1":case"exponent2":case"coefficient":return new R;case"otherPrimeInfos":return[];default:throw new Error(`Invalid member name for RSAPrivateKey class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.version||""}),new R({name:t.modulus||""}),new R({name:t.publicExponent||""}),new R({name:t.privateExponent||""}),new R({name:t.prime1||""}),new R({name:t.prime2||""}),new R({name:t.exponent1||""}),new R({name:t.exponent2||""}),new R({name:t.coefficient||""}),new x({optional:!0,value:[new ge({name:t.otherPrimeInfosName||"",value:Ue.schema(t.otherPrimeInfo||{})})]})]})}fromSchema(e){const t=we(e,e,Re.schema({names:{version:"version",modulus:"modulus",publicExponent:"publicExponent",privateExponent:"privateExponent",prime1:"prime1",prime2:"prime2",exponent1:"exponent1",exponent2:"exponent2",coefficient:"coefficient",otherPrimeInfo:{names:{blockName:"otherPrimeInfos"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPrivateKey");this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),"otherPrimeInfos"in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,e=>new Ue({schema:e})))}toSchema(){const e=[];return e.push(new R({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),"otherPrimeInfos"in this&&e.push(new x({value:Array.from(this.otherPrimeInfos,e=>e.toSchema())})),new x({value:e})}toJSON(){const e={n:Be(Pe(this.modulus.valueBlock.valueHex),!0,!0,!0),e:Be(Pe(this.publicExponent.valueBlock.valueHex),!0,!0,!0),d:Be(Pe(this.privateExponent.valueBlock.valueHex),!0,!0,!0),p:Be(Pe(this.prime1.valueBlock.valueHex),!0,!0,!0),q:Be(Pe(this.prime2.valueBlock.valueHex),!0,!0,!0),dp:Be(Pe(this.exponent1.valueBlock.valueHex),!0,!0,!0),dq:Be(Pe(this.exponent2.valueBlock.valueHex),!0,!0,!0),qi:Be(Pe(this.coefficient.valueBlock.valueHex),!0,!0,!0)};return"otherPrimeInfos"in this&&(e.oth=Array.from(this.otherPrimeInfos,e=>e.toJSON())),e}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');if(this.modulus=new R({valueHex:Ee(Ne(e.n,!0,!0))}),!("e"in e))throw new Error('Absent mandatory parameter "e"');if(this.publicExponent=new R({valueHex:Ee(Ne(e.e,!0,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.privateExponent=new R({valueHex:Ee(Ne(e.d,!0,!0))}),!("p"in e))throw new Error('Absent mandatory parameter "p"');if(this.prime1=new R({valueHex:Ee(Ne(e.p,!0,!0))}),!("q"in e))throw new Error('Absent mandatory parameter "q"');if(this.prime2=new R({valueHex:Ee(Ne(e.q,!0,!0))}),!("dp"in e))throw new Error('Absent mandatory parameter "dp"');if(this.exponent1=new R({valueHex:Ee(Ne(e.dp,!0,!0))}),!("dq"in e))throw new Error('Absent mandatory parameter "dq"');if(this.exponent2=new R({valueHex:Ee(Ne(e.dq,!0,!0))}),!("qi"in e))throw new Error('Absent mandatory parameter "qi"');this.coefficient=new R({valueHex:Ee(Ne(e.qi,!0,!0))}),"oth"in e&&(this.otherPrimeInfos=Array.from(e.oth,e=>new Ue({json:e})))}}class Le{constructor(e={}){this.version=be(e,"version",Le.defaultValues("version")),this.privateKeyAlgorithm=be(e,"privateKeyAlgorithm",Le.defaultValues("privateKeyAlgorithm")),this.privateKey=be(e,"privateKey",Le.defaultValues("privateKey")),"attributes"in e&&(this.attributes=be(e,"attributes",Le.defaultValues("attributes"))),"parsedKey"in e&&(this.parsedKey=be(e,"parsedKey",Le.defaultValues("parsedKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 0;case"privateKeyAlgorithm":return new Ve;case"privateKey":return new j;case"attributes":return[];default:throw new Error(`Invalid member name for PrivateKeyInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.version||""}),Ve.schema(t.privateKeyAlgorithm||{}),new j({name:t.privateKey||""}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ge({name:t.attributes||"",value:He.schema()})]})]})}fromSchema(e){const t=we(e,e,Le.schema({names:{version:"version",privateKeyAlgorithm:{names:{blockName:"privateKeyAlgorithm"}},privateKey:"privateKey",attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PKCS8");switch(this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new Ve({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,"attributes"in t.result&&(this.attributes=Array.from(t.result.attributes,e=>new He({schema:e}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{const e=ve(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new Re({schema:e.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof $){const e=ve(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new Ke({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:e.result}))}}}toSchema(){const e=[new R({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return"attributes"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new x({value:e})}toJSON(){if("parsedKey"in this==!1){const e={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return"attributes"in this&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}const e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const r of Object.keys(t))e[r]=t[r];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new Ke({json:e}),this.privateKeyAlgorithm=new Ve({algorithmId:"1.2.840.10045.2.1",algorithmParams:new $({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Re({json:e}),this.privateKeyAlgorithm=new Ve({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new D});break;default:throw new Error(`Invalid value for "kty" parameter: ${e.kty}`)}this.privateKey=new j({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}class Te{constructor(e={}){if(this.contentType=be(e,"contentType",Te.defaultValues("contentType")),this.contentEncryptionAlgorithm=be(e,"contentEncryptionAlgorithm",Te.defaultValues("contentEncryptionAlgorithm")),"encryptedContent"in e&&(this.encryptedContent=e.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed)){const e=new j({idBlock:{isConstructed:!0},isConstructed:!0});let t=0,r=this.encryptedContent.valueBlock.valueHex.byteLength;for(;r>0;){const s=new Uint8Array(this.encryptedContent.valueBlock.valueHex,t,t+1024>this.encryptedContent.valueBlock.valueHex.byteLength?this.encryptedContent.valueBlock.valueHex.byteLength-t:1024),a=new ArrayBuffer(s.length),n=new Uint8Array(a);for(let e=0;e<n.length;e++)n[e]=s[e];e.valueBlock.value.push(new j({valueHex:a})),r-=s.length,t+=s.length}this.encryptedContent=e}"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"contentType":return"";case"contentEncryptionAlgorithm":return new Ve;case"encryptedContent":return new j;default:throw new Error(`Invalid member name for EncryptedContentInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"contentType":return""===t;case"contentEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"encryptedContent":return t.isEqual(Te.defaultValues(e));default:throw new Error(`Invalid member name for EncryptedContentInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.contentType||""}),Ve.schema(t.contentEncryptionAlgorithm||{}),new fe({value:[new I({name:t.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0},value:[new ge({value:new j})]}),new S({name:t.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){const t=we(e,e,Te.schema({names:{contentType:"contentType",contentEncryptionAlgorithm:{names:{blockName:"contentEncryptionAlgorithm"}},encryptedContent:"encryptedContent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EncryptedContentInfo");this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new Ve({schema:t.result.contentEncryptionAlgorithm}),"encryptedContent"in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){const e={isIndefiniteForm:!1},t=[];if(t.push(new $({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),"encryptedContent"in this){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;const r=this.encryptedContent;r.idBlock.tagClass=3,r.idBlock.tagNumber=0,r.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(r)}return new x({lenBlock:e,value:t})}toJSON(){const e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return"encryptedContent"in this&&(e.encryptedContent=this.encryptedContent.toJSON()),e}}class Je{constructor(e={}){this.hashAlgorithm=be(e,"hashAlgorithm",Je.defaultValues("hashAlgorithm")),this.maskGenAlgorithm=be(e,"maskGenAlgorithm",Je.defaultValues("maskGenAlgorithm")),this.saltLength=be(e,"saltLength",Je.defaultValues("saltLength")),this.trailerField=be(e,"trailerField",Je.defaultValues("trailerField")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new Ve({algorithmId:"1.3.14.3.2.26",algorithmParams:new D});case"maskGenAlgorithm":return new Ve({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new Ve({algorithmId:"1.3.14.3.2.26",algorithmParams:new D}).toSchema()});case"saltLength":return 20;case"trailerField":return 1;default:throw new Error(`Invalid member name for RSASSAPSSParams class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new I({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[Ve.schema(t.hashAlgorithm||{})]}),new I({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[Ve.schema(t.maskGenAlgorithm||{})]}),new I({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new R({name:t.saltLength||""})]}),new I({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new R({name:t.trailerField||""})]})]})}fromSchema(e){const t=we(e,e,Je.schema({names:{hashAlgorithm:{names:{blockName:"hashAlgorithm"}},maskGenAlgorithm:{names:{blockName:"maskGenAlgorithm"}},saltLength:"saltLength",trailerField:"trailerField"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSASSA_PSS_params");"hashAlgorithm"in t.result&&(this.hashAlgorithm=new Ve({schema:t.result.hashAlgorithm})),"maskGenAlgorithm"in t.result&&(this.maskGenAlgorithm=new Ve({schema:t.result.maskGenAlgorithm})),"saltLength"in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),"trailerField"in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){const e=[];return this.hashAlgorithm.isEqual(Je.defaultValues("hashAlgorithm"))||e.push(new I({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(Je.defaultValues("maskGenAlgorithm"))||e.push(new I({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==Je.defaultValues("saltLength")&&e.push(new I({idBlock:{tagClass:3,tagNumber:2},value:[new R({value:this.saltLength})]})),this.trailerField!==Je.defaultValues("trailerField")&&e.push(new I({idBlock:{tagClass:3,tagNumber:3},value:[new R({value:this.trailerField})]})),new x({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(Je.defaultValues("hashAlgorithm"))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(Je.defaultValues("maskGenAlgorithm"))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==Je.defaultValues("saltLength")&&(e.saltLength=this.saltLength),this.trailerField!==Je.defaultValues("trailerField")&&(e.trailerField=this.trailerField),e}}class $e{constructor(e={}){this.salt=be(e,"salt",$e.defaultValues("salt")),this.iterationCount=be(e,"iterationCount",$e.defaultValues("iterationCount")),"keyLength"in e&&(this.keyLength=be(e,"keyLength",$e.defaultValues("keyLength"))),"prf"in e&&(this.prf=be(e,"prf",$e.defaultValues("prf"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"salt":return{};case"iterationCount":return-1;case"keyLength":return 0;case"prf":return new Ve({algorithmId:"1.3.14.3.2.26",algorithmParams:new D});default:throw new Error(`Invalid member name for PBKDF2Params class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new fe({value:[new j({name:t.saltPrimitive||""}),Ve.schema(t.saltConstructed||{})]}),new R({name:t.iterationCount||""}),new R({name:t.keyLength||"",optional:!0}),Ve.schema(t.prf||{names:{optional:!0}})]})}fromSchema(e){const t=we(e,e,$e.schema({names:{saltPrimitive:"salt",saltConstructed:{names:{blockName:"salt"}},iterationCount:"iterationCount",keyLength:"keyLength",prf:{names:{blockName:"prf",optional:!0}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBKDF2_params");this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,"keyLength"in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),"prf"in t.result&&(this.prf=new Ve({schema:t.result.prf}))}toSchema(){const e=[];return e.push(this.salt),e.push(new R({value:this.iterationCount})),"keyLength"in this&&$e.defaultValues("keyLength")!==this.keyLength&&e.push(new R({value:this.keyLength})),"prf"in this&&!1===$e.defaultValues("prf").isEqual(this.prf)&&e.push(this.prf.toSchema()),new x({value:e})}toJSON(){const e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return"keyLength"in this&&$e.defaultValues("keyLength")!==this.keyLength&&(e.keyLength=this.keyLength),"prf"in this&&!1===$e.defaultValues("prf").isEqual(this.prf)&&(e.prf=this.prf.toJSON()),e}}class Fe{constructor(e={}){this.keyDerivationFunc=be(e,"keyDerivationFunc",Fe.defaultValues("keyDerivationFunc")),this.encryptionScheme=be(e,"encryptionScheme",Fe.defaultValues("encryptionScheme")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyDerivationFunc":case"encryptionScheme":return new Ve;default:throw new Error(`Invalid member name for PBES2Params class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[Ve.schema(t.keyDerivationFunc||{}),Ve.schema(t.encryptionScheme||{})]})}fromSchema(e){const t=we(e,e,Fe.schema({names:{keyDerivationFunc:{names:{blockName:"keyDerivationFunc"}},encryptionScheme:{names:{blockName:"encryptionScheme"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBES2_params");this.keyDerivationFunc=new Ve({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new Ve({schema:t.result.encryptionScheme})}toSchema(){return new x({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}function Me(e,t,r,s,a,n){let i,o;const l=[];switch(t.toUpperCase()){case"SHA-1":i=20,o=64;break;case"SHA-256":i=32,o=64;break;case"SHA-384":i=48,o=128;break;case"SHA-512":i=64,o=128;break;default:throw new Error("Unsupported hashing algorithm")}const c=new Uint8Array(s),u=new ArrayBuffer(2*s.byteLength+2),h=new Uint8Array(u);for(let e=0;e<c.length;e++)h[2*e]=0,h[2*e+1]=c[e];h[h.length-2]=0,h[h.length-1]=0,s=u.slice(0);const m=new ArrayBuffer(o),f=new Uint8Array(m);for(let e=0;e<m.byteLength;e++)f[e]=3;const d=a.byteLength,g=o*Math.ceil(d/o),p=new ArrayBuffer(g),y=new Uint8Array(p),v=new Uint8Array(a);for(let e=0;e<g;e++)y[e]=v[e%d];const w=s.byteLength,b=o*Math.ceil(w/o),k=new ArrayBuffer(b),A=new Uint8Array(k),S=new Uint8Array(s);for(let e=0;e<b;e++)A[e]=S[e%w];const C=p.byteLength+k.byteLength;let I=new ArrayBuffer(C),B=new Uint8Array(I);B.set(y),B.set(A,y.length);const N=Math.ceil((r>>3)/i);let P=Promise.resolve(I);for(let r=0;r<=N;r++){P=P.then(e=>{const t=new ArrayBuffer(m.byteLength+e.byteLength),r=new Uint8Array(t);return r.set(f),r.set(B,f.length),t});for(let r=0;r<n;r++)P=P.then(r=>e.digest({name:t},new Uint8Array(r)));P=P.then(e=>{const t=new ArrayBuffer(o),r=new Uint8Array(t);for(let s=0;s<t.byteLength;s++)r[s]=e[s%e.length];const s=Math.ceil(d/o)+Math.ceil(w/o),a=[];let n=0,i=o;for(let e=0;e<s;e++){const e=Array.from(new Uint8Array(I.slice(n,n+i)));(n+=o)+o>I.byteLength&&(i=I.byteLength-n);let s=511;for(let a=t.byteLength-1;a>=0;a--)s>>=8,s+=r[a]+e[a],e[a]=255&s;a.push(...e)}return I=new ArrayBuffer(a.length),(B=new Uint8Array(I)).set(a),l.push(...new Uint8Array(e)),I})}return P=P.then(()=>{const e=new ArrayBuffer(r>>3);return new Uint8Array(e).set(new Uint8Array(l).slice(0,r>>3)),e})}let We={name:"none",crypto:null,subtle:null};function qe(){return We}!function(){if("undefined"!=typeof self&&"crypto"in self){let e="webcrypto";const t=self.crypto;let r=null;if("webkitSubtle"in self.crypto){try{r=self.crypto.webkitSubtle}catch(e){r=self.crypto.subtle}e="safari"}"subtle"in self.crypto&&(r=self.crypto.subtle),We={name:e,crypto:t,subtle:new class{constructor(e={}){this.crypto=be(e,"crypto",{}),this.subtle=be(e,"subtle",{}),this.name=be(e,"name","")}importKey(e,t,r,s,a){let n={};switch(t instanceof Uint8Array&&(t=t.buffer),e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,r,s,a);case"spki":{const e=ve(t);if(-1===e.offset)return Promise.reject("Incorrect keyData");const i=new je;try{i.fromSchema(e.result)}catch(e){return Promise.reject("Incorrect keyData")}switch(r.name.toUpperCase()){case"RSA-PSS":switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="PS1";break;case"SHA-256":n.alg="PS256";break;case"SHA-384":n.alg="PS384";break;case"SHA-512":n.alg="PS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(a=["verify"],n.kty="RSA",n.ext=s,n.key_ops=a,"1.2.840.113549.1.1.1"!==i.algorithm.algorithmId)return Promise.reject(`Incorrect public key algorithm: ${i.algorithm.algorithmId}`);if("alg"in n==0)switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RS1";break;case"SHA-256":n.alg="RS256";break;case"SHA-384":n.alg="RS384";break;case"SHA-512":n.alg="RS512";break;default:return Promise.reject(`Incorrect public key algorithm: ${i.algorithm.algorithmId}`)}const e=i.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;case"ECDSA":a=["verify"];case"ECDH":{if(n={kty:"EC",ext:s,key_ops:a},"1.2.840.10045.2.1"!==i.algorithm.algorithmId)return Promise.reject(`Incorrect public key algorithm: ${i.algorithm.algorithmId}`);const e=i.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;case"RSA-OAEP":{if(n.kty="RSA",n.ext=s,n.key_ops=a,"safari"===this.name.toLowerCase())n.alg="RSA-OAEP";else switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RSA-OAEP-1";break;case"SHA-256":n.alg="RSA-OAEP-256";break;case"SHA-384":n.alg="RSA-OAEP-384";break;case"SHA-512":n.alg="RSA-OAEP-512";break;default:return Promise.reject(`Incorrect public key algorithm: ${i.algorithm.algorithmId}`)}const e=i.toJSON();for(const t of Object.keys(e))n[t]=e[t]}break;default:return Promise.reject(`Incorrect algorithm name: ${r.name.toUpperCase()}`)}}break;case"pkcs8":{const e=new Le,i=ve(t);if(-1===i.offset)return Promise.reject("Incorrect keyData");try{e.fromSchema(i.result)}catch(e){return Promise.reject("Incorrect keyData")}switch(r.name.toUpperCase()){case"RSA-PSS":switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="PS1";break;case"SHA-256":n.alg="PS256";break;case"SHA-384":n.alg="PS384";break;case"SHA-512":n.alg="PS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}case"RSASSA-PKCS1-V1_5":{if(a=["sign"],n.kty="RSA",n.ext=s,n.key_ops=a,"1.2.840.113549.1.1.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject(`Incorrect private key algorithm: ${e.privateKeyAlgorithm.algorithmId}`);if("alg"in n==0)switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RS1";break;case"SHA-256":n.alg="RS256";break;case"SHA-384":n.alg="RS384";break;case"SHA-512":n.alg="RS512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}const t=e.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;case"ECDSA":a=["sign"];case"ECDH":{if(n={kty:"EC",ext:s,key_ops:a},"1.2.840.10045.2.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject(`Incorrect algorithm: ${e.privateKeyAlgorithm.algorithmId}`);const t=e.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;case"RSA-OAEP":{if(n.kty="RSA",n.ext=s,n.key_ops=a,"safari"===this.name.toLowerCase())n.alg="RSA-OAEP";else switch(r.hash.name.toUpperCase()){case"SHA-1":n.alg="RSA-OAEP-1";break;case"SHA-256":n.alg="RSA-OAEP-256";break;case"SHA-384":n.alg="RSA-OAEP-384";break;case"SHA-512":n.alg="RSA-OAEP-512";break;default:return Promise.reject(`Incorrect hash algorithm: ${r.hash.name.toUpperCase()}`)}const t=e.toJSON();for(const e of Object.keys(t))n[e]=t[e]}break;default:return Promise.reject(`Incorrect algorithm name: ${r.name.toUpperCase()}`)}}break;case"jwk":n=t;break;default:return Promise.reject(`Incorrect format: ${e}`)}return"safari"===this.name.toLowerCase()?Promise.resolve().then(()=>this.subtle.importKey("jwk",Ee(JSON.stringify(n)),r,s,a)).then(e=>e,e=>this.subtle.importKey("jwk",n,r,s,a)):this.subtle.importKey("jwk",n,r,s,a)}exportKey(e,t){let r=this.subtle.exportKey("jwk",t);switch("safari"===this.name.toLowerCase()&&(r=r.then(e=>e instanceof ArrayBuffer?JSON.parse(Pe(e)):e)),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":r=r.then(e=>{const t=new je;try{t.fromJSON(e)}catch(e){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"pkcs8":r=r.then(e=>{const t=new Le;try{t.fromJSON(e)}catch(e){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"jwk":break;default:return Promise.reject(`Incorrect format: ${e}`)}return r}convert(e,t,r,s,a,n){switch(e.toLowerCase()){case"raw":switch(t.toLowerCase()){case"raw":return Promise.resolve(r);case"spki":return Promise.resolve().then(()=>this.importKey("raw",r,s,a,n)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("raw",r,s,a,n)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve().then(()=>this.importKey("raw",r,s,a,n)).then(e=>this.exportKey("jwk",e));default:return Promise.reject(`Incorrect outputFormat: ${t}`)}case"spki":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("spki",r,s,a,n)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve(r);case"pkcs8":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"jwk":return Promise.resolve().then(()=>this.importKey("spki",r,s,a,n)).then(e=>this.exportKey("jwk",e));default:return Promise.reject(`Incorrect outputFormat: ${t}`)}case"pkcs8":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("pkcs8",r,s,a,n)).then(e=>this.exportKey("raw",e));case"spki":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"pkcs8":return Promise.resolve(r);case"jwk":return Promise.resolve().then(()=>this.importKey("pkcs8",r,s,a,n)).then(e=>this.exportKey("jwk",e));default:return Promise.reject(`Incorrect outputFormat: ${t}`)}case"jwk":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("jwk",r,s,a,n)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve().then(()=>this.importKey("jwk",r,s,a,n)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("jwk",r,s,a,n)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve(r);default:return Promise.reject(`Incorrect outputFormat: ${t}`)}default:return Promise.reject(`Incorrect inputFormat: ${e}`)}}encrypt(...e){return this.subtle.encrypt(...e)}decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}verify(...e){return this.subtle.verify(...e)}digest(...e){return this.subtle.digest(...e)}generateKey(...e){return this.subtle.generateKey(...e)}deriveKey(...e){return this.subtle.deriveKey(...e)}deriveBits(...e){return this.subtle.deriveBits(...e)}wrapKey(...e){return this.subtle.wrapKey(...e)}unwrapKey(...e){return this.subtle.unwrapKey(...e)}getRandomValues(e){if("getRandomValues"in this.crypto==0)throw new Error("No support for getRandomValues");return this.crypto.getRandomValues(e)}getAlgorithmByOID(e){switch(e){case"1.2.840.113549.1.1.1":case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}return{}}getOIDByAlgorithm(e){let t="";switch(e.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.1.1.5";break;case"SHA-256":t="1.2.840.113549.1.1.11";break;case"SHA-384":t="1.2.840.113549.1.1.12";break;case"SHA-512":t="1.2.840.113549.1.1.13"}break;case"RSA-PSS":t="1.2.840.113549.1.1.10";break;case"RSA-OAEP":t="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.10045.4.1";break;case"SHA-256":t="1.2.840.10045.4.3.2";break;case"SHA-384":t="1.2.840.10045.4.3.3";break;case"SHA-512":t="1.2.840.10045.4.3.4"}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":t="1.3.133.16.840.63.0.2";break;case"SHA-256":t="1.3.132.1.11.1";break;case"SHA-384":t="1.3.132.1.11.2";break;case"SHA-512":t="1.3.132.1.11.3"}break;case"AES-CTR":break;case"AES-CBC":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.2";break;case 192:t="2.16.840.1.101.3.4.1.22";break;case 256:t="2.16.840.1.101.3.4.1.42"}break;case"AES-CMAC":break;case"AES-GCM":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.6";break;case 192:t="2.16.840.1.101.3.4.1.26";break;case 256:t="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.4";break;case 192:t="2.16.840.1.101.3.4.1.24";break;case 256:t="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.5";break;case 192:t="2.16.840.1.101.3.4.1.25";break;case 256:t="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.2.7";break;case"SHA-256":t="1.2.840.113549.2.9";break;case"SHA-384":t="1.2.840.113549.2.10";break;case"SHA-512":t="1.2.840.113549.2.11"}break;case"DH":t="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":t="1.3.14.3.2.26";break;case"SHA-256":t="2.16.840.1.101.3.4.2.1";break;case"SHA-384":t="2.16.840.1.101.3.4.2.2";break;case"SHA-512":t="2.16.840.1.101.3.4.2.3";break;case"CONCAT":case"HKDF":break;case"PBKDF2":t="1.2.840.113549.1.5.12";break;case"P-256":t="1.2.840.10045.3.1.7";break;case"P-384":t="1.3.132.0.34";break;case"P-521":t="1.3.132.0.35"}return t}getAlgorithmParameters(e,t){let r={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":r={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":r={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":r={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":r={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;case"exportkey":default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":r={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":r={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":r={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":r={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":switch(t.toLowerCase()){case"derivekey":r={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"HKDF"},usages:[]}}break;case"PBKDF2":switch(t.toLowerCase()){case"derivekey":r={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"PBKDF2"},usages:[]}}}return r}getHashAlgorithm(e){let t="";switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{const r=new Je({schema:e.algorithmParams});if("hashAlgorithm"in r){const e=this.getAlgorithmByOID(r.hashAlgorithm.algorithmId);if("name"in e==0)return"";t=e.name}else t="SHA-1"}catch(e){}}return t}encryptEncryptedContentInfo(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("contentEncryptionAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "contentEncryptionAlgorithm"');if("hmacHashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hmacHashAlgorithm"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("contentToEncrypt"in e==0)return Promise.reject('Absent mandatory parameter "contentToEncrypt"');if("contentType"in e==0)return Promise.reject('Absent mandatory parameter "contentType"');const t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm);if(""===t)return Promise.reject('Wrong "contentEncryptionAlgorithm" value');const r=this.getOIDByAlgorithm({name:"PBKDF2"});if(""===r)return Promise.reject("Can not find OID for PBKDF2");const s=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}});if(""===s)return Promise.reject(`Incorrect value for "hmacHashAlgorithm": ${e.hmacHashAlgorithm}`);let a=Promise.resolve();const n=new ArrayBuffer(16),i=new Uint8Array(n);this.getRandomValues(i);const o=new ArrayBuffer(64),l=new Uint8Array(o);this.getRandomValues(l);const c=new Uint8Array(e.contentToEncrypt),u=new $e({salt:new j({valueHex:o}),iterationCount:e.iterationCount,prf:new Ve({algorithmId:s,algorithmParams:new D})});return a=(a=(a=(a=a.then(()=>{const t=new Uint8Array(e.password);return this.importKey("raw",t,"PBKDF2",!1,["deriveKey"])},e=>Promise.reject(e))).then(t=>this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:l,iterations:e.iterationCount},t,e.contentEncryptionAlgorithm,!1,["encrypt"]),e=>Promise.reject(e))).then(t=>this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:i},t,c),e=>Promise.reject(e))).then(s=>{const a=new Fe({keyDerivationFunc:new Ve({algorithmId:r,algorithmParams:u.toSchema()}),encryptionScheme:new Ve({algorithmId:t,algorithmParams:new j({valueHex:n})})});return new Te({contentType:e.contentType,contentEncryptionAlgorithm:new Ve({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:a.toSchema()}),encryptedContent:new j({valueHex:s})})},e=>Promise.reject(e))}decryptEncryptedContentInfo(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("encryptedContentInfo"in e==0)return Promise.reject('Absent mandatory parameter "encryptedContentInfo"');if("1.2.840.113549.1.5.13"!==e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)return Promise.reject(`Unknown "contentEncryptionAlgorithm": ${e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);let t,r=Promise.resolve();try{t=new Fe({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(e){return Promise.reject('Incorrectly encoded "pbes2Parameters"')}let s;try{s=new $e({schema:t.keyDerivationFunc.algorithmParams})}catch(e){return Promise.reject('Incorrectly encoded "pbkdf2Params"')}const a=this.getAlgorithmByOID(t.encryptionScheme.algorithmId);if("name"in a==0)return Promise.reject(`Incorrect OID for "contentEncryptionAlgorithm": ${t.encryptionScheme.algorithmId}`);const n=t.encryptionScheme.algorithmParams.valueBlock.valueHex,i=new Uint8Array(n),o=s.salt.valueBlock.valueHex,l=new Uint8Array(o),c=s.iterationCount;let u="SHA-1";if("prf"in s){const e=this.getAlgorithmByOID(s.prf.algorithmId);if("name"in e==0)return Promise.reject("Incorrect OID for HMAC hash algorithm");u=e.hash.name}return r=(r=(r=r.then(()=>this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),e=>Promise.reject(e))).then(e=>this.deriveKey({name:"PBKDF2",hash:{name:u},salt:l,iterations:c},e,a,!1,["decrypt"]),e=>Promise.reject(e))).then(t=>{let r=new ArrayBuffer(0);if(!1===e.encryptedContentInfo.encryptedContent.idBlock.isConstructed)r=e.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else for(const t of e.encryptedContentInfo.encryptedContent.valueBlock.value)r=Ae(r,t.valueBlock.valueHex);return this.decrypt({name:a.name,iv:i},t,r)},e=>Promise.reject(e))}stampDataWithPassword(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToStamp"in e==0)return Promise.reject('Absent mandatory parameter "contentToStamp"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let r=Promise.resolve();const s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return r=(r=(r=r.then(()=>Me(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount))).then(e=>this.importKey("raw",new Uint8Array(e),s,!1,["sign"]))).then(t=>this.sign(s,t,new Uint8Array(e.contentToStamp)),e=>Promise.reject(e))}verifyDataStampedWithPassword(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToVerify"in e==0)return Promise.reject('Absent mandatory parameter "contentToVerify"');if("signatureToVerify"in e==0)return Promise.reject('Absent mandatory parameter "signatureToVerify"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject(`Incorrect "parameters.hashAlgorithm" parameter: ${e.hashAlgorithm}`)}let r=Promise.resolve();const s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return r=(r=(r=r.then(()=>Me(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount))).then(e=>this.importKey("raw",new Uint8Array(e),s,!1,["verify"]))).then(t=>this.verify(s,t,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify)),e=>Promise.reject(e))}getSignatureParameters(e,t="SHA-1"){const r=this.getOIDByAlgorithm({name:t});if(""===r)return Promise.reject(`Unsupported hash algorithm: ${t}`);const s=new Ve,a=this.getAlgorithmParameters(e.algorithm.name,"sign");switch(a.algorithm.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":s.algorithmId=this.getOIDByAlgorithm(a.algorithm);break;case"RSA-PSS":{switch(t.toUpperCase()){case"SHA-256":a.algorithm.saltLength=32;break;case"SHA-384":a.algorithm.saltLength=48;break;case"SHA-512":a.algorithm.saltLength=64}const e={};if("SHA-1"!==t.toUpperCase()){const r=this.getOIDByAlgorithm({name:t});if(""===r)return Promise.reject(`Unsupported hash algorithm: ${t}`);e.hashAlgorithm=new Ve({algorithmId:r,algorithmParams:new D}),e.maskGenAlgorithm=new Ve({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:e.hashAlgorithm.toSchema()})}20!==a.algorithm.saltLength&&(e.saltLength=a.algorithm.saltLength);const r=new Je(e);s.algorithmId="1.2.840.113549.1.1.10",s.algorithmParams=r.toSchema()}break;default:return Promise.reject(`Unsupported signature algorithm: ${e.algorithm.name}`)}return Promise.resolve().then(()=>({signatureAlgorithm:s,parameters:a}))}signWithPrivateKey(e,t,r){return this.sign(r.algorithm,t,new Uint8Array(e)).then(e=>("ECDSA"===r.algorithm.name&&(e=function(e){if(e.byteLength%2!=0)return new ArrayBuffer(0);const t=e.byteLength/2,r=new ArrayBuffer(t);new Uint8Array(r).set(new Uint8Array(e,0,t));const s=new R({valueHex:r}),a=new ArrayBuffer(t);new Uint8Array(a).set(new Uint8Array(e,t,t));const n=new R({valueHex:a});return new x({value:[s.convertToDER(),n.convertToDER()]}).toBER(!1)}(e)),e),e=>Promise.reject(`Signing error: ${e}`))}verifyWithPublicKey(e,t,r,s){let a=Promise.resolve();const n=this.getHashAlgorithm(s);return""===n?Promise.reject(`Unsupported signature algorithm: ${s.algorithmId}`):a=(a=a.then(()=>{const e=this.getAlgorithmByOID(s.algorithmId);if("name"in e==="")return Promise.reject(`Unsupported public key algorithm: ${s.algorithmId}`);const t=this.getAlgorithmParameters(e.name,"importkey");if("hash"in t.algorithm&&(t.algorithm.hash.name=n),"ECDSA"===e.name){let e=!1;if("algorithmParams"in r.algorithm==1&&"idBlock"in r.algorithm.algorithmParams&&1===r.algorithm.algorithmParams.idBlock.tagClass&&6===r.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)return Promise.reject("Incorrect type for ECDSA public key parameters");const s=this.getAlgorithmByOID(r.algorithm.algorithmParams.valueBlock.toString());if("name"in s==0)return Promise.reject(`Unsupported named curve algorithm: ${r.algorithm.algorithmParams.valueBlock.toString()}`);t.algorithm.namedCurve=s.name}const a=r.toSchema().toBER(!1),i=new Uint8Array(a);return this.importKey("spki",i,t.algorithm,!0,t.usages)})).then(r=>{const a=this.getAlgorithmParameters(r.algorithm.name,"verify");"hash"in a.algorithm&&(a.algorithm.hash.name=n);let i=t.valueBlock.valueHex;if("ECDSA"===r.algorithm.name&&(i=Ye(ve(i).result)),"RSA-PSS"===r.algorithm.name){let e;try{e=new Je({schema:s.algorithmParams})}catch(e){return Promise.reject(e)}a.algorithm.saltLength="saltLength"in e?e.saltLength:20;let t="SHA-1";if("hashAlgorithm"in e){const r=this.getAlgorithmByOID(e.hashAlgorithm.algorithmId);if("name"in r==0)return Promise.reject(`Unrecognized hash algorithm: ${e.hashAlgorithm.algorithmId}`);t=r.name}a.algorithm.hash.name=t}return this.verify(a.algorithm,r,new Uint8Array(i),new Uint8Array(e))})}}({name:e,crypto:self.crypto,subtle:r})}}}();function _e(){if(null!==We.subtle)return We.subtle}function Ge(e){return We.subtle.getRandomValues(e)}function Qe(e){return We.subtle.getOIDByAlgorithm(e)}function ze(e,t){return We.subtle.getAlgorithmParameters(e,t)}function Ze(e){let t=!1,r="";const s=e.trim();for(let e=0;e<s.length;e++)32===s.charCodeAt(e)?!1===t&&(t=!0):(t&&(r+=" ",t=!1),r+=s[e]);return r.toLowerCase()}function Ye(e){if(e instanceof x==!1)return new ArrayBuffer(0);if(2!==e.valueBlock.value.length)return new ArrayBuffer(0);if(e.valueBlock.value[0]instanceof R==!1)return new ArrayBuffer(0);if(e.valueBlock.value[1]instanceof R==!1)return new ArrayBuffer(0);const t=e.valueBlock.value[0].convertFromDER(),r=e.valueBlock.value[1].convertFromDER();switch(!0){case t.valueBlock.valueHex.byteLength<r.valueBlock.valueHex.byteLength:{if(r.valueBlock.valueHex.byteLength-t.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=r.valueBlock.valueHex.byteLength,s=new Uint8Array(t.valueBlock.valueHex),a=new ArrayBuffer(e),n=new Uint8Array(a);return n.set(s,1),n[0]=0,Ae(a,r.valueBlock.valueHex)}case t.valueBlock.valueHex.byteLength>r.valueBlock.valueHex.byteLength:{if(t.valueBlock.valueHex.byteLength-r.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=t.valueBlock.valueHex.byteLength,s=new Uint8Array(r.valueBlock.valueHex),a=new ArrayBuffer(e),n=new Uint8Array(a);return n.set(s,1),n[0]=0,Ae(t.valueBlock.valueHex,a)}default:if(t.valueBlock.valueHex.byteLength%2){const e=t.valueBlock.valueHex.byteLength+1,s=new Uint8Array(t.valueBlock.valueHex),a=new ArrayBuffer(e),n=new Uint8Array(a);n.set(s,1),n[0]=0;const i=new Uint8Array(r.valueBlock.valueHex),o=new ArrayBuffer(e),l=new Uint8Array(o);return l.set(i,1),l[0]=0,Ae(a,o)}}return Ae(t.valueBlock.valueHex,r.valueBlock.valueHex)}function Xe(e){return We.subtle.getAlgorithmByOID(e)}function et(e){return We.subtle.getHashAlgorithm(e)}function tt(e,t,r,s){switch(e.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":break;default:return Promise.reject(`Unknown hash function: ${e}`)}if(t instanceof ArrayBuffer==!1)return Promise.reject('Please set "Zbuffer" as "ArrayBuffer"');if(0===t.byteLength)return Promise.reject('"Zbuffer" has zero length, error');if(s instanceof ArrayBuffer==!1)return Promise.reject('Please set "SharedInfo" as "ArrayBuffer"');if(r>255)return Promise.reject('Please set "Counter" variable to value less or equal to 255');const a=new ArrayBuffer(4),n=new Uint8Array(a);n[0]=0,n[1]=0,n[2]=0,n[3]=r;let i=new ArrayBuffer(0);const o=_e();return void 0===o?Promise.reject("Unable to create WebCrypto object"):(i=Ae(i=Ae(i=Ae(i,t),a),s),o.digest({name:e},i).then(e=>({counter:r,result:e})))}function rt(e,t,r,s){let a=0,n=1;const i=[];switch(e.toUpperCase()){case"SHA-1":a=160;break;case"SHA-256":a=256;break;case"SHA-384":a=384;break;case"SHA-512":a=512;break;default:return Promise.reject(`Unknown hash function: ${e}`)}if(t instanceof ArrayBuffer==!1)return Promise.reject('Please set "Zbuffer" as "ArrayBuffer"');if(0===t.byteLength)return Promise.reject('"Zbuffer" has zero length, error');if(s instanceof ArrayBuffer==!1)return Promise.reject('Please set "SharedInfo" as "ArrayBuffer"');const o=r/a;Math.floor(o)>0&&o-(n=Math.floor(o))>0&&n++;for(let r=1;r<=n;r++)i.push(tt(e,t,r,s));return Promise.all(i).then(e=>{let t=new ArrayBuffer(0),s=1,a=!0;for(;a;){a=!1;for(const r of e)if(r.counter===s){t=Ae(t,r.result),a=!0;break}s++}if(r>>=3,t.byteLength>r){const e=new ArrayBuffer(r),s=new Uint8Array(e),a=new Uint8Array(t);for(let e=0;e<r;e++)s[e]=a[e];return e}return t})}class st{constructor(e={}){this.type=be(e,"type",st.defaultValues("type")),this.value=be(e,"value",st.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return"";case"value":return{};default:throw new Error(`Invalid member name for AttributeTypeAndValue class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.type||""}),new de({name:t.value||""})]})}fromSchema(e){const t=we(e,e,st.schema({names:{type:"type",value:"typeValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ATTR_TYPE_AND_VALUE");this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new x({value:[new $({value:this.type}),this.value]})}toJSON(){const e={type:this.type};return 0!==Object.keys(this.value).length?e.value=this.value.toJSON():e.value=this.value,e}isEqual(e){if(e instanceof st){if(this.type!==e.type)return!1;if(this.value instanceof M&&e.value instanceof M||this.value instanceof q&&e.value instanceof q||this.value instanceof G&&e.value instanceof G||this.value instanceof Z&&e.value instanceof Z||this.value instanceof Y&&e.value instanceof Y||this.value instanceof X&&e.value instanceof X||this.value instanceof ee&&e.value instanceof ee||this.value instanceof te&&e.value instanceof te||this.value instanceof re&&e.value instanceof re||this.value instanceof se&&e.value instanceof se||this.value instanceof ae&&e.value instanceof ae||this.value instanceof ne&&e.value instanceof ne){const t=Ze(this.value.valueBlock.value),r=Ze(e.value.valueBlock.value);if(0!==t.localeCompare(r))return!1}else if(!1===Se(this.value.valueBeforeDecode,e.value.valueBeforeDecode))return!1;return!0}return e instanceof ArrayBuffer&&Se(this.value.valueBeforeDecode,e)}}class at{constructor(e={}){this.typesAndValues=be(e,"typesAndValues",at.defaultValues("typesAndValues")),this.valueBeforeDecode=be(e,"valueBeforeDecode",at.defaultValues("valueBeforeDecode")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"typesAndValues":return[];case"valueBeforeDecode":return new ArrayBuffer(0);default:throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"typesAndValues":return 0===t.length;case"valueBeforeDecode":return 0===t.byteLength;default:throw new Error(`Invalid member name for RelativeDistinguishedNames class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new ge({name:t.repeatedSequence||"",value:new V({value:[new ge({name:t.repeatedSet||"",value:st.schema(t.typeAndValue||{})})]})})]})}fromSchema(e){const t=we(e,e,at.schema({names:{blockName:"RDN",repeatedSet:"typesAndValues"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RDN");"typesAndValues"in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,e=>new st({schema:e}))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecode}toSchema(){if(0===this.valueBeforeDecode.byteLength)return new x({value:[new V({value:Array.from(this.typesAndValues,e=>e.toSchema())})]});const e=ve(this.valueBeforeDecode);return e.result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,e=>e.toJSON())}}isEqual(e){if(e instanceof at){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(const[t,r]of this.typesAndValues.entries())if(!1===r.isEqual(e.typesAndValues[t]))return!1;return!0}return e instanceof ArrayBuffer&&Se(this.valueBeforeDecode,e)}}class nt{constructor(e={}){this.type=be(e,"type",nt.defaultValues("type")),this.value=be(e,"value",nt.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return 9;case"value":return{};default:throw new Error(`Invalid member name for GeneralName class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"type":return t===nt.defaultValues(e);case"value":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for GeneralName class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new fe({value:[new I({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||"",value:[new $,new I({idBlock:{tagClass:3,tagNumber:0},value:[new de]})]}),new S({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:1}}),new S({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:2}}),new I({idBlock:{tagClass:3,tagNumber:3},name:t.blockName||"",value:[function(e={},t=!1){const r=be(e,"names",{});return new x({optional:t,value:[new I({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:r.country_name||"",value:[new fe({value:[new Z,new Y]})]}),new I({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:r.administration_domain_name||"",value:[new fe({value:[new Z,new Y]})]}),new S({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:r.network_address||"",isHexOnly:!0}),new S({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:r.terminal_identifier||"",isHexOnly:!0}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:r.private_domain_name||"",value:[new fe({value:[new Z,new Y]})]}),new S({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:r.organization_name||"",isHexOnly:!0}),new S({optional:!0,name:r.numeric_user_identifier||"",idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new I({optional:!0,name:r.personal_name||"",idBlock:{tagClass:3,tagNumber:5},value:[new S({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new S({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new S({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new S({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new I({optional:!0,name:r.organizational_unit_names||"",idBlock:{tagClass:3,tagNumber:6},value:[new ge({value:new Y})]})]})}(t.builtInStandardAttributes||{},!1),function(e=!1){return new x({optional:e,value:[new Y,new Y]})}(!0),function(e=!1){return new V({optional:e,value:[new S({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new de]})]})}(!0)]}),new I({idBlock:{tagClass:3,tagNumber:4},name:t.blockName||"",value:[at.schema(t.directoryName||{})]}),new I({idBlock:{tagClass:3,tagNumber:5},name:t.blockName||"",value:[new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new fe({value:[new X,new Y,new G,new M,new q]})]}),new I({idBlock:{tagClass:3,tagNumber:1},value:[new fe({value:[new X,new Y,new G,new M,new q]})]})]}),new S({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:6}}),new S({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:7}}),new S({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){const t=we(e,e,nt.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GENERAL_NAME");switch(this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:this.value=t.result.blockName;break;case 1:case 2:case 6:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=22;const r=e.toBER(!1);this.value=ve(r).result.valueBlock.value}break;case 3:this.value=t.result.blockName;break;case 4:this.value=new at({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new j({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=6;const r=e.toBER(!1);this.value=ve(r).result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new I({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{const e=new te({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new I({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{const e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{const e=new $({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return nt.schema()}}toJSON(){const e={type:this.type};return"string"==typeof this.value?e.value=this.value:e.value=this.value.toJSON(),e}}class it{constructor(e={}){this.accessMethod=be(e,"accessMethod",it.defaultValues("accessMethod")),this.accessLocation=be(e,"accessLocation",it.defaultValues("accessLocation")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"accessMethod":return"";case"accessLocation":return new nt;default:throw new Error(`Invalid member name for AccessDescription class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.accessMethod||""}),nt.schema(t.accessLocation||{})]})}fromSchema(e){const t=we(e,e,it.schema({names:{accessMethod:"accessMethod",accessLocation:{names:{blockName:"accessLocation"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AccessDescription");this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new nt({schema:t.result.accessLocation})}toSchema(){return new x({value:[new $({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}class ot{constructor(e={}){"seconds"in e&&(this.seconds=be(e,"seconds",ot.defaultValues("seconds"))),"millis"in e&&(this.millis=be(e,"millis",ot.defaultValues("millis"))),"micros"in e&&(this.micros=be(e,"micros",ot.defaultValues("micros"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"seconds":case"millis":case"micros":return 0;default:throw new Error(`Invalid member name for Accuracy class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"seconds":case"millis":case"micros":return t===ot.defaultValues(e);default:throw new Error(`Invalid member name for Accuracy class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",optional:!0,value:[new R({optional:!0,name:t.seconds||""}),new S({name:t.millis||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new S({name:t.micros||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){const t=we(e,e,ot.schema({names:{seconds:"seconds",millis:"millis",micros:"micros"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for tsp.Accuracy");if("seconds"in t.result&&(this.seconds=t.result.seconds.valueBlock.valueDec),"millis"in t.result){const e=new R({valueHex:t.result.millis.valueBlock.valueHex});this.millis=e.valueBlock.valueDec}if("micros"in t.result){const e=new R({valueHex:t.result.micros.valueBlock.valueHex});this.micros=e.valueBlock.valueDec}}toSchema(){const e=[];if("seconds"in this&&e.push(new R({value:this.seconds})),"millis"in this){const t=new R({value:this.millis});e.push(new S({idBlock:{tagClass:3,tagNumber:0},valueHex:t.valueBlock.valueHex}))}if("micros"in this){const t=new R({value:this.micros});e.push(new S({idBlock:{tagClass:3,tagNumber:1},valueHex:t.valueBlock.valueHex}))}return new x({value:e})}toJSON(){const e={};return"seconds"in this&&(e.seconds=this.seconds),"millis"in this&&(e.millis=this.millis),"micros"in this&&(e.micros=this.micros),e}}class lt{constructor(e={}){this.altNames=be(e,"altNames",lt.defaultValues("altNames")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"altNames":return[];default:throw new Error(`Invalid member name for AltName class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new ge({name:t.altNames||"",value:nt.schema()})]})}fromSchema(e){const t=we(e,e,lt.schema({names:{altNames:"altNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AltName");"altNames"in t.result&&(this.altNames=Array.from(t.result.altNames,e=>new nt({schema:e})))}toSchema(){return new x({value:Array.from(this.altNames,e=>e.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,e=>e.toJSON())}}}class ct{constructor(e={}){this.contentType=be(e,"contentType",ct.defaultValues("contentType")),this.content=be(e,"content",ct.defaultValues("content")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"contentType":return"";case"content":return new de;default:throw new Error(`Invalid member name for ContentInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"contentType":return""===t;case"content":return t instanceof de;default:throw new Error(`Invalid member name for ContentInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return"optional"in t==!1&&(t.optional=!1),new x({name:t.blockName||"ContentInfo",optional:t.optional,value:[new $({name:t.contentType||"contentType"}),new I({idBlock:{tagClass:3,tagNumber:0},value:[new de({name:t.content||"content"})]})]})}fromSchema(e){const t=we(e,e,ct.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CMS_CONTENT_INFO");this.contentType=t.result.contentType.valueBlock.toString(),this.content=t.result.content}toSchema(){return new x({value:[new $({value:this.contentType}),new I({idBlock:{tagClass:3,tagNumber:0},value:[this.content]})]})}toJSON(){const e={contentType:this.contentType};return this.content instanceof de||(e.content=this.content.toJSON()),e}}class ut{constructor(e={}){this.version=be(e,"version",ut.defaultValues("version")),this.encryptedContentInfo=be(e,"encryptedContentInfo",ut.defaultValues("encryptedContentInfo")),"unprotectedAttrs"in e&&(this.unprotectedAttrs=be(e,"unprotectedAttrs",ut.defaultValues("unprotectedAttrs"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"encryptedContentInfo":return new Te;case"unprotectedAttrs":return[];default:throw new Error(`Invalid member name for EncryptedData class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return 0===t;case"encryptedContentInfo":return Te.compareWithDefault("contentType",t.contentType)&&Te.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&Te.compareWithDefault("encryptedContent",t.encryptedContent);case"unprotectedAttrs":return 0===t.length;default:throw new Error(`Invalid member name for EncryptedData class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.version||""}),Te.schema(t.encryptedContentInfo||{}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ge({name:t.unprotectedAttrs||"",value:He.schema()})]})]})}fromSchema(e){const t=we(e,e,ut.schema({names:{version:"version",encryptedContentInfo:{names:{blockName:"encryptedContentInfo"}},unprotectedAttrs:"unprotectedAttrs"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CMS_ENCRYPTED_DATA");this.version=t.result.version.valueBlock.valueDec,this.encryptedContentInfo=new Te({schema:t.result.encryptedContentInfo}),"unprotectedAttrs"in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,e=>new He({schema:e})))}toSchema(){const e=[];return e.push(new R({value:this.version})),e.push(this.encryptedContentInfo.toSchema()),"unprotectedAttrs"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,e=>e.toSchema())})),new x({value:e})}toJSON(){const e={version:this.version,encryptedContentInfo:this.encryptedContentInfo.toJSON()};return"unprotectedAttrs"in this&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,e=>e.toJSON())),e}encrypt(e){if(e instanceof Object==!1)return Promise.reject('Parameters must have type "Object"');const t=qe();return void 0===t?Promise.reject("Unable to initialize cryptographic engine"):(e.contentType="1.2.840.113549.1.7.1","encryptEncryptedContentInfo"in t.subtle?t.subtle.encryptEncryptedContentInfo(e).then(e=>{this.encryptedContentInfo=e}):Promise.reject(`No support for "encryptEncryptedContentInfo" in current crypto engine ${t.name}`))}decrypt(e){if(e instanceof Object==!1)return Promise.reject('Parameters must have type "Object"');const t=qe();return void 0===t?Promise.reject("Unable to initialize cryptographic engine"):(e.encryptedContentInfo=this.encryptedContentInfo,"decryptEncryptedContentInfo"in t.subtle?t.subtle.decryptEncryptedContentInfo(e):Promise.reject(`No support for "decryptEncryptedContentInfo" in current crypto engine ${t.name}`))}}class ht{constructor(e={}){this.encryptionAlgorithm=be(e,"encryptionAlgorithm",ht.defaultValues("encryptionAlgorithm")),this.encryptedData=be(e,"encryptedData",ht.defaultValues("encryptedData")),"parsedValue"in e&&(this.parsedValue=be(e,"parsedValue",ht.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"encryptionAlgorithm":return new Ve;case"encryptedData":return new j;case"parsedValue":return{};default:throw new Error(`Invalid member name for PKCS8ShroudedKeyBag class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"encryptionAlgorithm":return Ve.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case"encryptedData":return t.isEqual(ht.defaultValues(e));case"parsedValue":return t instanceof Object&&0===Object.keys(t).length;default:throw new Error(`Invalid member name for PKCS8ShroudedKeyBag class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[Ve.schema(t.encryptionAlgorithm||{names:{blockName:"encryptionAlgorithm"}}),new fe({value:[new j({name:t.encryptedData||"encryptedData"}),new j({idBlock:{isConstructed:!0},name:t.encryptedData||"encryptedData"})]})]})}fromSchema(e){const t=we(e,e,ht.schema({names:{encryptionAlgorithm:{names:{blockName:"encryptionAlgorithm"}},encryptedData:"encryptedData"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PKCS8ShroudedKeyBag");this.encryptionAlgorithm=new Ve({schema:t.result.encryptionAlgorithm}),this.encryptedData=t.result.encryptedData}toSchema(){return new x({value:[this.encryptionAlgorithm.toSchema(),this.encryptedData]})}toJSON(){return{encryptionAlgorithm:this.encryptionAlgorithm.toJSON(),encryptedData:this.encryptedData.toJSON()}}parseInternalValues(e){let t=Promise.resolve();const r=new ut({encryptedContentInfo:new Te({contentEncryptionAlgorithm:this.encryptionAlgorithm,encryptedContent:this.encryptedData})});return t=(t=t.then(()=>r.decrypt(e),e=>Promise.reject(e))).then(e=>{const t=ve(e);if(-1===t.offset)return Promise.reject("Error during parsing ASN.1 data");this.parsedValue=new Le({schema:t.result})},e=>Promise.reject(e))}makeInternalValues(e){if("parsedValue"in this==!1)return Promise.reject('Please initialize "parsedValue" first');let t=Promise.resolve();const r=new ut;return t=(t=t.then(()=>(e.contentToEncrypt=this.parsedValue.toSchema().toBER(!1),r.encrypt(e)),e=>Promise.reject(e))).then(()=>{this.encryptionAlgorithm=r.encryptedContentInfo.contentEncryptionAlgorithm,this.encryptedData=r.encryptedContentInfo.encryptedContent})}}class mt{constructor(e={}){this.type=be(e,"type",mt.defaultValues("type")),this.value=be(e,"value",mt.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return 0;case"value":return new Date(0,0,0);default:throw new Error(`Invalid member name for Time class: ${e}`)}}static schema(e={},t=!1){const r=be(e,"names",{});return new fe({optional:t,value:[new ie({name:r.utcTimeName||""}),new oe({name:r.generalTimeName||""})]})}fromSchema(e){const t=we(e,e,mt.schema({names:{utcTimeName:"utcTimeName",generalTimeName:"generalTimeName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for TIME");"utcTimeName"in t.result&&(this.type=0,this.value=t.result.utcTimeName.toDate()),"generalTimeName"in t.result&&(this.type=1,this.value=t.result.generalTimeName.toDate())}toSchema(){let e={};return 0===this.type&&(e=new ie({valueDate:this.value})),1===this.type&&(e=new oe({valueDate:this.value})),e}toJSON(){return{type:this.type,value:this.value}}}class ft{constructor(e={}){this.attributes=be(e,"attributes",ft.defaultValues("attributes")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"attributes":return[];default:throw new Error(`Invalid member name for SubjectDirectoryAttributes class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new ge({name:t.attributes||"",value:He.schema()})]})}fromSchema(e){const t=we(e,e,ft.schema({names:{attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SubjectDirectoryAttributes");this.attributes=Array.from(t.result.attributes,e=>new He({schema:e}))}toSchema(){return new x({value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,e=>e.toJSON())}}}class dt{constructor(e={}){"notBefore"in e&&(this.notBefore=be(e,"notBefore",dt.defaultValues("notBefore"))),"notAfter"in e&&(this.notAfter=be(e,"notAfter",dt.defaultValues("notAfter"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"notBefore":case"notAfter":return new Date;default:throw new Error(`Invalid member name for PrivateKeyUsagePeriod class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new S({name:t.notBefore||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new S({name:t.notAfter||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){const t=we(e,e,dt.schema({names:{notBefore:"notBefore",notAfter:"notAfter"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyUsagePeriod");if("notBefore"in t.result){const e=new oe;e.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=e.toDate()}if("notAfter"in t.result){const e=new oe({valueHex:t.result.notAfter.valueBlock.valueHex});e.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=e.toDate()}}toSchema(){const e=[];return"notBefore"in this&&e.push(new S({idBlock:{tagClass:3,tagNumber:0},valueHex:new oe({valueDate:this.notBefore}).valueBlock.valueHex})),"notAfter"in this&&e.push(new S({idBlock:{tagClass:3,tagNumber:1},valueHex:new oe({valueDate:this.notAfter}).valueBlock.valueHex})),new x({value:e})}toJSON(){const e={};return"notBefore"in this&&(e.notBefore=this.notBefore),"notAfter"in this&&(e.notAfter=this.notAfter),e}}class gt{constructor(e={}){this.cA=be(e,"cA",!1),"pathLenConstraint"in e&&(this.pathLenConstraint=be(e,"pathLenConstraint",0)),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"cA":return!1;default:throw new Error(`Invalid member name for BasicConstraints class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new E({optional:!0,name:t.cA||""}),new R({optional:!0,name:t.pathLenConstraint||""})]})}fromSchema(e){const t=we(e,e,gt.schema({names:{cA:"cA",pathLenConstraint:"pathLenConstraint"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for BasicConstraints");"cA"in t.result&&(this.cA=t.result.cA.valueBlock.value),"pathLenConstraint"in t.result&&(t.result.pathLenConstraint.valueBlock.isHexOnly?this.pathLenConstraint=t.result.pathLenConstraint:this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){const e=[];return this.cA!==gt.defaultValues("cA")&&e.push(new E({value:this.cA})),"pathLenConstraint"in this&&(this.pathLenConstraint instanceof R?e.push(this.pathLenConstraint):e.push(new R({value:this.pathLenConstraint}))),new x({value:e})}toJSON(){const e={};return this.cA!==gt.defaultValues("cA")&&(e.cA=this.cA),"pathLenConstraint"in this&&(this.pathLenConstraint instanceof R?e.pathLenConstraint=this.pathLenConstraint.toJSON():e.pathLenConstraint=this.pathLenConstraint),e}}class pt{constructor(e={}){"distributionPoint"in e&&(this.distributionPoint=be(e,"distributionPoint",pt.defaultValues("distributionPoint"))),this.onlyContainsUserCerts=be(e,"onlyContainsUserCerts",pt.defaultValues("onlyContainsUserCerts")),this.onlyContainsCACerts=be(e,"onlyContainsCACerts",pt.defaultValues("onlyContainsCACerts")),"onlySomeReasons"in e&&(this.onlySomeReasons=be(e,"onlySomeReasons",pt.defaultValues("onlySomeReasons"))),this.indirectCRL=be(e,"indirectCRL",pt.defaultValues("indirectCRL")),this.onlyContainsAttributeCerts=be(e,"onlyContainsAttributeCerts",pt.defaultValues("onlyContainsAttributeCerts")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"onlyContainsUserCerts":case"onlyContainsCACerts":return!1;case"onlySomeReasons":return 0;case"indirectCRL":case"onlyContainsAttributeCerts":return!1;default:throw new Error(`Invalid member name for IssuingDistributionPoint class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new fe({value:[new I({name:t.distributionPoint||"",idBlock:{tagClass:3,tagNumber:0},value:[new ge({name:t.distributionPointNames||"",value:nt.schema()})]}),new I({name:t.distributionPoint||"",idBlock:{tagClass:3,tagNumber:1},value:at.schema().valueBlock.value})]})]}),new S({name:t.onlyContainsUserCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new S({name:t.onlyContainsCACerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new S({name:t.onlySomeReasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new S({name:t.indirectCRL||"",optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new S({name:t.onlyContainsAttributeCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){const t=we(e,e,pt.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",onlyContainsUserCerts:"onlyContainsUserCerts",onlyContainsCACerts:"onlyContainsCACerts",onlySomeReasons:"onlySomeReasons",indirectCRL:"indirectCRL",onlyContainsAttributeCerts:"onlyContainsAttributeCerts"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for IssuingDistributionPoint");if("distributionPoint"in t.result)switch(!0){case 0===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new nt({schema:e}));break;case 1===t.result.distributionPoint.idBlock.tagNumber:t.result.distributionPoint.idBlock.tagClass=1,t.result.distributionPoint.idBlock.tagNumber=16,this.distributionPoint=new at({schema:t.result.distributionPoint});break;default:throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if("onlyContainsUserCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==e[0]}if("onlyContainsCACerts"in t.result){const e=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==e[0]}if("onlySomeReasons"in t.result){const e=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=e[0]}if("indirectCRL"in t.result){const e=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==e[0]}if("onlyContainsAttributeCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==e[0]}}toSchema(){const e=[];if("distributionPoint"in this){let t;this.distributionPoint instanceof Array?t=new I({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):((t=this.distributionPoint.toSchema()).idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(t)}if(this.onlyContainsUserCerts!==pt.defaultValues("onlyContainsUserCerts")&&e.push(new S({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==pt.defaultValues("onlyContainsCACerts")&&e.push(new S({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),"onlySomeReasons"in this){const t=new ArrayBuffer(1);new Uint8Array(t)[0]=this.onlySomeReasons,e.push(new S({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==pt.defaultValues("indirectCRL")&&e.push(new S({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==pt.defaultValues("onlyContainsAttributeCerts")&&e.push(new S({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new x({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==pt.defaultValues("onlyContainsUserCerts")&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==pt.defaultValues("onlyContainsCACerts")&&(e.onlyContainsCACerts=this.onlyContainsCACerts),"onlySomeReasons"in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==pt.defaultValues("indirectCRL")&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==pt.defaultValues("onlyContainsAttributeCerts")&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}}class yt{constructor(e={}){this.names=be(e,"names",yt.defaultValues("names")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"names":return[];default:throw new Error(`Invalid member name for GeneralNames class: ${e}`)}}static schema(e={},t=!1){const r=be(e,"names",{});return new x({optional:t,name:r.blockName||"",value:[new ge({name:r.generalNames||"",value:nt.schema()})]})}fromSchema(e){const t=we(e,e,yt.schema({names:{blockName:"names",generalNames:"generalNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralNames");this.names=Array.from(t.result.generalNames,e=>new nt({schema:e}))}toSchema(){return new x({value:Array.from(this.names,e=>e.toSchema())})}toJSON(){return{names:Array.from(this.names,e=>e.toJSON())}}}class vt{constructor(e={}){this.base=be(e,"base",vt.defaultValues("base")),this.minimum=be(e,"minimum",vt.defaultValues("minimum")),"maximum"in e&&(this.maximum=be(e,"maximum",vt.defaultValues("maximum"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"base":return new nt;case"minimum":case"maximum":return 0;default:throw new Error(`Invalid member name for GeneralSubtree class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[nt.schema(t.base||{}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new R({name:t.minimum||""})]}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new R({name:t.maximum||""})]})]})}fromSchema(e){const t=we(e,e,vt.schema({names:{base:{names:{blockName:"base"}},minimum:"minimum",maximum:"maximum"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ");this.base=new nt({schema:t.result.base}),"minimum"in t.result&&(t.result.minimum.valueBlock.isHexOnly?this.minimum=t.result.minimum:this.minimum=t.result.minimum.valueBlock.valueDec),"maximum"in t.result&&(t.result.maximum.valueBlock.isHexOnly?this.maximum=t.result.maximum:this.maximum=t.result.maximum.valueBlock.valueDec)}toSchema(){const e=[];if(e.push(this.base.toSchema()),0!==this.minimum){let t=0;t=this.minimum instanceof R?this.minimum:new R({value:this.minimum}),e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if("maximum"in this){let t=0;t=this.maximum instanceof R?this.maximum:new R({value:this.maximum}),e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new x({value:e})}toJSON(){const e={base:this.base.toJSON()};return 0!==this.minimum&&("number"==typeof this.minimum?e.minimum=this.minimum:e.minimum=this.minimum.toJSON()),"maximum"in this&&("number"==typeof this.maximum?e.maximum=this.maximum:e.maximum=this.maximum.toJSON()),e}}class wt{constructor(e={}){"permittedSubtrees"in e&&(this.permittedSubtrees=be(e,"permittedSubtrees",wt.defaultValues("permittedSubtrees"))),"excludedSubtrees"in e&&(this.excludedSubtrees=be(e,"excludedSubtrees",wt.defaultValues("excludedSubtrees"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"permittedSubtrees":case"excludedSubtrees":return[];default:throw new Error(`Invalid member name for NameConstraints class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ge({name:t.permittedSubtrees||"",value:vt.schema()})]}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ge({name:t.excludedSubtrees||"",value:vt.schema()})]})]})}fromSchema(e){const t=we(e,e,wt.schema({names:{permittedSubtrees:"permittedSubtrees",excludedSubtrees:"excludedSubtrees"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for NameConstraints");"permittedSubtrees"in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,e=>new vt({schema:e}))),"excludedSubtrees"in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,e=>new vt({schema:e})))}toSchema(){const e=[];return"permittedSubtrees"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new x({value:Array.from(this.permittedSubtrees,e=>e.toSchema())})]})),"excludedSubtrees"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new x({value:Array.from(this.excludedSubtrees,e=>e.toSchema())})]})),new x({value:e})}toJSON(){const e={};return"permittedSubtrees"in this&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,e=>e.toJSON())),"excludedSubtrees"in this&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,e=>e.toJSON())),e}}class bt{constructor(e={}){"distributionPoint"in e&&(this.distributionPoint=be(e,"distributionPoint",bt.defaultValues("distributionPoint"))),"reasons"in e&&(this.reasons=be(e,"reasons",bt.defaultValues("reasons"))),"cRLIssuer"in e&&(this.cRLIssuer=be(e,"cRLIssuer",bt.defaultValues("cRLIssuer"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"reasons":return new K;case"cRLIssuer":return[];default:throw new Error(`Invalid member name for DistributionPoint class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new fe({value:[new I({name:t.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new ge({name:t.distributionPointNames||"",value:nt.schema()})]}),new I({name:t.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:at.schema().valueBlock.value})]})]}),new S({name:t.reasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new I({name:t.cRLIssuer||"",optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new ge({name:t.cRLIssuerNames||"",value:nt.schema()})]})]})}fromSchema(e){const t=we(e,e,bt.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",reasons:"reasons",cRLIssuer:"cRLIssuer",cRLIssuerNames:"cRLIssuerNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for DistributionPoint");"distributionPoint"in t.result&&(0===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new nt({schema:e}))),1===t.result.distributionPoint.idBlock.tagNumber&&(t.result.distributionPoint.idBlock.tagClass=1,t.result.distributionPoint.idBlock.tagNumber=16,this.distributionPoint=new at({schema:t.result.distributionPoint}))),"reasons"in t.result&&(this.reasons=new K({valueHex:t.result.reasons.valueBlock.valueHex})),"cRLIssuer"in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,e=>new nt({schema:e})))}toSchema(){const e=[];if("distributionPoint"in this){let t;t=this.distributionPoint instanceof Array?new I({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):new I({idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new I({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return"reasons"in this&&e.push(new S({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHex})),"cRLIssuer"in this&&e.push(new I({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,e=>e.toSchema())})),new x({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(this.distributionPoint instanceof Array?e.distributionPoint=Array.from(this.distributionPoint,e=>e.toJSON()):e.distributionPoint=this.distributionPoint.toJSON()),"reasons"in this&&(e.reasons=this.reasons.toJSON()),"cRLIssuer"in this&&(e.cRLIssuer=Array.from(this.cRLIssuer,e=>e.toJSON())),e}}class kt{constructor(e={}){this.distributionPoints=be(e,"distributionPoints",kt.defaultValues("distributionPoints")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoints":return[];default:throw new Error(`Invalid member name for CRLDistributionPoints class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new ge({name:t.distributionPoints||"",value:bt.schema()})]})}fromSchema(e){const t=we(e,e,kt.schema({names:{distributionPoints:"distributionPoints"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CRLDistributionPoints");this.distributionPoints=Array.from(t.result.distributionPoints,e=>new bt({schema:e}))}toSchema(){return new x({value:Array.from(this.distributionPoints,e=>e.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,e=>e.toJSON())}}}class At{constructor(e={}){this.policyQualifierId=be(e,"policyQualifierId",At.defaultValues("policyQualifierId")),this.qualifier=be(e,"qualifier",At.defaultValues("qualifier")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"policyQualifierId":return"";case"qualifier":return new de;default:throw new Error(`Invalid member name for PolicyQualifierInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.policyQualifierId||""}),new de({name:t.qualifier||""})]})}fromSchema(e){const t=we(e,e,At.schema({names:{policyQualifierId:"policyQualifierId",qualifier:"qualifier"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyQualifierInfo");this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new x({value:[new $({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}class St{constructor(e={}){this.policyIdentifier=be(e,"policyIdentifier",St.defaultValues("policyIdentifier")),"policyQualifiers"in e&&(this.policyQualifiers=be(e,"policyQualifiers",St.defaultValues("policyQualifiers"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"policyIdentifier":return"";case"policyQualifiers":return[];default:throw new Error(`Invalid member name for PolicyInformation class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.policyIdentifier||""}),new x({optional:!0,value:[new ge({name:t.policyQualifiers||"",value:At.schema()})]})]})}fromSchema(e){const t=we(e,e,St.schema({names:{policyIdentifier:"policyIdentifier",policyQualifiers:"policyQualifiers"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyInformation");this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),"policyQualifiers"in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,e=>new At({schema:e})))}toSchema(){const e=[];return e.push(new $({value:this.policyIdentifier})),"policyQualifiers"in this&&e.push(new x({value:Array.from(this.policyQualifiers,e=>e.toSchema())})),new x({value:e})}toJSON(){const e={policyIdentifier:this.policyIdentifier};return"policyQualifiers"in this&&(e.policyQualifiers=Array.from(this.policyQualifiers,e=>e.toJSON())),e}}class Ct{constructor(e={}){this.certificatePolicies=be(e,"certificatePolicies",Ct.defaultValues("certificatePolicies")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certificatePolicies":return[];default:throw new Error(`Invalid member name for CertificatePolicies class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new ge({name:t.certificatePolicies||"",value:St.schema()})]})}fromSchema(e){const t=we(e,e,Ct.schema({names:{certificatePolicies:"certificatePolicies"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificatePolicies");this.certificatePolicies=Array.from(t.result.certificatePolicies,e=>new St({schema:e}))}toSchema(){return new x({value:Array.from(this.certificatePolicies,e=>e.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,e=>e.toJSON())}}}class It{constructor(e={}){this.issuerDomainPolicy=be(e,"issuerDomainPolicy",It.defaultValues("issuerDomainPolicy")),this.subjectDomainPolicy=be(e,"subjectDomainPolicy",It.defaultValues("subjectDomainPolicy")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"issuerDomainPolicy":case"subjectDomainPolicy":return"";default:throw new Error(`Invalid member name for PolicyMapping class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.issuerDomainPolicy||""}),new $({name:t.subjectDomainPolicy||""})]})}fromSchema(e){const t=we(e,e,It.schema({names:{issuerDomainPolicy:"issuerDomainPolicy",subjectDomainPolicy:"subjectDomainPolicy"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMapping");this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new x({value:[new $({value:this.issuerDomainPolicy}),new $({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}class Bt{constructor(e={}){this.mappings=be(e,"mappings",Bt.defaultValues("mappings")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"mappings":return[];default:throw new Error(`Invalid member name for PolicyMappings class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new ge({name:t.mappings||"",value:It.schema()})]})}fromSchema(e){const t=we(e,e,Bt.schema({names:{mappings:"mappings"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMappings");this.mappings=Array.from(t.result.mappings,e=>new It({schema:e}))}toSchema(){return new x({value:Array.from(this.mappings,e=>e.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,e=>e.toJSON())}}}class Nt{constructor(e={}){"keyIdentifier"in e&&(this.keyIdentifier=be(e,"keyIdentifier",Nt.defaultValues("keyIdentifier"))),"authorityCertIssuer"in e&&(this.authorityCertIssuer=be(e,"authorityCertIssuer",Nt.defaultValues("authorityCertIssuer"))),"authorityCertSerialNumber"in e&&(this.authorityCertSerialNumber=be(e,"authorityCertSerialNumber",Nt.defaultValues("authorityCertSerialNumber"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyIdentifier":return new j;case"authorityCertIssuer":return[];case"authorityCertSerialNumber":return new R;default:throw new Error(`Invalid member name for AuthorityKeyIdentifier class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new S({name:t.keyIdentifier||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ge({name:t.authorityCertIssuer||"",value:nt.schema()})]}),new S({name:t.authorityCertSerialNumber||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){const t=we(e,e,Nt.schema({names:{keyIdentifier:"keyIdentifier",authorityCertIssuer:"authorityCertIssuer",authorityCertSerialNumber:"authorityCertSerialNumber"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AuthorityKeyIdentifier");"keyIdentifier"in t.result&&(this.keyIdentifier=new j({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,e=>new nt({schema:e}))),"authorityCertSerialNumber"in t.result&&(this.authorityCertSerialNumber=new R({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){const e=[];if("keyIdentifier"in this){const t=this.keyIdentifier;t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if("authorityCertIssuer"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,e=>e.toSchema())})),"authorityCertSerialNumber"in this){const t=this.authorityCertSerialNumber;t.idBlock.tagClass=3,t.idBlock.tagNumber=2,e.push(t)}return new x({value:e})}toJSON(){const e={};return"keyIdentifier"in this&&(e.keyIdentifier=this.keyIdentifier.toJSON()),"authorityCertIssuer"in this&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,e=>e.toJSON())),"authorityCertSerialNumber"in this&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}}class Pt{constructor(e={}){"requireExplicitPolicy"in e&&(this.requireExplicitPolicy=be(e,"requireExplicitPolicy",Pt.defaultValues("requireExplicitPolicy"))),"inhibitPolicyMapping"in e&&(this.inhibitPolicyMapping=be(e,"inhibitPolicyMapping",Pt.defaultValues("inhibitPolicyMapping"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"requireExplicitPolicy":case"inhibitPolicyMapping":return 0;default:throw new Error(`Invalid member name for PolicyConstraints class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new S({name:t.requireExplicitPolicy||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new S({name:t.inhibitPolicyMapping||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){const t=we(e,e,Pt.schema({names:{requireExplicitPolicy:"requireExplicitPolicy",inhibitPolicyMapping:"inhibitPolicyMapping"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyConstraints");if("requireExplicitPolicy"in t.result){const e=t.result.requireExplicitPolicy;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=ve(e.toBER(!1));this.requireExplicitPolicy=r.result.valueBlock.valueDec}if("inhibitPolicyMapping"in t.result){const e=t.result.inhibitPolicyMapping;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=ve(e.toBER(!1));this.inhibitPolicyMapping=r.result.valueBlock.valueDec}}toSchema(){const e=[];if("requireExplicitPolicy"in this){const t=new R({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if("inhibitPolicyMapping"in this){const t=new R({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new x({value:e})}toJSON(){const e={};return"requireExplicitPolicy"in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),"inhibitPolicyMapping"in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}}class Et{constructor(e={}){this.keyPurposes=be(e,"keyPurposes",Et.defaultValues("keyPurposes")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyPurposes":return[];default:throw new Error(`Invalid member name for ExtKeyUsage class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new ge({name:t.keyPurposes||"",value:new $})]})}fromSchema(e){const t=we(e,e,Et.schema({names:{keyPurposes:"keyPurposes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ExtKeyUsage");this.keyPurposes=Array.from(t.result.keyPurposes,e=>e.valueBlock.toString())}toSchema(){return new x({value:Array.from(this.keyPurposes,e=>new $({value:e}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}class xt{constructor(e={}){this.accessDescriptions=be(e,"accessDescriptions",xt.defaultValues("accessDescriptions")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"accessDescriptions":return[];default:throw new Error(`Invalid member name for InfoAccess class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new ge({name:t.accessDescriptions||"",value:it.schema()})]})}fromSchema(e){const t=we(e,e,xt.schema({names:{accessDescriptions:"accessDescriptions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for InfoAccess");this.accessDescriptions=Array.from(t.result.accessDescriptions,e=>new it({schema:e}))}toSchema(){return new x({value:Array.from(this.accessDescriptions,e=>e.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,e=>e.toJSON())}}}class Vt{constructor(e={}){this.extnID=be(e,"extnID",Vt.defaultValues("extnID")),this.critical=be(e,"critical",Vt.defaultValues("critical")),this.extnValue="extnValue"in e?new j({valueHex:e.extnValue}):Vt.defaultValues("extnValue"),"parsedValue"in e&&(this.parsedValue=be(e,"parsedValue",Vt.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"extnID":return"";case"critical":return!1;case"extnValue":return new j;case"parsedValue":return{};default:throw new Error(`Invalid member name for Extension class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.extnID||""}),new E({name:t.critical||"",optional:!0}),new j({name:t.extnValue||""})]})}fromSchema(e){let t=we(e,e,Vt.schema({names:{extnID:"extnID",critical:"critical",extnValue:"extnValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EXTENSION");if(this.extnID=t.result.extnID.valueBlock.toString(),"critical"in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue,-1!==(t=ve(this.extnValue.valueBlock.valueHex)).offset)switch(this.extnID){case"2.5.29.9":this.parsedValue=new ft({schema:t.result});break;case"2.5.29.14":case"2.5.29.15":this.parsedValue=t.result;break;case"2.5.29.16":this.parsedValue=new dt({schema:t.result});break;case"2.5.29.17":case"2.5.29.18":this.parsedValue=new lt({schema:t.result});break;case"2.5.29.19":this.parsedValue=new gt({schema:t.result});break;case"2.5.29.20":case"2.5.29.27":case"2.5.29.21":case"2.5.29.24":this.parsedValue=t.result;break;case"2.5.29.28":this.parsedValue=new pt({schema:t.result});break;case"2.5.29.29":this.parsedValue=new yt({schema:t.result});break;case"2.5.29.30":this.parsedValue=new wt({schema:t.result});break;case"2.5.29.31":case"2.5.29.46":this.parsedValue=new kt({schema:t.result});break;case"2.5.29.32":this.parsedValue=new Ct({schema:t.result});break;case"2.5.29.33":this.parsedValue=new Bt({schema:t.result});break;case"2.5.29.35":this.parsedValue=new Nt({schema:t.result});break;case"2.5.29.36":this.parsedValue=new Pt({schema:t.result});break;case"2.5.29.37":this.parsedValue=new Et({schema:t.result});break;case"2.5.29.54":this.parsedValue=t.result;break;case"1.3.6.1.5.5.7.1.1":case"1.3.6.1.5.5.7.1.11":this.parsedValue=new xt({schema:t.result})}}toSchema(){const e=[];return e.push(new $({value:this.extnID})),this.critical!==Vt.defaultValues("critical")&&e.push(new E({value:this.critical})),e.push(this.extnValue),new x({value:e})}toJSON(){const e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==Vt.defaultValues("critical")&&(e.critical=this.critical),"parsedValue"in this&&(e.parsedValue=this.parsedValue.toJSON()),e}}class Dt{constructor(e={}){this.extensions=be(e,"extensions",Dt.defaultValues("extensions")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"extensions":return[];default:throw new Error(`Invalid member name for Extensions class: ${e}`)}}static schema(e={},t=!1){const r=be(e,"names",{});return new x({optional:t,name:r.blockName||"",value:[new ge({name:r.extensions||"",value:Vt.schema(r.extension||{})})]})}fromSchema(e){const t=we(e,e,Dt.schema({names:{extensions:"extensions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EXTENSIONS");this.extensions=Array.from(t.result.extensions,e=>new Vt({schema:e}))}toSchema(){return new x({value:Array.from(this.extensions,e=>e.toSchema())})}toJSON(){return{extensions:Array.from(this.extensions,e=>e.toJSON())}}}class Ot{constructor(e={}){this.tbs=be(e,"tbs",Ot.defaultValues("tbs")),this.version=be(e,"version",Ot.defaultValues("version")),this.serialNumber=be(e,"serialNumber",Ot.defaultValues("serialNumber")),this.signature=be(e,"signature",Ot.defaultValues("signature")),this.issuer=be(e,"issuer",Ot.defaultValues("issuer")),this.notBefore=be(e,"notBefore",Ot.defaultValues("notBefore")),this.notAfter=be(e,"notAfter",Ot.defaultValues("notAfter")),this.subject=be(e,"subject",Ot.defaultValues("subject")),this.subjectPublicKeyInfo=be(e,"subjectPublicKeyInfo",Ot.defaultValues("subjectPublicKeyInfo")),"issuerUniqueID"in e&&(this.issuerUniqueID=be(e,"issuerUniqueID",Ot.defaultValues("issuerUniqueID"))),"subjectUniqueID"in e&&(this.subjectUniqueID=be(e,"subjectUniqueID",Ot.defaultValues("subjectUniqueID"))),"extensions"in e&&(this.extensions=be(e,"extensions",Ot.defaultValues("extensions"))),this.signatureAlgorithm=be(e,"signatureAlgorithm",Ot.defaultValues("signatureAlgorithm")),this.signatureValue=be(e,"signatureValue",Ot.defaultValues("signatureValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"version":return 0;case"serialNumber":return new R;case"signature":return new Ve;case"issuer":return new at;case"notBefore":case"notAfter":return new mt;case"subject":return new at;case"subjectPublicKeyInfo":return new je;case"issuerUniqueID":case"subjectUniqueID":return new ArrayBuffer(0);case"extensions":return[];case"signatureAlgorithm":return new Ve;case"signatureValue":return new K;default:throw new Error(`Invalid member name for Certificate class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[function(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"tbsCertificate",value:[new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new R({name:t.tbsCertificateVersion||"tbsCertificate.version"})]}),new R({name:t.tbsCertificateSerialNumber||"tbsCertificate.serialNumber"}),Ve.schema(t.signature||{names:{blockName:"tbsCertificate.signature"}}),at.schema(t.issuer||{names:{blockName:"tbsCertificate.issuer"}}),new x({name:t.tbsCertificateValidity||"tbsCertificate.validity",value:[mt.schema(t.notBefore||{names:{utcTimeName:"tbsCertificate.notBefore",generalTimeName:"tbsCertificate.notBefore"}}),mt.schema(t.notAfter||{names:{utcTimeName:"tbsCertificate.notAfter",generalTimeName:"tbsCertificate.notAfter"}})]}),at.schema(t.subject||{names:{blockName:"tbsCertificate.subject"}}),je.schema(t.subjectPublicKeyInfo||{names:{blockName:"tbsCertificate.subjectPublicKeyInfo"}}),new S({name:t.tbsCertificateIssuerUniqueID||"tbsCertificate.issuerUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new S({name:t.tbsCertificateSubjectUniqueID||"tbsCertificate.subjectUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[Dt.schema(t.extensions||{names:{blockName:"tbsCertificate.extensions"}})]})]})}(t.tbsCertificate),Ve.schema(t.signatureAlgorithm||{names:{blockName:"signatureAlgorithm"}}),new K({name:t.signatureValue||"signatureValue"})]})}fromSchema(e){const t=we(e,e,Ot.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:"tbsCertificate.extensions"}}}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CERT");this.tbs=t.result.tbsCertificate.valueBeforeDecode,"tbsCertificate.version"in t.result&&(this.version=t.result["tbsCertificate.version"].valueBlock.valueDec),this.serialNumber=t.result["tbsCertificate.serialNumber"],this.signature=new Ve({schema:t.result["tbsCertificate.signature"]}),this.issuer=new at({schema:t.result["tbsCertificate.issuer"]}),this.notBefore=new mt({schema:t.result["tbsCertificate.notBefore"]}),this.notAfter=new mt({schema:t.result["tbsCertificate.notAfter"]}),this.subject=new at({schema:t.result["tbsCertificate.subject"]}),this.subjectPublicKeyInfo=new je({schema:t.result["tbsCertificate.subjectPublicKeyInfo"]}),"tbsCertificate.issuerUniqueID"in t.result&&(this.issuerUniqueID=t.result["tbsCertificate.issuerUniqueID"].valueBlock.valueHex),"tbsCertificate.subjectUniqueID"in t.result&&(this.issuerUniqueID=t.result["tbsCertificate.subjectUniqueID"].valueBlock.valueHex),"tbsCertificate.extensions"in t.result&&(this.extensions=Array.from(t.result["tbsCertificate.extensions"],e=>new Vt({schema:e}))),this.signatureAlgorithm=new Ve({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return"version"in this&&this.version!==Ot.defaultValues("version")&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new R({value:this.version})]})),e.push(this.serialNumber),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(new x({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),e.push(this.subject.toSchema()),e.push(this.subjectPublicKeyInfo.toSchema()),"issuerUniqueID"in this&&e.push(new S({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),"subjectUniqueID"in this&&e.push(new S({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),"subjectUniqueID"in this&&e.push(new S({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[this.extensions.toSchema()]})),"extensions"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new x({value:Array.from(this.extensions,e=>e.toSchema())})]})),new x({value:e})}toSchema(e=!1){let t={};if(!1===e){if(0===this.tbs.length)return Ot.schema().value[0];t=ve(this.tbs).result}else t=this.encodeTBS();return new x({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:ke(this.tbs,0,this.tbs.byteLength),serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return"version"in this&&this.version!==Ot.defaultValues("version")&&(e.version=this.version),"issuerUniqueID"in this&&(e.issuerUniqueID=ke(this.issuerUniqueID,0,this.issuerUniqueID.byteLength)),"subjectUniqueID"in this&&(e.subjectUniqueID=ke(this.subjectUniqueID,0,this.subjectUniqueID.byteLength)),"extensions"in this&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}getPublicKey(e=null){const t=_e();if(void 0===t)return Promise.reject("Unable to create WebCrypto object");if(null===e){e={};const t=et(this.signatureAlgorithm);if(""===t)return Promise.reject(`Unsupported signature algorithm: ${this.signatureAlgorithm.algorithmId}`);const r=Xe(this.subjectPublicKeyInfo.algorithm.algorithmId);if("name"in r==!1)return Promise.reject(`Unsupported public key algorithm: ${this.subjectPublicKeyInfo.algorithm.algorithmId}`);if(e.algorithm=ze(r.name,"importkey"),"hash"in e.algorithm.algorithm&&(e.algorithm.algorithm.hash.name=t),"ECDSA"===r.name){let t=!1;if("algorithmParams"in this.subjectPublicKeyInfo.algorithm==!0&&"idBlock"in this.subjectPublicKeyInfo.algorithm.algorithmParams&&1===this.subjectPublicKeyInfo.algorithm.algorithmParams.idBlock.tagClass&&6===this.subjectPublicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)return Promise.reject("Incorrect type for ECDSA public key parameters");const r=Xe(this.subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString());if("name"in r==!1)return Promise.reject(`Unsupported named curve algorithm: ${this.subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);e.algorithm.algorithm.namedCurve=r.name}}const r=this.subjectPublicKeyInfo.toSchema(),s=r.toBER(!1),a=new Uint8Array(s);return t.importKey("spki",a,e.algorithm.algorithm,!0,e.algorithm.usages)}getKeyHash(){const e=_e();return void 0===e?Promise.reject("Unable to create WebCrypto object"):e.digest({name:"sha-1"},new Uint8Array(this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex))}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let r,s=Promise.resolve();const a=qe();return s=(s=(s=(s=(s=s.then(()=>a.subtle.getSignatureParameters(e,t))).then(e=>{r=e.parameters,this.signature=e.signatureAlgorithm,this.signatureAlgorithm=e.signatureAlgorithm})).then(()=>{this.tbs=this.encodeTBS().toBER(!1)})).then(()=>a.subtle.signWithPrivateKey(this.tbs,e,r))).then(e=>{this.signatureValue=new K({valueHex:e})})}verify(e=null){let t=Promise.resolve(),r={};const s=this.signatureValue,a=this.tbs;if(null!==e?r=e.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(r=this.subjectPublicKeyInfo),r instanceof je==!1)return Promise.reject("Please provide issuer certificate as a parameter");const n=_e();if(void 0===n)return Promise.reject("Unable to create WebCrypto object");const i=et(this.signatureAlgorithm);return""===i?Promise.reject(`Unsupported signature algorithm: ${this.signatureAlgorithm.algorithmId}`):t=(t=t.then(()=>{let e;const t=Xe(e="1.2.840.113549.1.1.10"===this.signatureAlgorithm.algorithmId?this.signatureAlgorithm.algorithmId:r.algorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Unsupported public key algorithm: ${e}`);const s=ze(t.name,"importkey");if("hash"in s.algorithm&&(s.algorithm.hash.name=i),"ECDSA"===t.name){let e=!1;if("algorithmParams"in r.algorithm==!0&&"idBlock"in r.algorithm.algorithmParams&&1===r.algorithm.algorithmParams.idBlock.tagClass&&6===r.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)return Promise.reject("Incorrect type for ECDSA public key parameters");const t=Xe(r.algorithm.algorithmParams.valueBlock.toString());if("name"in t==!1)return Promise.reject(`Unsupported named curve algorithm: ${r.algorithm.algorithmParams.valueBlock.toString()}`);s.algorithm.namedCurve=t.name}const a=r.toSchema().toBER(!1),o=new Uint8Array(a);return n.importKey("spki",o,s.algorithm,!0,s.usages)})).then(e=>{const t=ze(e.algorithm.name,"verify");"hash"in t.algorithm&&(t.algorithm.hash.name=i);let r=s.valueBlock.valueHex;if("ECDSA"===e.algorithm.name){r=Ye(ve(r).result)}if("RSA-PSS"===e.algorithm.name){let e;try{e=new Je({schema:this.signatureAlgorithm.algorithmParams})}catch(e){return Promise.reject(e)}t.algorithm.saltLength="saltLength"in e?e.saltLength:20;let r="SHA-1";if("hashAlgorithm"in e){const t=Xe(e.hashAlgorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Unrecognized hash algorithm: ${e.hashAlgorithm.algorithmId}`);r=t.name}t.algorithm.hash.name=r}return n.verify(t.algorithm,e,new Uint8Array(r),new Uint8Array(a))})}}class jt{constructor(e={}){this.notBeforeTime=be(e,"notBeforeTime",jt.defaultValues("notBeforeTime")),this.notAfterTime=be(e,"notAfterTime",jt.defaultValues("notAfterTime")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"notBeforeTime":case"notAfterTime":return new Date(0,0,0);default:throw new Error(`Invalid member name for AttCertValidityPeriod class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new oe({name:t.notBeforeTime||""}),new oe({name:t.notAfterTime||""})]})}fromSchema(e){const t=we(e,e,jt.schema({names:{notBeforeTime:"notBeforeTime",notAfterTime:"notAfterTime"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AttCertValidityPeriod");this.notBeforeTime=t.result.notBeforeTime.toDate(),this.notAfterTime=t.result.notAfterTime.toDate()}toSchema(){return new x({value:[new oe({valueDate:this.notBeforeTime}),new oe({valueDate:this.notAfterTime})]})}toJSON(){return{notBeforeTime:this.notBeforeTime,notAfterTime:this.notAfterTime}}}class Ht{constructor(e={}){this.digestedObjectType=be(e,"digestedObjectType",Ht.defaultValues("digestedObjectType")),"otherObjectTypeID"in e&&(this.otherObjectTypeID=be(e,"otherObjectTypeID",Ht.defaultValues("otherObjectTypeID"))),this.digestAlgorithm=be(e,"digestAlgorithm",Ht.defaultValues("digestAlgorithm")),this.objectDigest=be(e,"objectDigest",Ht.defaultValues("objectDigest")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"digestedObjectType":return new L;case"otherObjectTypeID":return new $;case"digestAlgorithm":return new Ve;case"objectDigest":return new K;default:throw new Error(`Invalid member name for ObjectDigestInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new L({name:t.digestedObjectType||""}),new $({optional:!0,name:t.otherObjectTypeID||""}),Ve.schema(t.digestAlgorithm||{}),new K({name:t.objectDigest||""})]})}fromSchema(e){const t=we(e,e,Ht.schema({names:{digestedObjectType:"digestedObjectType",otherObjectTypeID:"otherObjectTypeID",digestAlgorithm:{names:{blockName:"digestAlgorithm"}},objectDigest:"objectDigest"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ObjectDigestInfo");this.digestedObjectType=t.result.digestedObjectType,"otherObjectTypeID"in t.result&&(this.otherObjectTypeID=t.result.otherObjectTypeID),this.digestAlgorithm=new Ve({schema:t.result.digestAlgorithm}),this.objectDigest=t.result.objectDigest}toSchema(){const e=new x({value:[this.digestedObjectType]});return"otherObjectTypeID"in this&&e.value.push(this.otherObjectTypeID),e.value.push(this.digestAlgorithm.toSchema()),e.value.push(this.objectDigest),e}toJSON(){const e={digestedObjectType:this.digestedObjectType.toJSON()};return"otherObjectTypeID"in this&&(e.otherObjectTypeID=this.otherObjectTypeID.toJSON()),e.digestAlgorithm=this.digestAlgorithm.toJSON(),e.objectDigest=this.objectDigest.toJSON(),e}}class Kt{constructor(e={}){this.issuer=be(e,"issuer",Kt.defaultValues("issuer")),this.serialNumber=be(e,"serialNumber",Kt.defaultValues("serialNumber")),"issuerUID"in e&&(this.issuerUID=be(e,"issuerUID",Kt.defaultValues("issuerUID"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"issuer":return new yt;case"serialNumber":return new R;case"issuerUID":return new K;default:throw new Error(`Invalid member name for IssuerSerial class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[yt.schema(t.issuer||{}),new R({name:t.serialNumber||""}),new K({optional:!0,name:t.issuerUID||""})]})}fromSchema(e){const t=we(e,e,Kt.schema({names:{issuer:{names:{blockName:"issuer"}},serialNumber:"serialNumber",issuerUID:"issuerUID"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for IssuerSerial");this.issuer=new yt({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber,"issuerUID"in t.result&&(this.issuerUID=t.result.issuerUID)}toSchema(){const e=new x({value:[this.issuer.toSchema(),this.serialNumber]});return"issuerUID"in this&&e.valueBlock.value.push(this.issuerUID),e}toJSON(){const e={issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()};return"issuerUID"in this&&(e.issuerUID=this.issuerUID.toJSON()),e}}class Ut{constructor(e={}){"issuerName"in e&&(this.issuerName=be(e,"issuerName",Ut.defaultValues("issuerName"))),"baseCertificateID"in e&&(this.baseCertificateID=be(e,"baseCertificateID",Ut.defaultValues("baseCertificateID"))),"objectDigestInfo"in e&&(this.objectDigestInfo=be(e,"objectDigestInfo",Ut.defaultValues("objectDigestInfo"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"issuerName":return new yt;case"baseCertificateID":return new Kt;case"objectDigestInfo":return new Ht;default:throw new Error(`Invalid member name for V2Form class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[yt.schema({names:{blockName:t.issuerName}},!0),new I({optional:!0,name:t.baseCertificateID||"",idBlock:{tagClass:3,tagNumber:0},value:Kt.schema().valueBlock.value}),new I({optional:!0,name:t.objectDigestInfo||"",idBlock:{tagClass:3,tagNumber:1},value:Ht.schema().valueBlock.value})]})}fromSchema(e){const t=we(e,e,Ut.schema({names:{issuerName:"issuerName",baseCertificateID:"baseCertificateID",objectDigestInfo:"objectDigestInfo"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for V2Form");"issuerName"in t.result&&(this.issuerName=new yt({schema:t.result.issuerName})),"baseCertificateID"in t.result&&(t.result.baseCertificateID.idBlock.tagClass=1,t.result.baseCertificateID.idBlock.tagNumber=16,this.baseCertificateID=new Kt({schema:t.result.baseCertificateID})),"objectDigestInfo"in t.result&&(t.result.objectDigestInfo.idBlock.tagClass=1,t.result.objectDigestInfo.idBlock.tagNumber=16,this.objectDigestInfo=new Ht({schema:t.result.objectDigestInfo}))}toSchema(){const e=new x;return"issuerName"in this&&e.valueBlock.value.push(this.issuerName.toSchema()),"baseCertificateID"in this&&e.valueBlock.value.push(new I({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),"objectDigestInfo"in this&&e.valueBlock.value.push(new I({idBlock:{tagClass:3,tagNumber:1},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){const e={};return"issuerName"in this&&(e.issuerName=this.issuerName.toJSON()),"baseCertificateID"in this&&(e.baseCertificateID=this.baseCertificateID.toJSON()),"objectDigestInfo"in this&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}class Rt{constructor(e={}){"baseCertificateID"in e&&(this.baseCertificateID=be(e,"baseCertificateID",Rt.defaultValues("baseCertificateID"))),"entityName"in e&&(this.entityName=be(e,"entityName",Rt.defaultValues("entityName"))),"objectDigestInfo"in e&&(this.objectDigestInfo=be(e,"objectDigestInfo",Rt.defaultValues("objectDigestInfo"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"baseCertificateID":return new Kt;case"entityName":return new yt;case"objectDigestInfo":return new Ht;default:throw new Error(`Invalid member name for Holder class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new I({optional:!0,name:t.baseCertificateID||"",idBlock:{tagClass:3,tagNumber:0},value:Kt.schema().valueBlock.value}),new I({optional:!0,name:t.entityName||"",idBlock:{tagClass:3,tagNumber:1},value:yt.schema().valueBlock.value}),new I({optional:!0,name:t.objectDigestInfo||"",idBlock:{tagClass:3,tagNumber:2},value:Ht.schema().valueBlock.value})]})}fromSchema(e){const t=we(e,e,Rt.schema({names:{baseCertificateID:"baseCertificateID",entityName:"entityName",objectDigestInfo:"objectDigestInfo"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Holder");"baseCertificateID"in t.result&&(t.result.baseCertificateID.idBlock.tagClass=1,t.result.baseCertificateID.idBlock.tagNumber=16,this.baseCertificateID=new Kt({schema:t.result.baseCertificateID})),"entityName"in t.result&&(t.result.entityName.idBlock.tagClass=1,t.result.entityName.idBlock.tagNumber=16,this.entityName=new yt({schema:t.result.entityName})),"objectDigestInfo"in t.result&&(t.result.objectDigestInfo.idBlock.tagClass=1,t.result.objectDigestInfo.idBlock.tagNumber=16,this.objectDigestInfo=new Ht({schema:t.result.objectDigestInfo}))}toSchema(){const e=new x;return"baseCertificateID"in this&&e.valueBlock.value.push(new I({idBlock:{tagClass:3,tagNumber:0},value:this.baseCertificateID.toSchema().valueBlock.value})),"entityName"in this&&e.valueBlock.value.push(new I({idBlock:{tagClass:3,tagNumber:1},value:this.entityName.toSchema().valueBlock.value})),"objectDigestInfo"in this&&e.valueBlock.value.push(new I({idBlock:{tagClass:3,tagNumber:2},value:this.objectDigestInfo.toSchema().valueBlock.value})),e}toJSON(){const e={};return"baseCertificateID"in this&&(e.baseCertificateID=this.baseCertificateID.toJSON()),"entityName"in this&&(e.entityName=this.entityName.toJSON()),"objectDigestInfo"in this&&(e.objectDigestInfo=this.objectDigestInfo.toJSON()),e}}class Lt{constructor(e={}){this.version=be(e,"version",Lt.defaultValues("version")),this.holder=be(e,"holder",Lt.defaultValues("holder")),this.issuer=be(e,"issuer",Lt.defaultValues("issuer")),this.signature=be(e,"signature",Lt.defaultValues("signature")),this.serialNumber=be(e,"serialNumber",Lt.defaultValues("serialNumber")),this.attrCertValidityPeriod=be(e,"attrCertValidityPeriod",Lt.defaultValues("attrCertValidityPeriod")),this.attributes=be(e,"attributes",Lt.defaultValues("attributes")),"issuerUniqueID"in e&&(this.issuerUniqueID=be(e,"issuerUniqueID",Lt.defaultValues("issuerUniqueID"))),"extensions"in e&&(this.extensions=be(e,"extensions",Lt.defaultValues("extensions"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 1;case"holder":return new Rt;case"issuer":return{};case"signature":return new Ve;case"serialNumber":return new R;case"attrCertValidityPeriod":return new jt;case"attributes":return[];case"issuerUniqueID":return new K;case"extensions":return new Dt;default:throw new Error(`Invalid member name for AttributeCertificateInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.version||""}),Rt.schema(t.holder||{}),new fe({value:[yt.schema({names:{blockName:t.issuer||""}}),new I({name:t.issuer||"",idBlock:{tagClass:3,tagNumber:0},value:Ut.schema().valueBlock.value})]}),Ve.schema(t.signature||{}),new R({name:t.serialNumber||""}),jt.schema(t.attrCertValidityPeriod||{}),new x({name:t.attributes||"",value:[new ge({value:He.schema()})]}),new K({optional:!0,name:t.issuerUniqueID||""}),Dt.schema(t.extensions||{},!0)]})}fromSchema(e){const t=we(e,e,Lt.schema({names:{version:"version",holder:{names:{blockName:"holder"}},issuer:"issuer",signature:{names:{blockName:"signature"}},serialNumber:"serialNumber",attrCertValidityPeriod:{names:{blockName:"attrCertValidityPeriod"}},attributes:"attributes",issuerUniqueID:"issuerUniqueID",extensions:{names:{blockName:"extensions"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AttributeCertificateInfo");switch(this.version=t.result.version.valueBlock.valueDec,this.holder=new Rt({schema:t.result.holder}),t.result.issuer.idBlock.tagClass){case 3:t.result.issuer.idBlock.tagClass=1,t.result.issuer.idBlock.tagNumber=16,this.issuer=new Ut({schema:t.result.issuer});break;case 1:default:throw new Error("Incorect value for 'issuer' in AttributeCertificateInfo")}this.signature=new Ve({schema:t.result.signature}),this.serialNumber=t.result.serialNumber,this.attrCertValidityPeriod=new jt({schema:t.result.attrCertValidityPeriod}),this.attributes=Array.from(t.result.attributes.valueBlock.value,e=>new He({schema:e})),"issuerUniqueID"in t.result&&(this.issuerUniqueID=t.result.issuerUniqueID),"extensions"in t.result&&(this.extensions=new Dt({schema:t.result.extensions}))}toSchema(){const e=new x({value:[new R({value:this.version}),this.holder.toSchema(),new I({idBlock:{tagClass:3,tagNumber:0},value:this.issuer.toSchema().valueBlock.value}),this.signature.toSchema(),this.serialNumber,this.attrCertValidityPeriod.toSchema(),new x({value:Array.from(this.attributes,e=>e.toSchema())})]});return"issuerUniqueID"in this&&e.valueBlock.value.push(this.issuerUniqueID),"extensions"in this&&e.valueBlock.value.push(this.extensions.toSchema()),e}toJSON(){const e={version:this.version,holder:this.holder.toJSON(),issuer:this.issuer.toJSON(),signature:this.signature.toJSON(),serialNumber:this.serialNumber.toJSON(),attrCertValidityPeriod:this.attrCertValidityPeriod.toJSON(),attributes:Array.from(this.attributes,e=>e.toJSON())};return"issuerUniqueID"in this&&(e.issuerUniqueID=this.issuerUniqueID.toJSON()),"extensions"in this&&(e.extensions=this.extensions.toJSON()),e}}class Tt{constructor(e={}){this.acinfo=be(e,"acinfo",Tt.defaultValues("acinfo")),this.signatureAlgorithm=be(e,"signatureAlgorithm",Tt.defaultValues("signatureAlgorithm")),this.signatureValue=be(e,"signatureValue",Tt.defaultValues("signatureValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"acinfo":return new Lt;case"signatureAlgorithm":return new Ve;case"signatureValue":return new K;default:throw new Error(`Invalid member name for AttributeCertificateV1 class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[Lt.schema(t.acinfo||{}),Ve.schema(t.signatureAlgorithm||{}),new K({name:t.signatureValue||""})]})}fromSchema(e){const t=we(e,e,Tt.schema({names:{acinfo:{names:{blockName:"acinfo"}},signatureAlgorithm:{names:{blockName:"signatureAlgorithm"}},signatureValue:"signatureValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AttributeCertificateV1");this.acinfo=new Lt({schema:t.result.acinfo}),this.signatureAlgorithm=new Ve({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}toSchema(){return new x({value:[this.acinfo.toSchema(),this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){return{acinfo:this.acinfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()}}}class Jt{constructor(e={}){this.certId=be(e,"certId",Jt.defaultValues("certId")),this.certValue=be(e,"certValue",Jt.defaultValues("certValue")),"parsedValue"in e&&(this.parsedValue=be(e,"parsedValue",Jt.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certId":return"";case"certValue":return new de;case"parsedValue":return{};default:throw new Error(`Invalid member name for CertBag class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"certId":return""===t;case"certValue":return t instanceof de;case"parsedValue":return t instanceof Object&&0===Object.keys(t).length;default:throw new Error(`Invalid member name for CertBag class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.id||"id"}),new I({idBlock:{tagClass:3,tagNumber:0},value:[new de({name:t.value||"value"})]})]})}fromSchema(e){const t=we(e,e,Jt.schema({names:{id:"certId",value:"certValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertBag");switch(this.certId=t.result.certId.valueBlock.toString(),this.certValue=t.result.certValue,this.certId){case"1.2.840.113549.1.9.22.1":{const e=ve(this.certValue.valueBlock.valueHex);try{this.parsedValue=new Ot({schema:e.result})}catch(t){this.parsedValue=new Tt({schema:e.result})}}break;case"1.2.840.113549.1.9.22.3":{const e=ve(this.certValue.valueBlock.valueHex);this.parsedValue=new Tt({schema:e.result})}break;case"1.2.840.113549.1.9.22.2":default:throw new Error(`Incorrect "certId" value in CertBag: ${this.certId}`)}}toSchema(){return"parsedValue"in this&&("acinfo"in this.parsedValue?this.certId="1.2.840.113549.1.9.22.3":this.certId="1.2.840.113549.1.9.22.1",this.certValue=new j({valueHex:this.parsedValue.toSchema().toBER(!1)})),new x({value:[new $({value:this.certId}),new I({idBlock:{tagClass:3,tagNumber:0},value:["toSchema"in this.certValue?this.certValue.toSchema():this.certValue]})]})}toJSON(){return{certId:this.certId,certValue:this.certValue.toJSON()}}}class $t{constructor(e={}){this.userCertificate=be(e,"userCertificate",$t.defaultValues("userCertificate")),this.revocationDate=be(e,"revocationDate",$t.defaultValues("revocationDate")),"crlEntryExtensions"in e&&(this.crlEntryExtensions=be(e,"crlEntryExtensions",$t.defaultValues("crlEntryExtensions"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"userCertificate":return new R;case"revocationDate":return new mt;case"crlEntryExtensions":return new Dt;default:throw new Error(`Invalid member name for RevokedCertificate class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.userCertificate||"userCertificate"}),mt.schema({names:{utcTimeName:t.revocationDate||"revocationDate",generalTimeName:t.revocationDate||"revocationDate"}}),Dt.schema({names:{blockName:t.crlEntryExtensions||"crlEntryExtensions"}},!0)]})}fromSchema(e){const t=we(e,e,$t.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for REV_CERT");this.userCertificate=t.result.userCertificate,this.revocationDate=new mt({schema:t.result.revocationDate}),"crlEntryExtensions"in t.result&&(this.crlEntryExtensions=new Dt({schema:t.result.crlEntryExtensions}))}toSchema(){const e=[this.userCertificate,this.revocationDate.toSchema()];return"crlEntryExtensions"in this&&e.push(this.crlEntryExtensions.toSchema()),new x({value:e})}toJSON(){const e={userCertificate:this.userCertificate.toJSON(),revocationDate:this.revocationDate.toJSON};return"crlEntryExtensions"in this&&(e.crlEntryExtensions=this.crlEntryExtensions.toJSON()),e}}class Ft{constructor(e={}){this.tbs=be(e,"tbs",Ft.defaultValues("tbs")),this.version=be(e,"version",Ft.defaultValues("version")),this.signature=be(e,"signature",Ft.defaultValues("signature")),this.issuer=be(e,"issuer",Ft.defaultValues("issuer")),this.thisUpdate=be(e,"thisUpdate",Ft.defaultValues("thisUpdate")),"nextUpdate"in e&&(this.nextUpdate=be(e,"nextUpdate",Ft.defaultValues("nextUpdate"))),"revokedCertificates"in e&&(this.revokedCertificates=be(e,"revokedCertificates",Ft.defaultValues("revokedCertificates"))),"crlExtensions"in e&&(this.crlExtensions=be(e,"crlExtensions",Ft.defaultValues("crlExtensions"))),this.signatureAlgorithm=be(e,"signatureAlgorithm",Ft.defaultValues("signatureAlgorithm")),this.signatureValue=be(e,"signatureValue",Ft.defaultValues("signatureValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"version":return 1;case"signature":return new Ve;case"issuer":return new at;case"thisUpdate":case"nextUpdate":return new mt;case"revokedCertificates":return[];case"crlExtensions":return new Dt;case"signatureAlgorithm":return new Ve;case"signatureValue":return new K;default:throw new Error(`Invalid member name for CertificateRevocationList class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"CertificateList",value:[function(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"tbsCertList",value:[new R({optional:!0,name:t.tbsCertListVersion||"tbsCertList.version",value:2}),Ve.schema(t.signature||{names:{blockName:"tbsCertList.signature"}}),at.schema(t.issuer||{names:{blockName:"tbsCertList.issuer"}}),mt.schema(t.tbsCertListThisUpdate||{names:{utcTimeName:"tbsCertList.thisUpdate",generalTimeName:"tbsCertList.thisUpdate"}}),mt.schema(t.tbsCertListNextUpdate||{names:{utcTimeName:"tbsCertList.nextUpdate",generalTimeName:"tbsCertList.nextUpdate"}},!0),new x({optional:!0,value:[new ge({name:t.tbsCertListRevokedCertificates||"tbsCertList.revokedCertificates",value:new x({value:[new R,mt.schema(),Dt.schema({},!0)]})})]}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[Dt.schema(t.crlExtensions||{names:{blockName:"tbsCertList.extensions"}})]})]})}(e),Ve.schema(t.signatureAlgorithm||{names:{blockName:"signatureAlgorithm"}}),new K({name:t.signatureValue||"signatureValue"})]})}fromSchema(e){const t=we(e,e,Ft.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CRL");this.tbs=t.result.tbsCertList.valueBeforeDecode,"tbsCertList.version"in t.result&&(this.version=t.result["tbsCertList.version"].valueBlock.valueDec),this.signature=new Ve({schema:t.result["tbsCertList.signature"]}),this.issuer=new at({schema:t.result["tbsCertList.issuer"]}),this.thisUpdate=new mt({schema:t.result["tbsCertList.thisUpdate"]}),"tbsCertList.nextUpdate"in t.result&&(this.nextUpdate=new mt({schema:t.result["tbsCertList.nextUpdate"]})),"tbsCertList.revokedCertificates"in t.result&&(this.revokedCertificates=Array.from(t.result["tbsCertList.revokedCertificates"],e=>new $t({schema:e}))),"tbsCertList.extensions"in t.result&&(this.crlExtensions=new Dt({schema:t.result["tbsCertList.extensions"]})),this.signatureAlgorithm=new Ve({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return this.version!==Ft.defaultValues("version")&&e.push(new R({value:this.version})),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(this.thisUpdate.toSchema()),"nextUpdate"in this&&e.push(this.nextUpdate.toSchema()),"revokedCertificates"in this&&e.push(new x({value:Array.from(this.revokedCertificates,e=>e.toSchema())})),"crlExtensions"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.crlExtensions.toSchema()]})),new x({value:e})}toSchema(e=!1){let t;if(!1===e){if(0===this.tbs.length)return Ft.schema();t=ve(this.tbs).result}else t=this.encodeTBS();return new x({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:ke(this.tbs,0,this.tbs.byteLength),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),thisUpdate:this.thisUpdate.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return this.version!==Ft.defaultValues("version")&&(e.version=this.version),"nextUpdate"in this&&(e.nextUpdate=this.nextUpdate.toJSON()),"revokedCertificates"in this&&(e.revokedCertificates=Array.from(this.revokedCertificates,e=>e.toJSON())),"crlExtensions"in this&&(e.crlExtensions=this.crlExtensions.toJSON()),e}isCertificateRevoked(e){if(!1===this.issuer.isEqual(e.issuer))return!1;if("revokedCertificates"in this==!1)return!1;for(const t of this.revokedCertificates)if(t.userCertificate.isEqual(e.serialNumber))return!0;return!1}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let r,s=Promise.resolve();const a=qe();return s=(s=(s=(s=(s=s.then(()=>a.subtle.getSignatureParameters(e,t))).then(e=>{r=e.parameters,this.signature=e.signatureAlgorithm,this.signatureAlgorithm=e.signatureAlgorithm})).then(()=>{this.tbs=this.encodeTBS().toBER(!1)})).then(()=>a.subtle.signWithPrivateKey(this.tbs,e,r))).then(e=>{this.signatureValue=new K({valueHex:e})})}verify(e={}){let t=Promise.resolve();const r=this.signatureValue,s=this.tbs;let a=-1;if("issuerCertificate"in e&&(a=e.issuerCertificate.subjectPublicKeyInfo,!1===this.issuer.isEqual(e.issuerCertificate.subject)))return Promise.resolve(!1);if("publicKeyInfo"in e&&(a=e.publicKeyInfo),a instanceof je==!1)return Promise.reject("Issuer's certificate must be provided as an input parameter");if("crlExtensions"in this)for(const e of this.crlExtensions.extensions)if(e.critical&&"parsedValue"in e==!1)return Promise.resolve(!1);const n=_e();if(void 0===n)return Promise.reject("Unable to create WebCrypto object");const i=et(this.signatureAlgorithm);return""===i?Promise.reject(`Unsupported signature algorithm: ${this.signatureAlgorithm.algorithmId}`):t=(t=t.then(()=>{const e=Xe(this.signature.algorithmId);if("name"in e==="")return Promise.reject(`Unsupported public key algorithm: ${this.signature.algorithmId}`);const t=ze(e.name,"importkey");if("hash"in t.algorithm&&(t.algorithm.hash.name=i),"ECDSA"===e.name){let e=!1;if("algorithmParams"in a.algorithm==!0&&"idBlock"in a.algorithm.algorithmParams&&1===a.algorithm.algorithmParams.idBlock.tagClass&&6===a.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)return Promise.reject("Incorrect type for ECDSA public key parameters");const r=Xe(a.algorithm.algorithmParams.valueBlock.toString());if("name"in r==!1)return Promise.reject(`Unsupported named curve algorithm: ${a.algorithm.algorithmParams.valueBlock.toString()}`);t.algorithm.namedCurve=r.name}const r=a.toSchema().toBER(!1),s=new Uint8Array(r);return n.importKey("spki",s,t.algorithm,!0,t.usages)})).then(e=>{const t=ze(e.algorithm.name,"verify");"hash"in t.algorithm&&(t.algorithm.hash.name=i);let a=r.valueBlock.valueHex;if("ECDSA"===e.algorithm.name){a=Ye(ve(a).result)}if("RSA-PSS"===e.algorithm.name){let e;try{e=new Je({schema:this.signatureAlgorithm.algorithmParams})}catch(e){return Promise.reject(e)}t.algorithm.saltLength="saltLength"in e?e.saltLength:20;let r="SHA-1";if("hashAlgorithm"in e){const t=Xe(e.hashAlgorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Unrecognized hash algorithm: ${e.hashAlgorithm.algorithmId}`);r=t.name}t.algorithm.hash.name=r}return n.verify(t.algorithm,e,new Uint8Array(a),new Uint8Array(s))})}}class Mt{constructor(e={}){this.crlId=be(e,"crlId",Mt.defaultValues("crlId")),this.crlValue=be(e,"crlValue",Mt.defaultValues("crlValue")),"parsedValue"in e&&(this.parsedValue=be(e,"parsedValue",Mt.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"crlId":return"";case"crlValue":return new de;case"parsedValue":return{};default:throw new Error(`Invalid member name for CRLBag class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"crlId":return""===t;case"crlValue":return t instanceof de;case"parsedValue":return t instanceof Object&&0===Object.keys(t).length;default:throw new Error(`Invalid member name for CRLBag class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.id||"id"}),new I({idBlock:{tagClass:3,tagNumber:0},value:[new de({name:t.value||"value"})]})]})}fromSchema(e){const t=we(e,e,Mt.schema({names:{id:"crlId",value:"crlValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CRLBag");switch(this.crlId=t.result.crlId.valueBlock.toString(),this.crlValue=t.result.crlValue,this.crlId){case"1.2.840.113549.1.9.23.1":{const e=ve(this.certValue.valueBlock.valueHex);this.parsedValue=new Ft({schema:e.result})}break;default:throw new Error(`Incorrect "crlId" value in CRLBag: ${this.crlId}`)}}toSchema(){return"parsedValue"in this&&(this.certId="1.2.840.113549.1.9.23.1",this.certValue=new j({valueHex:this.parsedValue.toSchema().toBER(!1)})),new x({value:[new $({value:this.crlId}),new I({idBlock:{tagClass:3,tagNumber:0},value:[this.crlValue.toSchema()]})]})}toJSON(){return{crlId:this.crlId,crlValue:this.crlValue.toJSON()}}}class Wt{constructor(e={}){this.secretTypeId=be(e,"secretTypeId",Wt.defaultValues("secretTypeId")),this.secretValue=be(e,"secretValue",Wt.defaultValues("secretValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"secretTypeId":return"";case"secretValue":return new de;default:throw new Error(`Invalid member name for SecretBag class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"secretTypeId":return""===t;case"secretValue":return t instanceof de;default:throw new Error(`Invalid member name for SecretBag class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.id||"id"}),new I({idBlock:{tagClass:3,tagNumber:0},value:[new de({name:t.value||"value"})]})]})}fromSchema(e){const t=we(e,e,Wt.schema({names:{id:"secretTypeId",value:"secretValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SecretBag");this.secretTypeId=t.result.secretTypeId.valueBlock.toString(),this.secretValue=t.result.secretValue}toSchema(){return new x({value:[new $({value:this.secretTypeId}),new I({idBlock:{tagClass:3,tagNumber:0},value:[this.secretValue.toSchema()]})]})}toJSON(){return{secretTypeId:this.secretTypeId,secretValue:this.secretValue.toJSON()}}}class qt{constructor(e={}){this.bagId=be(e,"bagId",qt.defaultValues("bagId")),this.bagValue=be(e,"bagValue",qt.defaultValues("bagValue")),"bagAttributes"in e&&(this.bagAttributes=be(e,"bagAttributes",qt.defaultValues("bagAttributes"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"bagId":return"";case"bagValue":return new de;case"bagAttributes":return[];default:throw new Error(`Invalid member name for SafeBag class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"bagId":return""===t;case"bagValue":return t instanceof de;case"bagAttributes":return 0===t.length;default:throw new Error(`Invalid member name for SafeBag class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.bagId||"bagId"}),new I({idBlock:{tagClass:3,tagNumber:0},value:[new de({name:t.bagValue||"bagValue"})]}),new V({optional:!0,value:[new ge({name:t.bagAttributes||"bagAttributes",value:He.schema()})]})]})}fromSchema(e){const t=we(e,e,qt.schema({names:{bagId:"bagId",bagValue:"bagValue",bagAttributes:"bagAttributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SafeBag");switch(this.bagId=t.result.bagId.valueBlock.toString(),this.bagId){case"1.2.840.113549.1.12.10.1.1":this.bagValue=new Le({schema:t.result.bagValue});break;case"1.2.840.113549.1.12.10.1.2":this.bagValue=new ht({schema:t.result.bagValue});break;case"1.2.840.113549.1.12.10.1.3":this.bagValue=new Jt({schema:t.result.bagValue});break;case"1.2.840.113549.1.12.10.1.4":this.bagValue=new Mt({schema:t.result.bagValue});break;case"1.2.840.113549.1.12.10.1.5":this.bagValue=new Wt({schema:t.result.bagValue});break;case"1.2.840.113549.1.12.10.1.6":this.bagValue=new _t({schema:t.result.bagValue});break;default:throw new Error(`Invalid "bagId" for SafeBag: ${this.bagId}`)}"bagAttributes"in t.result&&(this.bagAttributes=Array.from(t.result.bagAttributes,e=>new He({schema:e})))}toSchema(){const e=[new $({value:this.bagId}),new I({idBlock:{tagClass:3,tagNumber:0},value:[this.bagValue.toSchema()]})];return"bagAttributes"in this&&e.push(new V({value:Array.from(this.bagAttributes,e=>e.toSchema())})),new x({value:e})}toJSON(){const e={bagId:this.bagId,bagValue:this.bagValue.toJSON()};return"bagAttributes"in this&&(e.bagAttributes=Array.from(this.bagAttributes,e=>e.toJSON())),e}}class _t{constructor(e={}){this.safeBags=be(e,"safeBags",_t.defaultValues("safeBags")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"safeBags":return[];default:throw new Error(`Invalid member name for SafeContents class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"safeBags":return 0===t.length;default:throw new Error(`Invalid member name for SafeContents class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new ge({name:t.safeBags||"",value:qt.schema()})]})}fromSchema(e){const t=we(e,e,_t.schema({names:{safeBags:"safeBags"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SafeContents");this.safeBags=Array.from(t.result.safeBags,e=>new qt({schema:e}))}toSchema(){return new x({value:Array.from(this.safeBags,e=>e.toSchema())})}toJSON(){return{safeBags:Array.from(this.safeBags,e=>e.toJSON())}}}class Gt{constructor(e={}){this.certificates=be(e,"certificates",Gt.defaultValues("certificates")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certificates":return[];default:throw new Error(`Invalid member name for Attribute class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new V({name:t.blockName||"",value:[new ge({name:t.certificates||"",value:new fe({value:[Ot.schema(),new I({idBlock:{tagClass:3,tagNumber:1},value:[new de]}),new I({idBlock:{tagClass:3,tagNumber:2},value:[new de]}),new I({idBlock:{tagClass:3,tagNumber:3},value:[new $,new de]})]})})]})}fromSchema(e){const t=we(e,e,Gt.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CMS_CERTIFICATE_SET");this.certificates=Array.from(t.result.certificates,e=>1===e.idBlock.tagClass?new Ot({schema:e}):e)}toSchema(){return new V({value:Array.from(this.certificates,e=>e instanceof Ot?e.toSchema():e)})}toJSON(){return{certificates:Array.from(this.certificates,e=>e.toJSON())}}}class Qt{constructor(e={}){this.otherRevInfoFormat=be(e,"otherRevInfoFormat",Qt.defaultValues("otherRevInfoFormat")),this.otherRevInfo=be(e,"otherRevInfo",Qt.defaultValues("otherRevInfo")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"otherRevInfoFormat":return"";case"otherRevInfo":return new de;default:throw new Error(`Invalid member name for OtherRevocationInfoFormat class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.otherRevInfoFormat||"otherRevInfoFormat"}),new de({name:t.otherRevInfo||"otherRevInfo"})]})}fromSchema(e){const t=we(e,e,Qt.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherRevocationInfoFormat");this.otherRevInfoFormat=t.result.otherRevInfoFormat.valueBlock.toString(),this.otherRevInfo=t.result.otherRevInfo}toSchema(){return new x({value:[new $({value:this.otherRevInfoFormat}),this.otherRevInfo]})}toJSON(){const e={otherRevInfoFormat:this.otherRevInfoFormat};return this.otherRevInfo instanceof de||(e.otherRevInfo=this.otherRevInfo.toJSON()),e}}class zt{constructor(e={}){this.crls=be(e,"crls",zt.defaultValues("crls")),this.otherRevocationInfos=be(e,"otherRevocationInfos",zt.defaultValues("otherRevocationInfos")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"crls":case"otherRevocationInfos":return[];default:throw new Error(`Invalid member name for RevocationInfoChoices class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new V({name:t.blockName||"",value:[new ge({name:t.crls||"",value:new fe({value:[Ft.schema(),new I({idBlock:{tagClass:3,tagNumber:1},value:[new $,new de]})]})})]})}fromSchema(e){const t=we(e,e,zt.schema({names:{crls:"crls"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CSM_REVOCATION_INFO_CHOICES");for(const e of t.result.crls)1===e.idBlock.tagClass?this.crls.push(new Ft({schema:e})):this.otherRevocationInfos.push(new Qt({schema:e}))}toSchema(){const e=[];return e.push(...Array.from(this.crls,e=>e.toSchema())),e.push(...Array.from(this.otherRevocationInfos,e=>{const t=e.toSchema();return t.idBlock.tagClass=3,t.idBlock.tagNumber=1,t})),new V({value:e})}toJSON(){return{crls:Array.from(this.crls,e=>e.toJSON()),otherRevocationInfos:Array.from(this.otherRevocationInfos,e=>e.toJSON())}}}class Zt{constructor(e={}){this.certs=be(e,"certs",Zt.defaultValues("certs")),this.crls=be(e,"crls",Zt.defaultValues("crls")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certs":return new Gt;case"crls":return new zt;default:throw new Error(`Invalid member name for OriginatorInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"certs":return 0===t.certificates.length;case"crls":return 0===t.crls.length&&0===t.otherRevocationInfos.length;default:throw new Error(`Invalid member name for OriginatorInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new I({name:t.certs||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Gt.schema().valueBlock.value}),new I({name:t.crls||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:zt.schema().valueBlock.value})]})}fromSchema(e){const t=we(e,e,Zt.schema({names:{certs:"certs",crls:"crls"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OriginatorInfo");t.result.certs.idBlock.tagClass=1,t.result.certs.idBlock.tagNumber=17,this.certs=new Gt({schema:t.result.certs}),t.result.crls.idBlock.tagClass=1,t.result.crls.idBlock.tagNumber=17,this.crls=new zt({schema:t.result.crls})}toSchema(){return new x({value:[new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:this.certs.toSchema().valueBlock.value}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:this.crls.toSchema().valueBlock.value})]})}toJSON(){return{certs:this.certs.toJSON(),crls:this.crls.toJSON()}}}class Yt{constructor(e={}){this.issuer=be(e,"issuer",Yt.defaultValues("issuer")),this.serialNumber=be(e,"serialNumber",Yt.defaultValues("serialNumber")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"issuer":return new at;case"serialNumber":return new R;default:throw new Error(`Invalid member name for IssuerAndSerialNumber class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[at.schema(t.issuer||{}),new R({name:t.serialNumber||""})]})}fromSchema(e){const t=we(e,e,Yt.schema({names:{issuer:{names:{blockName:"issuer"}},serialNumber:"serialNumber"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for IssuerAndSerialNumber");this.issuer=new at({schema:t.result.issuer}),this.serialNumber=t.result.serialNumber}toSchema(){return new x({value:[this.issuer.toSchema(),this.serialNumber]})}toJSON(){return{issuer:this.issuer.toJSON(),serialNumber:this.serialNumber.toJSON()}}}class Xt{constructor(e={}){this.variant=be(e,"variant",Xt.defaultValues("variant")),"value"in e&&(this.value=be(e,"value",Xt.defaultValues("value"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"variant":return-1;case"value":return{};default:throw new Error(`Invalid member name for RecipientIdentifier class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"variant":return-1===t;case"values":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for RecipientIdentifier class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new fe({value:[Yt.schema({names:{blockName:t.blockName||""}}),new I({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:0},value:[new j]})]})}fromSchema(e){const t=we(e,e,Xt.schema({names:{blockName:"blockName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RecipientIdentifier");1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new Yt({schema:t.result.blockName})):(this.variant=2,this.value=t.result.blockName.valueBlock.value[0])}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return new I({idBlock:{tagClass:3,tagNumber:0},value:[this.value]});default:return new de}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant||(e.value=this.value.toJSON()),e}}class er{constructor(e={}){this.version=be(e,"version",er.defaultValues("version")),this.rid=be(e,"rid",er.defaultValues("rid")),this.keyEncryptionAlgorithm=be(e,"keyEncryptionAlgorithm",er.defaultValues("keyEncryptionAlgorithm")),this.encryptedKey=be(e,"encryptedKey",er.defaultValues("encryptedKey")),this.recipientCertificate=be(e,"recipientCertificate",er.defaultValues("recipientCertificate")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return-1;case"rid":return{};case"keyEncryptionAlgorithm":return new Ve;case"encryptedKey":return new j;case"recipientCertificate":return new Ot;default:throw new Error(`Invalid member name for KeyTransRecipientInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return t===er.defaultValues("version");case"rid":return 0===Object.keys(t).length;case"keyEncryptionAlgorithm":case"encryptedKey":return t.isEqual(er.defaultValues(e));case"recipientCertificate":return!1;default:throw new Error(`Invalid member name for KeyTransRecipientInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.version||""}),Xt.schema(t.rid||{}),Ve.schema(t.keyEncryptionAlgorithm||{}),new j({name:t.encryptedKey||""})]})}fromSchema(e){const t=we(e,e,er.schema({names:{version:"version",rid:{names:{blockName:"rid"}},keyEncryptionAlgorithm:{names:{blockName:"keyEncryptionAlgorithm"}},encryptedKey:"encryptedKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for KeyTransRecipientInfo");this.version=t.result.version.valueBlock.valueDec,3===t.result.rid.idBlock.tagClass?this.rid=t.result.rid.valueBlock.value[0]:this.rid=new Yt({schema:t.result.rid}),this.keyEncryptionAlgorithm=new Ve({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){const e=[];return this.rid instanceof Yt?(this.version=0,e.push(new R({value:this.version})),e.push(this.rid.toSchema())):(this.version=2,e.push(new R({value:this.version})),e.push(new I({idBlock:{tagClass:3,tagNumber:0},value:[this.rid]}))),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new x({value:e})}toJSON(){return{version:this.version,rid:this.rid.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}class tr{constructor(e={}){this.algorithm=be(e,"algorithm",tr.defaultValues("algorithm")),this.publicKey=be(e,"publicKey",tr.defaultValues("publicKey")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"algorithm":return new Ve;case"publicKey":return new K;default:throw new Error(`Invalid member name for OriginatorPublicKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"algorithm":case"publicKey":return t.isEqual(tr.defaultValues(e));default:throw new Error(`Invalid member name for OriginatorPublicKey class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[Ve.schema(t.algorithm||{}),new K({name:t.publicKey||""})]})}fromSchema(e){const t=we(e,e,tr.schema({names:{algorithm:{names:{blockName:"algorithm"}},publicKey:"publicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OriginatorPublicKey");this.algorithm=new Ve({schema:t.result.algorithm}),this.publicKey=t.result.publicKey}toSchema(){return new x({value:[this.algorithm.toSchema(),this.publicKey]})}toJSON(){return{algorithm:this.algorithm.toJSON(),publicKey:this.publicKey.toJSON()}}}class rr{constructor(e={}){this.variant=be(e,"variant",rr.defaultValues("variant")),"value"in e&&(this.value=be(e,"value",rr.defaultValues("value"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"variant":return-1;case"value":return{};default:throw new Error(`Invalid member name for OriginatorIdentifierOrKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"variant":return-1===t;case"value":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for OriginatorIdentifierOrKey class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new fe({value:[Yt.schema({names:{blockName:t.blockName||""}}),new S({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||""}),new I({idBlock:{tagClass:3,tagNumber:1},name:t.blockName||"",value:tr.schema().valueBlock.value})]})}fromSchema(e){const t=we(e,e,rr.schema({names:{blockName:"blockName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OriginatorIdentifierOrKey");1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new Yt({schema:t.result.blockName})):0===t.result.blockName.idBlock.tagNumber?(t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=4,this.variant=2,this.value=t.result.blockName):(t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=16,this.variant=3,this.value=new tr({schema:t.result.blockName}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return this.value.idBlock.tagClass=3,this.value.idBlock.tagNumber=0,this.value;case 3:{const e=this.value.toSchema();return e.idBlock.tagClass=3,e.idBlock.tagNumber=1,e}default:return new de}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant&&3!==this.variant||(e.value=this.value.toJSON()),e}}class sr{constructor(e={}){this.keyAttrId=be(e,"keyAttrId",sr.defaultValues("keyAttrId")),"keyAttr"in e&&(this.keyAttr=be(e,"keyAttr",sr.defaultValues("keyAttr"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyAttrId":return"";case"keyAttr":return{};default:throw new Error(`Invalid member name for OtherKeyAttribute class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"keyAttrId":return""===t;case"keyAttr":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for OtherKeyAttribute class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({optional:t.optional||!0,name:t.blockName||"",value:[new $({name:t.keyAttrId||""}),new de({optional:!0,name:t.keyAttr||""})]})}fromSchema(e){const t=we(e,e,sr.schema({names:{keyAttrId:"keyAttrId",keyAttr:"keyAttr"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherKeyAttribute");this.keyAttrId=t.result.keyAttrId.valueBlock.toString(),"keyAttr"in t.result&&(this.keyAttr=t.result.keyAttr)}toSchema(){const e=[];return e.push(new $({value:this.keyAttrId})),"keyAttr"in this&&e.push(this.keyAttr.toSchema()),new x({value:e})}toJSON(){const e={keyAttrId:this.keyAttrId};return"keyAttr"in this&&(e.keyAttr=this.keyAttr.toJSON()),e}}class ar{constructor(e={}){this.subjectKeyIdentifier=be(e,"subjectKeyIdentifier",ar.defaultValues("subjectKeyIdentifier")),"date"in e&&(this.date=be(e,"date",ar.defaultValues("date"))),"other"in e&&(this.other=be(e,"other",ar.defaultValues("other"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"subjectKeyIdentifier":return new j;case"date":return new oe;case"other":return new sr;default:throw new Error(`Invalid member name for RecipientKeyIdentifier class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"subjectKeyIdentifier":return t.isEqual(ar.defaultValues("subjectKeyIdentifier"));case"date":return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case"other":return""===t.keyAttrId&&"keyAttr"in t==!1;default:throw new Error(`Invalid member name for RecipientKeyIdentifier class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new j({name:t.subjectKeyIdentifier||""}),new oe({optional:!0,name:t.date||""}),sr.schema(t.other||{})]})}fromSchema(e){const t=we(e,e,ar.schema({names:{subjectKeyIdentifier:"subjectKeyIdentifier",date:"date",other:{names:{blockName:"other"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RecipientKeyIdentifier");this.subjectKeyIdentifier=t.result.subjectKeyIdentifier,"date"in t.result&&(this.date=t.result.date),"other"in t.result&&(this.other=new sr({schema:t.result.other}))}toSchema(){const e=[];return e.push(this.subjectKeyIdentifier),"date"in this&&e.push(this.date),"other"in this&&e.push(this.other.toSchema()),new x({value:e})}toJSON(){const e={subjectKeyIdentifier:this.subjectKeyIdentifier.toJSON()};return"date"in this&&(e.date=this.date),"other"in this&&(e.other=this.other.toJSON()),e}}class nr{constructor(e={}){this.variant=be(e,"variant",nr.defaultValues("variant")),this.value=be(e,"value",nr.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"variant":return-1;case"value":return{};default:throw new Error(`Invalid member name for KeyAgreeRecipientIdentifier class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"variant":return-1===t;case"value":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for KeyAgreeRecipientIdentifier class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new fe({value:[Yt.schema(t.issuerAndSerialNumber||{names:{blockName:t.blockName||""}}),new I({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:0},value:ar.schema(t.rKeyId||{names:{blockName:t.blockName||""}}).valueBlock.value})]})}fromSchema(e){const t=we(e,e,nr.schema({names:{blockName:"blockName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for KeyAgreeRecipientIdentifier");1===t.result.blockName.idBlock.tagClass?(this.variant=1,this.value=new Yt({schema:t.result.blockName})):(this.variant=2,t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=16,this.value=new ar({schema:t.result.blockName}))}toSchema(){switch(this.variant){case 1:return this.value.toSchema();case 2:return new I({idBlock:{tagClass:3,tagNumber:0},value:this.value.toSchema().valueBlock.value});default:return new de}}toJSON(){const e={variant:this.variant};return 1!==this.variant&&2!==this.variant||(e.value=this.value.toJSON()),e}}class ir{constructor(e={}){this.rid=be(e,"rid",ir.defaultValues("rid")),this.encryptedKey=be(e,"encryptedKey",ir.defaultValues("encryptedKey")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"rid":return new nr;case"encryptedKey":return new j;default:throw new Error(`Invalid member name for RecipientEncryptedKey class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"rid":return-1===t.variant&&"value"in t==!1;case"encryptedKey":return t.isEqual(ir.defaultValues("encryptedKey"));default:throw new Error(`Invalid member name for RecipientEncryptedKey class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[nr.schema(t.rid||{}),new j({name:t.encryptedKey||""})]})}fromSchema(e){const t=we(e,e,ir.schema({names:{rid:{names:{blockName:"rid"}},encryptedKey:"encryptedKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RecipientEncryptedKey");this.rid=new nr({schema:t.result.rid}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new x({value:[this.rid.toSchema(),this.encryptedKey]})}toJSON(){return{rid:this.rid.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}class or{constructor(e={}){this.encryptedKeys=be(e,"encryptedKeys",or.defaultValues("encryptedKeys")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"encryptedKeys":return[];default:throw new Error(`Invalid member name for RecipientEncryptedKeys class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"encryptedKeys":return 0===t.length;default:throw new Error(`Invalid member name for RecipientEncryptedKeys class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new ge({name:t.RecipientEncryptedKeys||"",value:ir.schema()})]})}fromSchema(e){const t=we(e,e,or.schema({names:{RecipientEncryptedKeys:"RecipientEncryptedKeys"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RecipientEncryptedKeys");this.encryptedKeys=Array.from(t.result.RecipientEncryptedKeys,e=>new ir({schema:e}))}toSchema(){return new x({value:Array.from(this.encryptedKeys,e=>e.toSchema())})}toJSON(){return{encryptedKeys:Array.from(this.encryptedKeys,e=>e.toJSON())}}}class lr{constructor(e={}){this.version=be(e,"version",lr.defaultValues("version")),this.originator=be(e,"originator",lr.defaultValues("originator")),"ukm"in e&&(this.ukm=be(e,"ukm",lr.defaultValues("ukm"))),this.keyEncryptionAlgorithm=be(e,"keyEncryptionAlgorithm",lr.defaultValues("keyEncryptionAlgorithm")),this.recipientEncryptedKeys=be(e,"recipientEncryptedKeys",lr.defaultValues("recipientEncryptedKeys")),this.recipientCertificate=be(e,"recipientCertificate",lr.defaultValues("recipientCertificate")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"originator":return new rr;case"ukm":return new j;case"keyEncryptionAlgorithm":return new Ve;case"recipientEncryptedKeys":return new or;case"recipientCertificate":return new Ot;default:throw new Error(`Invalid member name for KeyAgreeRecipientInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return 0===t;case"originator":return-1===t.variant&&"value"in t==!1;case"ukm":return t.isEqual(lr.defaultValues("ukm"));case"keyEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"recipientEncryptedKeys":return 0===t.encryptedKeys.length;case"recipientCertificate":return!1;default:throw new Error(`Invalid member name for KeyAgreeRecipientInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.version||""}),new I({idBlock:{tagClass:3,tagNumber:0},value:[rr.schema(t.originator||{})]}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new j({name:t.ukm||""})]}),Ve.schema(t.keyEncryptionAlgorithm||{}),or.schema(t.recipientEncryptedKeys||{})]})}fromSchema(e){const t=we(e,e,lr.schema({names:{version:"version",originator:{names:{blockName:"originator"}},ukm:"ukm",keyEncryptionAlgorithm:{names:{blockName:"keyEncryptionAlgorithm"}},recipientEncryptedKeys:{names:{blockName:"recipientEncryptedKeys"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for KeyAgreeRecipientInfo");this.version=t.result.version.valueBlock.valueDec,this.originator=new rr({schema:t.result.originator}),"ukm"in t.result&&(this.ukm=t.result.ukm),this.keyEncryptionAlgorithm=new Ve({schema:t.result.keyEncryptionAlgorithm}),this.recipientEncryptedKeys=new or({schema:t.result.recipientEncryptedKeys})}toSchema(){const e=[];return e.push(new R({value:this.version})),e.push(new I({idBlock:{tagClass:3,tagNumber:0},value:[this.originator.toSchema()]})),"ukm"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[this.ukm]})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.recipientEncryptedKeys.toSchema()),new x({value:e})}toJSON(){const e={version:this.version,originator:this.originator.toJSON()};return"ukm"in this&&(e.ukm=this.ukm.toJSON()),e.keyEncryptionAlgorithm=this.keyEncryptionAlgorithm.toJSON(),e.recipientEncryptedKeys=this.recipientEncryptedKeys.toJSON(),e}}class cr{constructor(e={}){this.keyIdentifier=be(e,"keyIdentifier",cr.defaultValues("keyIdentifier")),"date"in e&&(this.date=be(e,"date",cr.defaultValues("date"))),"other"in e&&(this.other=be(e,"other",cr.defaultValues("other"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyIdentifier":return new j;case"date":return new oe;case"other":return new sr;default:throw new Error(`Invalid member name for KEKIdentifier class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"keyIdentifier":return t.isEqual(cr.defaultValues("keyIdentifier"));case"date":return 0===t.year&&0===t.month&&0===t.day&&0===t.hour&&0===t.minute&&0===t.second&&0===t.millisecond;case"other":return t.compareWithDefault("keyAttrId",t.keyAttrId)&&"keyAttr"in t==!1;default:throw new Error(`Invalid member name for KEKIdentifier class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new j({name:t.keyIdentifier||""}),new oe({optional:!0,name:t.date||""}),sr.schema(t.other||{})]})}fromSchema(e){const t=we(e,e,cr.schema({names:{keyIdentifier:"keyIdentifier",date:"date",other:{names:{blockName:"other"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for KEKIdentifier");this.keyIdentifier=t.result.keyIdentifier,"date"in t.result&&(this.date=t.result.date),"other"in t.result&&(this.other=new sr({schema:t.result.other}))}toSchema(){const e=[];return e.push(this.keyIdentifier),"date"in this&&e.push(this.date),"other"in this&&e.push(this.other.toSchema()),new x({value:e})}toJSON(){const e={keyIdentifier:this.keyIdentifier.toJSON()};return"date"in this&&(e.date=this.date),"other"in this&&(e.other=this.other.toJSON()),e}}class ur{constructor(e={}){this.version=be(e,"version",ur.defaultValues("version")),this.kekid=be(e,"kekid",ur.defaultValues("kekid")),this.keyEncryptionAlgorithm=be(e,"keyEncryptionAlgorithm",ur.defaultValues("keyEncryptionAlgorithm")),this.encryptedKey=be(e,"encryptedKey",ur.defaultValues("encryptedKey")),this.preDefinedKEK=be(e,"preDefinedKEK",ur.defaultValues("preDefinedKEK")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"kekid":return new cr;case"keyEncryptionAlgorithm":return new Ve;case"encryptedKey":return new j;case"preDefinedKEK":return new ArrayBuffer(0);default:throw new Error(`Invalid member name for KEKRecipientInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"KEKRecipientInfo":return t===ur.defaultValues("version");case"kekid":return t.compareWithDefault("keyIdentifier",t.keyIdentifier)&&"date"in t==!1&&"other"in t==!1;case"keyEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"encryptedKey":return t.isEqual(ur.defaultValues("encryptedKey"));case"preDefinedKEK":return 0===t.byteLength;default:throw new Error(`Invalid member name for KEKRecipientInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.version||""}),cr.schema(t.kekid||{}),Ve.schema(t.keyEncryptionAlgorithm||{}),new j({name:t.encryptedKey||""})]})}fromSchema(e){const t=we(e,e,ur.schema({names:{version:"version",kekid:{names:{blockName:"kekid"}},keyEncryptionAlgorithm:{names:{blockName:"keyEncryptionAlgorithm"}},encryptedKey:"encryptedKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for KEKRecipientInfo");this.version=t.result.version.valueBlock.valueDec,this.kekid=new cr({schema:t.result.kekid}),this.keyEncryptionAlgorithm=new Ve({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){return new x({value:[new R({value:this.version}),this.kekid.toSchema(),this.keyEncryptionAlgorithm.toSchema(),this.encryptedKey]})}toJSON(){return{version:this.version,kekid:this.originator.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}class hr{constructor(e={}){this.version=be(e,"version",hr.defaultValues("version")),"keyDerivationAlgorithm"in e&&(this.keyDerivationAlgorithm=be(e,"keyDerivationAlgorithm",hr.defaultValues("keyDerivationAlgorithm"))),this.keyEncryptionAlgorithm=be(e,"keyEncryptionAlgorithm",hr.defaultValues("keyEncryptionAlgorithm")),this.encryptedKey=be(e,"encryptedKey",hr.defaultValues("encryptedKey")),this.password=be(e,"password",hr.defaultValues("password")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return-1;case"keyDerivationAlgorithm":case"keyEncryptionAlgorithm":return new Ve;case"encryptedKey":return new j;case"password":return new ArrayBuffer(0);default:throw new Error(`Invalid member name for PasswordRecipientinfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return-1===t;case"keyDerivationAlgorithm":case"keyEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"encryptedKey":return t.isEqual(hr.defaultValues("encryptedKey"));case"password":return 0===t.byteLength;default:throw new Error(`Invalid member name for PasswordRecipientinfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.version||""}),new I({name:t.keyDerivationAlgorithm||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Ve.schema().valueBlock.value}),Ve.schema(t.keyEncryptionAlgorithm||{}),new j({name:t.encryptedKey||""})]})}fromSchema(e){const t=we(e,e,hr.schema({names:{version:"version",keyDerivationAlgorithm:"keyDerivationAlgorithm",keyEncryptionAlgorithm:{names:{blockName:"keyEncryptionAlgorithm"}},encryptedKey:"encryptedKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PasswordRecipientinfo");this.version=t.result.version.valueBlock.valueDec,"keyDerivationAlgorithm"in t.result&&(t.result.keyDerivationAlgorithm.idBlock.tagClass=1,t.result.keyDerivationAlgorithm.idBlock.tagNumber=16,this.keyDerivationAlgorithm=new Ve({schema:t.result.keyDerivationAlgorithm})),this.keyEncryptionAlgorithm=new Ve({schema:t.result.keyEncryptionAlgorithm}),this.encryptedKey=t.result.encryptedKey}toSchema(){const e=[];return e.push(new R({value:this.version})),"keyDerivationAlgorithm"in this&&e.push(new I({idBlock:{tagClass:3,tagNumber:0},value:this.keyDerivationAlgorithm.toSchema().valueBlock.value})),e.push(this.keyEncryptionAlgorithm.toSchema()),e.push(this.encryptedKey),new x({value:e})}toJSON(){return{version:this.version,keyDerivationAlgorithm:this.keyDerivationAlgorithm.toJSON(),keyEncryptionAlgorithm:this.keyEncryptionAlgorithm.toJSON(),encryptedKey:this.encryptedKey.toJSON()}}}class mr{constructor(e={}){this.oriType=be(e,"oriType",mr.defaultValues("oriType")),this.oriValue=be(e,"oriValue",mr.defaultValues("oriValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"oriType":return"";case"oriValue":return{};default:throw new Error(`Invalid member name for OtherRecipientInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"oriType":return""===t;case"oriValue":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for OtherRecipientInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.oriType||""}),new de({name:t.oriValue||""})]})}fromSchema(e){const t=we(e,e,mr.schema({names:{oriType:"oriType",oriValue:"oriValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherRecipientInfo");this.oriType=t.result.oriType.valueBlock.toString(),this.oriValue=t.result.oriValue}toSchema(){return new x({value:[new $({value:this.oriType}),this.oriValue]})}toJSON(){const e={oriType:this.oriType};return!1===mr.compareWithDefault("oriValue",this.oriValue)&&(e.oriValue=this.oriValue.toJSON()),e}}class fr{constructor(e={}){this.variant=be(e,"variant",fr.defaultValues("variant")),"value"in e&&(this.value=be(e,"value",fr.defaultValues("value"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"variant":return-1;case"value":return{};default:throw new Error(`Invalid member name for RecipientInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"variant":return t===fr.defaultValues(e);case"value":return 0===Object.keys(t).length;default:throw new Error(`Invalid member name for RecipientInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new fe({value:[er.schema({names:{blockName:t.blockName||""}}),new I({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:1},value:lr.schema().valueBlock.value}),new I({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:2},value:ur.schema().valueBlock.value}),new I({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:3},value:hr.schema().valueBlock.value}),new I({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:4},value:mr.schema().valueBlock.value})]})}fromSchema(e){const t=we(e,e,fr.schema({names:{blockName:"blockName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CMS_RECIPIENT_INFO");if(1===t.result.blockName.idBlock.tagClass)this.variant=1,this.value=new er({schema:t.result.blockName});else{const e=t.result.blockName.idBlock.tagNumber;switch(t.result.blockName.idBlock.tagClass=1,t.result.blockName.idBlock.tagNumber=16,e){case 1:this.variant=2,this.value=new lr({schema:t.result.blockName});break;case 2:this.variant=3,this.value=new ur({schema:t.result.blockName});break;case 3:this.variant=4,this.value=new hr({schema:t.result.blockName});break;case 4:this.variant=5,this.value=new mr({schema:t.result.blockName});break;default:throw new Error("Incorrect structure of RecipientInfo block")}}}toSchema(){const e=this.value.toSchema();switch(this.variant){case 1:return e;case 2:case 3:case 4:return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.variant-1,e;default:return new de}}toJSON(){const e={variant:this.variant};return this.variant>=1&&this.variant<=4&&(e.value=this.value.toJSON()),e}}class dr{constructor(e={}){this.hashAlgorithm=be(e,"hashAlgorithm",dr.defaultValues("hashAlgorithm")),this.maskGenAlgorithm=be(e,"maskGenAlgorithm",dr.defaultValues("maskGenAlgorithm")),this.pSourceAlgorithm=be(e,"pSourceAlgorithm",dr.defaultValues("pSourceAlgorithm")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new Ve({algorithmId:"1.3.14.3.2.26",algorithmParams:new D});case"maskGenAlgorithm":return new Ve({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new Ve({algorithmId:"1.3.14.3.2.26",algorithmParams:new D}).toSchema()});case"pSourceAlgorithm":return new Ve({algorithmId:"1.2.840.113549.1.1.9",algorithmParams:new j({valueHex:new Uint8Array([218,57,163,238,94,107,75,13,50,85,191,239,149,96,24,144,175,216,7,9]).buffer})});default:throw new Error(`Invalid member name for RSAESOAEPParams class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new I({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[Ve.schema(t.hashAlgorithm||{})]}),new I({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[Ve.schema(t.maskGenAlgorithm||{})]}),new I({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[Ve.schema(t.pSourceAlgorithm||{})]})]})}fromSchema(e){const t=we(e,e,dr.schema({names:{hashAlgorithm:{names:{blockName:"hashAlgorithm"}},maskGenAlgorithm:{names:{blockName:"maskGenAlgorithm"}},pSourceAlgorithm:{names:{blockName:"pSourceAlgorithm"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAESOAEPParams");"hashAlgorithm"in t.result&&(this.hashAlgorithm=new Ve({schema:t.result.hashAlgorithm})),"maskGenAlgorithm"in t.result&&(this.maskGenAlgorithm=new Ve({schema:t.result.maskGenAlgorithm})),"pSourceAlgorithm"in t.result&&(this.pSourceAlgorithm=new Ve({schema:t.result.pSourceAlgorithm}))}toSchema(){const e=[];return this.hashAlgorithm.isEqual(dr.defaultValues("hashAlgorithm"))||e.push(new I({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(dr.defaultValues("maskGenAlgorithm"))||e.push(new I({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.pSourceAlgorithm.isEqual(dr.defaultValues("pSourceAlgorithm"))||e.push(new I({idBlock:{tagClass:3,tagNumber:2},value:[this.pSourceAlgorithm.toSchema()]})),new x({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(dr.defaultValues("hashAlgorithm"))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(dr.defaultValues("maskGenAlgorithm"))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.pSourceAlgorithm.isEqual(dr.defaultValues("pSourceAlgorithm"))||(e.pSourceAlgorithm=this.pSourceAlgorithm.toJSON()),e}}class gr{constructor(e={}){this.keyInfo=be(e,"keyInfo",gr.defaultValues("keyInfo")),"entityUInfo"in e&&(this.entityUInfo=be(e,"entityUInfo",gr.defaultValues("entityUInfo"))),this.suppPubInfo=be(e,"suppPubInfo",gr.defaultValues("suppPubInfo")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyInfo":return new Ve;case"entityUInfo":case"suppPubInfo":return new j;default:throw new Error(`Invalid member name for ECCCMSSharedInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"keyInfo":case"entityUInfo":case"suppPubInfo":return t.isEqual(gr.defaultValues(e));default:throw new Error(`Invalid member name for ECCCMSSharedInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[Ve.schema(t.keyInfo||{}),new I({name:t.entityUInfo||"",idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[new j]}),new I({name:t.suppPubInfo||"",idBlock:{tagClass:3,tagNumber:2},value:[new j]})]})}fromSchema(e){const t=we(e,e,gr.schema({names:{keyInfo:{names:{blockName:"keyInfo"}},entityUInfo:"entityUInfo",suppPubInfo:"suppPubInfo"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ECC_CMS_SharedInfo");this.keyInfo=new Ve({schema:t.result.keyInfo}),"entityUInfo"in t.result&&(this.entityUInfo=t.result.entityUInfo.valueBlock.value[0]),this.suppPubInfo=t.result.suppPubInfo.valueBlock.value[0]}toSchema(){const e=[];return e.push(this.keyInfo.toSchema()),"entityUInfo"in this&&e.push(new I({idBlock:{tagClass:3,tagNumber:0},value:[this.entityUInfo]})),e.push(new I({idBlock:{tagClass:3,tagNumber:2},value:[this.suppPubInfo]})),new x({value:e})}toJSON(){const e={keyInfo:this.keyInfo.toJSON()};return"entityUInfo"in this&&(e.entityUInfo=this.entityUInfo.toJSON()),e.suppPubInfo=this.suppPubInfo.toJSON(),e}}class pr{constructor(e={}){this.version=be(e,"version",pr.defaultValues("version")),"originatorInfo"in e&&(this.originatorInfo=be(e,"originatorInfo",pr.defaultValues("originatorInfo"))),this.recipientInfos=be(e,"recipientInfos",pr.defaultValues("recipientInfos")),this.encryptedContentInfo=be(e,"encryptedContentInfo",pr.defaultValues("encryptedContentInfo")),"unprotectedAttrs"in e&&(this.unprotectedAttrs=be(e,"unprotectedAttrs",pr.defaultValues("unprotectedAttrs"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"originatorInfo":return new Zt;case"recipientInfos":return[];case"encryptedContentInfo":return new Te;case"unprotectedAttrs":return[];default:throw new Error(`Invalid member name for EnvelopedData class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return t===pr.defaultValues(e);case"originatorInfo":return 0===t.certs.certificates.length&&0===t.crls.crls.length;case"recipientInfos":case"unprotectedAttrs":return 0===t.length;case"encryptedContentInfo":return Te.compareWithDefault("contentType",t.contentType)&&Te.compareWithDefault("contentEncryptionAlgorithm",t.contentEncryptionAlgorithm)&&Te.compareWithDefault("encryptedContent",t.encryptedContent);default:throw new Error(`Invalid member name for EnvelopedData class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.version||""}),new I({name:t.originatorInfo||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Zt.schema().valueBlock.value}),new V({value:[new ge({name:t.recipientInfos||"",value:fr.schema()})]}),Te.schema(t.encryptedContentInfo||{}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ge({name:t.unprotectedAttrs||"",value:He.schema()})]})]})}fromSchema(e){const t=we(e,e,pr.schema({names:{version:"version",originatorInfo:"originatorInfo",recipientInfos:"recipientInfos",encryptedContentInfo:{names:{blockName:"encryptedContentInfo"}},unprotectedAttrs:"unprotectedAttrs"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CMS_ENVELOPED_DATA");this.version=t.result.version.valueBlock.valueDec,"originatorInfo"in t.result&&(t.result.originatorInfo.idBlock.tagClass=1,t.result.originatorInfo.idBlock.tagNumber=16,this.originatorInfo=new Zt({schema:t.result.originatorInfo})),this.recipientInfos=Array.from(t.result.recipientInfos,e=>new fr({schema:e})),this.encryptedContentInfo=new Te({schema:t.result.encryptedContentInfo}),"unprotectedAttrs"in t.result&&(this.unprotectedAttrs=Array.from(t.result.unprotectedAttrs,e=>new He({schema:e})))}toSchema(){const e=[];return e.push(new R({value:this.version})),"originatorInfo"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:this.originatorInfo.toSchema().valueBlock.value})),e.push(new V({value:Array.from(this.recipientInfos,e=>e.toSchema())})),e.push(this.encryptedContentInfo.toSchema()),"unprotectedAttrs"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.unprotectedAttrs,e=>e.toSchema())})),new x({value:e})}toJSON(){const e={version:this.version};return"originatorInfo"in this&&(e.originatorInfo=this.originatorInfo.toJSON()),e.recipientInfos=Array.from(this.recipientInfos,e=>e.toJSON()),e.encryptedContentInfo=this.encryptedContentInfo.toJSON(),"unprotectedAttrs"in this&&(e.unprotectedAttrs=Array.from(this.unprotectedAttrs,e=>e.toJSON())),e}addRecipientByCertificate(e,t,r){const s=t||{};if(-1!==e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.113549"))r=1;else{if(-1===e.subjectPublicKeyInfo.algorithm.algorithmId.indexOf("1.2.840.10045"))throw new Error(`Unknown type of certificate's public key: ${e.subjectPublicKeyInfo.algorithm.algorithmId}`);r=2}switch("oaepHashAlgorithm"in s==!1&&(s.oaepHashAlgorithm="SHA-512"),"kdfAlgorithm"in s==!1&&(s.kdfAlgorithm="SHA-512"),"kekEncryptionLength"in s==!1&&(s.kekEncryptionLength=256),r){case 1:{const t=Qe({name:"RSA-OAEP"});if(""===t)throw new Error("Can not find OID for OAEP");const r=Qe({name:s.oaepHashAlgorithm});if(""===r)throw new Error(`Unknown OAEP hash algorithm: ${s.oaepHashAlgorithm}`);const a=new Ve({algorithmId:r,algorithmParams:new D}),n=new dr({hashAlgorithm:a,maskGenAlgorithm:new Ve({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:a.toSchema()})}),i=new er({version:0,rid:new Yt({issuer:e.issuer,serialNumber:e.serialNumber}),keyEncryptionAlgorithm:new Ve({algorithmId:t,algorithmParams:n.toSchema()}),recipientCertificate:e});this.recipientInfos.push(new fr({variant:1,value:i}))}break;case 2:{const t=new ir({rid:new nr({variant:1,value:new Yt({issuer:e.issuer,serialNumber:e.serialNumber})})}),r=Qe({name:"AES-KW",length:s.kekEncryptionLength});if(""===r)throw new Error(`Unknown length for key encryption algorithm: ${s.kekEncryptionLength}`);const a=new Ve({algorithmId:r,algorithmParams:new D}),n=Qe({name:"ECDH",kdf:s.kdfAlgorithm});if(""===n)throw new Error(`Unknown KDF algorithm: ${s.kdfAlgorithm}`);const i=new ArrayBuffer(64);Ge(new Uint8Array(i));const o=new lr({version:3,ukm:new j({valueHex:i}),keyEncryptionAlgorithm:new Ve({algorithmId:n,algorithmParams:a.toSchema()}),recipientEncryptedKeys:new or({encryptedKeys:[t]}),recipientCertificate:e});this.recipientInfos.push(new fr({variant:2,value:o}))}break;default:throw new Error(`Unknown "variant" value: ${r}`)}return!0}addRecipientByPreDefinedData(e,t,r){const s=t||{};if(e instanceof ArrayBuffer==!1)throw new Error('Please pass "preDefinedData" in ArrayBuffer type');if(0===e.byteLength)throw new Error("Pre-defined data could have zero length");if("keyIdentifier"in s==!1){const e=new ArrayBuffer(16);Ge(new Uint8Array(e)),s.keyIdentifier=e}switch("hmacHashAlgorithm"in s==!1&&(s.hmacHashAlgorithm="SHA-512"),"iterationCount"in s==!1&&(s.iterationCount=2048),"keyEncryptionAlgorithm"in s==!1&&(s.keyEncryptionAlgorithm={name:"AES-KW",length:256}),"keyEncryptionAlgorithmParams"in s==!1&&(s.keyEncryptionAlgorithmParams=new D),r){case 1:{const t=Qe(s.keyEncryptionAlgorithm);if(""===t)throw new Error('Incorrect value for "keyEncryptionAlgorithm"');const r=new ur({version:4,kekid:new cr({keyIdentifier:new j({valueHex:s.keyIdentifier})}),keyEncryptionAlgorithm:new Ve({algorithmId:t,algorithmParams:s.keyEncryptionAlgorithmParams}),preDefinedKEK:e});this.recipientInfos.push(new fr({variant:3,value:r}))}break;case 2:{const t=Qe({name:"PBKDF2"});if(""===t)throw new Error("Can not find OID for PBKDF2");const r=new ArrayBuffer(64);Ge(new Uint8Array(r));const a=Qe({name:"HMAC",hash:{name:s.hmacHashAlgorithm}});if(""===a)throw new Error(`Incorrect value for "hmacHashAlgorithm": ${s.hmacHashAlgorithm}`);const n=new $e({salt:new j({valueHex:r}),iterationCount:s.iterationCount,prf:new Ve({algorithmId:a,algorithmParams:new D})}),i=Qe(s.keyEncryptionAlgorithm);if(""===i)throw new Error('Incorrect value for "keyEncryptionAlgorithm"');const o=new hr({version:0,keyDerivationAlgorithm:new Ve({algorithmId:t,algorithmParams:n.toSchema()}),keyEncryptionAlgorithm:new Ve({algorithmId:i,algorithmParams:s.keyEncryptionAlgorithmParams}),password:e});this.recipientInfos.push(new fr({variant:4,value:o}))}break;default:throw new Error(`Unknown value for "variant": ${r}`)}}encrypt(e,t){let r=Promise.resolve();const s=new ArrayBuffer(16),a=new Uint8Array(s);Ge(a);const n=new Uint8Array(t);let i,o,l;const c=[],u=this,h=Qe(e);if(""===h)return Promise.reject('Wrong "contentEncryptionAlgorithm" value');const m=_e();if(void 0===m)return Promise.reject("Unable to create WebCrypto object");function f(e){let t,r,s,a,n,o=Promise.resolve();return o=(o=(o=(o=(o=(o=(o=(o=(o=o.then(()=>{const t=u.recipientInfos[e].value.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(t instanceof $==!1)return Promise.reject(`Incorrect "recipientCertificate" for index ${e}`);switch(t.valueBlock.toString()){case"1.2.840.10045.3.1.7":s="P-256",a=256;break;case"1.3.132.0.34":s="P-384",a=384;break;case"1.3.132.0.35":s="P-521",a=528;break;default:return Promise.reject(`Incorrect curve OID for index ${e}`)}return s},e=>Promise.reject(e))).then(e=>m.generateKey({name:"ECDH",namedCurve:e},!0,["deriveBits"]),e=>Promise.reject(e))).then(e=>(t=e.publicKey,r=e.privateKey,m.exportKey("spki",t)),e=>Promise.reject(e))).then(t=>(n=t,u.recipientInfos[e].value.recipientCertificate.getPublicKey({algorithm:{algorithm:{name:"ECDH",namedCurve:s},usages:[]}})),e=>Promise.reject(e))).then(e=>m.deriveBits({name:"ECDH",public:e},r,a),e=>Promise.reject(e))).then(t=>{const r=new Ve({schema:u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmParams}),s=Xe(r.algorithmId);if("name"in s==!1)return Promise.reject(`Incorrect OID for key encryption algorithm: ${r.algorithmId}`);let a=s.length;const n=new ArrayBuffer(4),i=new Uint8Array(n);for(let e=3;e>=0;e--)i[e]=a,a>>=8;const o=new gr({keyInfo:new Ve({algorithmId:r.algorithmId,algorithmParams:new D}),entityUInfo:u.recipientInfos[e].value.ukm,suppPubInfo:new j({valueHex:n})}).toSchema().toBER(!1),l=Xe(u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId);return"name"in l==!1?Promise.reject(`Incorrect OID for key encryption algorithm: ${u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId}`):rt(l.kdf,t,s.length,o)},e=>Promise.reject(e))).then(e=>m.importKey("raw",e,{name:"AES-KW"},!0,["wrapKey"]),e=>Promise.reject(e))).then(e=>m.wrapKey("raw",i,e,{name:"AES-KW"}),e=>Promise.reject(e))).then(t=>{const r=ve(n),s=new rr;s.variant=3,s.value=new tr({schema:r.result}),"algorithmParams"in s.value.algorithm&&delete s.value.algorithm.algorithmParams,u.recipientInfos[e].value.originator=s,u.recipientInfos[e].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey=new j({valueHex:t})},e=>Promise.reject(e))}function d(e){let t=Promise.resolve();return t=(t=(t=t.then(()=>{const t=u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmParams,r=new dr({schema:t}),s=Xe(r.hashAlgorithm.algorithmId);return"name"in s==!1?Promise.reject(`Incorrect OID for hash algorithm: ${r.hashAlgorithm.algorithmId}`):u.recipientInfos[e].value.recipientCertificate.getPublicKey({algorithm:{algorithm:{name:"RSA-OAEP",hash:{name:s.name}},usages:["encrypt","wrapKey"]}})},e=>Promise.reject(e))).then(e=>m.encrypt(e.algorithm,e,l),e=>Promise.reject(e))).then(t=>{u.recipientInfos[e].value.encryptedKey=new j({valueHex:t})},e=>Promise.reject(e))}function g(e){let t,r=Promise.resolve();return r=(r=(r=r.then(()=>"name"in(t=Xe(u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId))==!1?Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId}`):m.importKey("raw",new Uint8Array(u.recipientInfos[e].value.preDefinedKEK),t,!0,["wrapKey"]),e=>Promise.reject(e))).then(e=>m.wrapKey("raw",i,e,t),e=>Promise.reject(e))).then(t=>{u.recipientInfos[e].value.encryptedKey=new j({valueHex:t})},e=>Promise.reject(e))}function p(e){let t,r,s=Promise.resolve();return s=(s=(s=(s=(s=s.then(()=>{if("keyDerivationAlgorithm"in u.recipientInfos[e].value==!1)return Promise.reject('Please append encoded "keyDerivationAlgorithm"');if("algorithmParams"in u.recipientInfos[e].value.keyDerivationAlgorithm==!1)return Promise.reject('Incorrectly encoded "keyDerivationAlgorithm"');try{t=new $e({schema:u.recipientInfos[e].value.keyDerivationAlgorithm.algorithmParams})}catch(e){return Promise.reject('Incorrectly encoded "keyDerivationAlgorithm"')}return Promise.resolve()},e=>Promise.reject(e))).then(()=>{const t=new Uint8Array(u.recipientInfos[e].value.password);return m.importKey("raw",t,"PBKDF2",!1,["deriveKey"])},e=>Promise.reject(e))).then(s=>{if("name"in(r=Xe(u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId))==!1)return Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${u.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId}`);let a="SHA-1";if("prf"in t){const e=Xe(t.prf.algorithmId);if("name"in e==!1)return Promise.reject("Incorrect OID for HMAC hash algorithm");a=e.hash.name}const n=new Uint8Array(t.salt.valueBlock.valueHex),i=t.iterationCount;return m.deriveKey({name:"PBKDF2",hash:{name:a},salt:n,iterations:i},s,r,!0,["wrapKey"])},e=>Promise.reject(e))).then(e=>m.wrapKey("raw",i,e,r),e=>Promise.reject(e))).then(t=>{u.recipientInfos[e].value.encryptedKey=new j({valueHex:t})},e=>Promise.reject(e))}return r=(r=(r=(r=(r=r.then(()=>m.generateKey(e,!0,["encrypt"]))).then(t=>(i=t,m.encrypt({name:e.name,iv:a},i,n)),e=>Promise.reject(e))).then(e=>(o=e,m.exportKey("raw",i)),e=>Promise.reject(e)).then(e=>(l=e,!0),e=>Promise.reject(e))).then(()=>{this.version=2,this.encryptedContentInfo=new Te({contentType:"1.2.840.113549.1.7.1",contentEncryptionAlgorithm:new Ve({algorithmId:h,algorithmParams:new j({valueHex:s})}),encryptedContent:new j({valueHex:o})})},e=>Promise.reject(e))).then(()=>{for(let e=0;e<this.recipientInfos.length;e++){let t=Promise.resolve();switch(this.recipientInfos[e].variant){case 1:t=d(e);break;case 2:t=f(e);break;case 3:t=g(e);break;case 4:t=p(e);break;default:return Promise.reject(`Uknown recipient type in array with index ${e}`)}c.push(t)}return Promise.all(c)},e=>Promise.reject(e))}decrypt(e,t){let r=Promise.resolve();const s=t||{},a=this;if(e+1>this.recipientInfos.length)return Promise.reject(`Maximum value for "index" is: ${this.recipientInfos.length-1}`);const n=_e();if(void 0===n)return Promise.reject("Unable to create WebCrypto object");function i(e){let t,r,i,o,l=Promise.resolve();return l=(l=(l=(l=(l=(l=l.then(()=>{if("recipientCertificate"in s==!1)return Promise.reject('Parameter "recipientCertificate" is mandatory for "KeyAgreeRecipientInfo"');if("recipientPrivateKey"in s==!1)return Promise.reject('Parameter "recipientPrivateKey" is mandatory for "KeyAgreeRecipientInfo"');const a=s.recipientCertificate.subjectPublicKeyInfo.algorithm.algorithmParams;if(a instanceof $==!1)return Promise.reject(`Incorrect "recipientCertificate" for index ${e}`);switch(i=a.valueBlock.toString()){case"1.2.840.10045.3.1.7":t="P-256",r=256;break;case"1.3.132.0.34":t="P-384",r=384;break;case"1.3.132.0.35":t="P-521",r=528;break;default:return Promise.reject(`Incorrect curve OID for index ${e}`)}return n.importKey("pkcs8",s.recipientPrivateKey,{name:"ECDH",namedCurve:t},!0,["deriveBits"])},e=>Promise.reject(e))).then(r=>{o=r,"algorithmParams"in a.recipientInfos[e].value.originator.value.algorithm==!1&&(a.recipientInfos[e].value.originator.value.algorithm.algorithmParams=new $({value:i}));const s=a.recipientInfos[e].value.originator.value.toSchema().toBER(!1);return n.importKey("spki",s,{name:"ECDH",namedCurve:t},!0,[])},e=>Promise.reject(e))).then(e=>n.deriveBits({name:"ECDH",public:e},o,r),e=>Promise.reject(e))).then(t=>{const r=new Ve({schema:a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmParams}),s=Xe(r.algorithmId);if("name"in s==!1)return Promise.reject(`Incorrect OID for key encryption algorithm: ${r.algorithmId}`);let n=s.length;const i=new ArrayBuffer(4),o=new Uint8Array(i);for(let e=3;e>=0;e--)o[e]=n,n>>=8;const l=new gr({keyInfo:new Ve({algorithmId:r.algorithmId,algorithmParams:new D}),entityUInfo:a.recipientInfos[e].value.ukm,suppPubInfo:new j({valueHex:i})}).toSchema().toBER(!1),c=Xe(a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId);return"name"in c==!1?Promise.reject(`Incorrect OID for key encryption algorithm: ${a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId}`):rt(c.kdf,t,s.length,l)},e=>Promise.reject(e))).then(e=>n.importKey("raw",e,{name:"AES-KW"},!0,["unwrapKey"]),e=>Promise.reject(e))).then(t=>{const r=Xe(a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);return"name"in r==!1?Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`):n.unwrapKey("raw",a.recipientInfos[e].value.recipientEncryptedKeys.encryptedKeys[0].encryptedKey.valueBlock.valueHex,t,{name:"AES-KW"},r,!0,["decrypt"])},e=>Promise.reject(e))}function o(e){let t=Promise.resolve();return t=(t=(t=t.then(()=>{if("recipientPrivateKey"in s==!1)return Promise.reject('Parameter "recipientPrivateKey" is mandatory for "KeyTransRecipientInfo"');const t=a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmParams,r=new dr({schema:t}),i=Xe(r.hashAlgorithm.algorithmId);return"name"in i==!1?Promise.reject(`Incorrect OID for hash algorithm: ${r.hashAlgorithm.algorithmId}`):n.importKey("pkcs8",s.recipientPrivateKey,{name:"RSA-OAEP",hash:{name:i.name}},!0,["decrypt"])},e=>Promise.reject(e))).then(t=>n.decrypt(t.algorithm,t,a.recipientInfos[e].value.encryptedKey.valueBlock.valueHex),e=>Promise.reject(e))).then(e=>{const t=Xe(a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);return"name"in t==!1?Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`):n.importKey("raw",e,t,!0,["decrypt"])},e=>Promise.reject(e))}function l(e){let t,r=Promise.resolve();return r=(r=r.then(()=>"preDefinedData"in s==!1?Promise.reject('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"'):"name"in(t=Xe(a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId))==!1?Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId}`):n.importKey("raw",s.preDefinedData,t,!0,["unwrapKey"]),e=>Promise.reject(e))).then(r=>{const s=Xe(a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);return"name"in s==!1?Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`):n.unwrapKey("raw",a.recipientInfos[e].value.encryptedKey.valueBlock.valueHex,r,t,s,!0,["decrypt"])},e=>Promise.reject(e))}function c(e){let t,r,i=Promise.resolve();return i=(i=(i=i.then(()=>{if("preDefinedData"in s==!1)return Promise.reject('Parameter "preDefinedData" is mandatory for "KEKRecipientInfo"');if("keyDerivationAlgorithm"in a.recipientInfos[e].value==!1)return Promise.reject('Please append encoded "keyDerivationAlgorithm"');if("algorithmParams"in a.recipientInfos[e].value.keyDerivationAlgorithm==!1)return Promise.reject('Incorrectly encoded "keyDerivationAlgorithm"');try{t=new $e({schema:a.recipientInfos[e].value.keyDerivationAlgorithm.algorithmParams})}catch(e){return Promise.reject('Incorrectly encoded "keyDerivationAlgorithm"')}return n.importKey("raw",s.preDefinedData,"PBKDF2",!1,["deriveKey"])},e=>Promise.reject(e))).then(s=>{if("name"in(r=Xe(a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId))==!1)return Promise.reject(`Incorrect OID for "keyEncryptionAlgorithm": ${a.recipientInfos[e].value.keyEncryptionAlgorithm.algorithmId}`);let i="SHA-1";if("prf"in t){const e=Xe(t.prf.algorithmId);if("name"in e==!1)return Promise.reject("Incorrect OID for HMAC hash algorithm");i=e.hash.name}const o=new Uint8Array(t.salt.valueBlock.valueHex),l=t.iterationCount;return n.deriveKey({name:"PBKDF2",hash:{name:i},salt:o,iterations:l},s,r,!0,["unwrapKey"])},e=>Promise.reject(e))).then(t=>{const s=Xe(a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);return"name"in s==!1?Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${a.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`):n.unwrapKey("raw",a.recipientInfos[e].value.encryptedKey.valueBlock.valueHex,t,r,s,!0,["decrypt"])},e=>Promise.reject(e))}return r=(r=r.then(()=>{let t=Promise.resolve();switch(this.recipientInfos[e].variant){case 1:t=o(e);break;case 2:t=i(e);break;case 3:t=l(e);break;case 4:t=c(e);break;default:return Promise.reject(`Uknown recipient type in array with index ${e}`)}return t},e=>Promise.reject(e))).then(e=>{const t=Xe(this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Incorrect "contentEncryptionAlgorithm": ${this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId}`);const r=this.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams.valueBlock.valueHex,s=new Uint8Array(r);let a=new ArrayBuffer(0);if(!1===this.encryptedContentInfo.encryptedContent.idBlock.isConstructed)a=this.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else for(const e of this.encryptedContentInfo.encryptedContent.valueBlock.value)a=Ae(a,e.valueBlock.valueHex);return n.decrypt({name:t.name,iv:s},e,a)},e=>Promise.reject(e))}}class yr{constructor(e={}){this.safeContents=be(e,"safeContents",yr.defaultValues("safeContents")),"parsedValue"in e&&(this.parsedValue=be(e,"parsedValue",yr.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"safeContents":return[];case"parsedValue":return{};default:throw new Error(`Invalid member name for AuthenticatedSafe class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"safeContents":return 0===t.length;case"parsedValue":return t instanceof Object&&0===Object.keys(t).length;default:throw new Error(`Invalid member name for AuthenticatedSafe class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new ge({name:t.contentInfos||"",value:ct.schema()})]})}fromSchema(e){const t=we(e,e,yr.schema({names:{contentInfos:"contentInfos"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AuthenticatedSafe");this.safeContents=Array.from(t.result.contentInfos,e=>new ct({schema:e}))}toSchema(){return new x({value:Array.from(this.safeContents,e=>e.toSchema())})}toJSON(){return{safeContents:Array.from(this.safeContents,e=>e.toJSON())}}parseInternalValues(e){if(e instanceof Object==!1)return Promise.reject('The "parameters" must has "Object" type');if("safeContents"in e==!1)return Promise.reject('Absent mandatory parameter "safeContents"');if(e.safeContents instanceof Array==!1)return Promise.reject('The "parameters.safeContents" must has "Array" type');if(e.safeContents.length!==this.safeContents.length)return Promise.reject('Length of "parameters.safeContents" must be equal to "this.safeContents.length"');let t=Promise.resolve();this.parsedValue={safeContents:[]};for(const[r,s]of this.safeContents.entries())switch(s.contentType){case"1.2.840.113549.1.7.1":{if(s.content instanceof j==!1)return Promise.reject('Wrong type of "this.safeContents[j].content"');let e=new ArrayBuffer(0);if(s.content.valueBlock.isConstructed)for(const t of s.content.valueBlock.value)e=Ae(e,t.valueBlock.valueHex);else e=s.content.valueBlock.valueHex;const t=ve(e);if(-1===t.offset)return Promise.reject('Error during parsing of ASN.1 data inside "content.content"');this.parsedValue.safeContents.push({privacyMode:0,value:new _t({schema:t.result})})}break;case"1.2.840.113549.1.7.3":{const a=new pr({schema:s.content});if("recipientCertificate"in e.safeContents[r]==!1)return Promise.reject('Absent mandatory parameter "recipientCertificate" in "parameters.safeContents[j]"');const n=e.safeContents[r].recipientCertificate;if("recipientKey"in e.safeContents[r]==!1)return Promise.reject('Absent mandatory parameter "recipientKey" in "parameters.safeContents[j]"');const i=e.safeContents[r].recipientKey;t=(t=t.then(()=>a.decrypt(0,{recipientCertificate:n,recipientPrivateKey:i}))).then(e=>{const t=ve(e);return-1===t.offset?Promise.reject("Error during parsing of decrypted data"):(this.parsedValue.safeContents.push({privacyMode:2,value:new _t({schema:t.result})}),Promise.resolve())})}break;case"1.2.840.113549.1.7.6":{const a=new ut({schema:s.content});if("password"in e.safeContents[r]==!1)return Promise.reject('Absent mandatory parameter "password" in "parameters.safeContents[j]"');const n=e.safeContents[r].password;t=(t=t.then(()=>a.decrypt({password:n}),e=>Promise.reject(e))).then(e=>{const t=ve(e);return-1===t.offset?Promise.reject("Error during parsing of decrypted data"):(this.parsedValue.safeContents.push({privacyMode:1,value:new _t({schema:t.result})}),Promise.resolve())},e=>Promise.reject(e))}break;default:throw new Error(`Unknown "contentType" for AuthenticatedSafe: " ${s.contentType}`)}return t}makeInternalValues(e){if("parsedValue"in this==!1)return Promise.reject('Please run "parseValues" first or add "parsedValue" manually');if(this.parsedValue instanceof Object==!1)return Promise.reject('The "this.parsedValue" must has "Object" type');if(this.parsedValue.safeContents instanceof Array==!1)return Promise.reject('The "this.parsedValue.safeContents" must has "Array" type');if(e instanceof Object==!1)return Promise.reject('The "parameters" must has "Object" type');if("safeContents"in e==!1)return Promise.reject('Absent mandatory parameter "safeContents"');if(e.safeContents instanceof Array==!1)return Promise.reject('The "parameters.safeContents" must has "Array" type');if(e.safeContents.length!==this.parsedValue.safeContents.length)return Promise.reject('Length of "parameters.safeContents" must be equal to "this.parsedValue.safeContents"');let t=Promise.resolve();this.safeContents=[];for(const[r,s]of this.parsedValue.safeContents.entries()){if("privacyMode"in s==!1)return Promise.reject('The "privacyMode" is a mandatory parameter for "content"');if("value"in s==!1)return Promise.reject('The "value" is a mandatory parameter for "content"');if(s.value instanceof _t==!1)return Promise.reject('The "content.value" must has "SafeContents" type');switch(s.privacyMode){case 0:{const e=s.value.toSchema().toBER(!1);t=t.then(()=>{this.safeContents.push(new ct({contentType:"1.2.840.113549.1.7.1",content:new j({valueHex:e})}))})}break;case 1:{const a=new ut,n=e.safeContents[r];n.contentToEncrypt=s.value.toSchema().toBER(!1),t=(t=t.then(()=>a.encrypt(n),e=>Promise.reject(e))).then(()=>{this.safeContents.push(new ct({contentType:"1.2.840.113549.1.7.6",content:a.toSchema()}))},e=>Promise.reject(e))}break;case 2:{const a=new pr,n=s.value.toSchema().toBER(!1);if("encryptingCertificate"in e.safeContents[r]==!1)return Promise.reject('Absent mandatory parameter "encryptingCertificate" in "parameters.safeContents[i]"');if("encryptionAlgorithm"in e.safeContents[r]==!1)return Promise.reject('Absent mandatory parameter "encryptionAlgorithm" in "parameters.safeContents[i]"');switch(!0){case"aes-cbc"===e.safeContents[r].encryptionAlgorithm.name.toLowerCase():case"aes-gcm"===e.safeContents[r].encryptionAlgorithm.name.toLowerCase():break;default:return Promise.reject(`Incorrect parameter "encryptionAlgorithm" in "parameters.safeContents[i]": ${e.safeContents[r].encryptionAlgorithm}`)}switch(!0){case 128===e.safeContents[r].encryptionAlgorithm.length:case 192===e.safeContents[r].encryptionAlgorithm.length:case 256===e.safeContents[r].encryptionAlgorithm.length:break;default:return Promise.reject(`Incorrect parameter "encryptionAlgorithm.length" in "parameters.safeContents[i]": ${e.safeContents[r].encryptionAlgorithm.length}`)}const i=e.safeContents[r].encryptionAlgorithm;a.addRecipientByCertificate(e.safeContents[r].encryptingCertificate),t=(t=t.then(()=>a.encrypt(i,n))).then(()=>{this.safeContents.push(new ct({contentType:"1.2.840.113549.1.7.3",content:a.toSchema()}))})}break;default:return Promise.reject(`Incorrect value for "content.privacyMode": ${s.privacyMode}`)}}return t.then(()=>this,e=>Promise.reject(`Error during parsing: ${e}`))}}class vr{constructor(e={}){this.hashAlgorithm=be(e,"hashAlgorithm",vr.defaultValues("hashAlgorithm")),this.issuerNameHash=be(e,"issuerNameHash",vr.defaultValues("issuerNameHash")),this.issuerKeyHash=be(e,"issuerKeyHash",vr.defaultValues("issuerKeyHash")),this.serialNumber=be(e,"serialNumber",vr.defaultValues("serialNumber")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new Ve;case"issuerNameHash":case"issuerKeyHash":return new j;case"serialNumber":return new R;default:throw new Error(`Invalid member name for CertID class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"hashAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"issuerNameHash":case"issuerKeyHash":case"serialNumber":return t.isEqual(vr.defaultValues(e));default:throw new Error(`Invalid member name for CertID class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[Ve.schema(t.hashAlgorithmObject||{names:{blockName:t.hashAlgorithm||""}}),new j({name:t.issuerNameHash||""}),new j({name:t.issuerKeyHash||""}),new R({name:t.serialNumber||""})]})}fromSchema(e){const t=we(e,e,vr.schema({names:{hashAlgorithm:"hashAlgorithm",issuerNameHash:"issuerNameHash",issuerKeyHash:"issuerKeyHash",serialNumber:"serialNumber"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertID");this.hashAlgorithm=new Ve({schema:t.result.hashAlgorithm}),this.issuerNameHash=t.result.issuerNameHash,this.issuerKeyHash=t.result.issuerKeyHash,this.serialNumber=t.result.serialNumber}toSchema(){return new x({value:[this.hashAlgorithm.toSchema(),this.issuerNameHash,this.issuerKeyHash,this.serialNumber]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),issuerNameHash:this.issuerNameHash.toJSON(),issuerKeyHash:this.issuerKeyHash.toJSON(),serialNumber:this.serialNumber.toJSON()}}isEqual(e){return!this.hashAlgorithm.algorithmId!==e.hashAlgorithm.algorithmId&&(!1!==Se(this.issuerNameHash.valueBlock.valueHex,e.issuerNameHash.valueBlock.valueHex)&&(!1!==Se(this.issuerKeyHash.valueBlock.valueHex,e.issuerKeyHash.valueBlock.valueHex)&&!!this.serialNumber.isEqual(e.serialNumber)))}createForCertificate(e,t){let r,s=Promise.resolve();const a=_e();if(void 0===a)return Promise.reject("Unable to create WebCrypto object");if("hashAlgorithm"in t==!1)return Promise.reject('Parameter "hashAlgorithm" is mandatory for "OCSP_REQUEST.createForCertificate"');const n=Qe({name:t.hashAlgorithm});return""===n?Promise.reject(`Incorrect "hashAlgorithm": ${this.hashAlgorithm}`):(this.hashAlgorithm=new Ve({algorithmId:n,algorithmParams:new D}),"issuerCertificate"in t?(r=t.issuerCertificate,this.serialNumber=e.serialNumber,s=(s=s.then(()=>a.digest({name:t.hashAlgorithm},r.subject.toSchema().toBER(!1)),e=>Promise.reject(e))).then(e=>{this.issuerNameHash=new j({valueHex:e});const s=r.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex;return a.digest({name:t.hashAlgorithm},s)},e=>Promise.reject(e)).then(e=>{this.issuerKeyHash=new j({valueHex:e})},e=>Promise.reject(e))):Promise.reject('Parameter "issuerCertificate" is mandatory for "OCSP_REQUEST.createForCertificate"'))}}class wr{constructor(e={}){this.certID=be(e,"certID",wr.defaultValues("certID")),this.certStatus=be(e,"certStatus",wr.defaultValues("certStatus")),this.thisUpdate=be(e,"thisUpdate",wr.defaultValues("thisUpdate")),"nextUpdate"in e&&(this.nextUpdate=be(e,"nextUpdate",wr.defaultValues("nextUpdate"))),"singleExtensions"in e&&(this.singleExtensions=be(e,"singleExtensions",wr.defaultValues("singleExtensions"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certID":return new vr;case"certStatus":return{};case"thisUpdate":case"nextUpdate":return new Date(0,0,0);case"singleExtensions":return[];default:throw new Error(`Invalid member name for SingleResponse class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"certID":return vr.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&vr.compareWithDefault("issuerNameHash",t.issuerNameHash)&&vr.compareWithDefault("issuerKeyHash",t.issuerKeyHash)&&vr.compareWithDefault("serialNumber",t.serialNumber);case"certStatus":return 0===Object.keys(t).length;case"thisUpdate":case"nextUpdate":return t===wr.defaultValues(e);default:throw new Error(`Invalid member name for SingleResponse class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[vr.schema(t.certID||{}),new fe({value:[new S({name:t.certStatus||"",idBlock:{tagClass:3,tagNumber:0},lenBlockLength:1}),new I({name:t.certStatus||"",idBlock:{tagClass:3,tagNumber:1},value:[new oe,new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new L]})]}),new S({name:t.certStatus||"",idBlock:{tagClass:3,tagNumber:2},lenBlock:{length:1}})]}),new oe({name:t.thisUpdate||""}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new oe({name:t.nextUpdate||""})]}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[Dt.schema(t.singleExtensions||{})]})]})}fromSchema(e){const t=we(e,e,wr.schema({names:{certID:{names:{blockName:"certID"}},certStatus:"certStatus",thisUpdate:"thisUpdate",nextUpdate:"nextUpdate",singleExtensions:{names:{blockName:"singleExtensions"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SingleResponse");this.certID=new vr({schema:t.result.certID}),this.certStatus=t.result.certStatus,this.thisUpdate=t.result.thisUpdate.toDate(),"nextUpdate"in t.result&&(this.nextUpdate=t.result.nextUpdate.toDate()),"singleExtensions"in t.result&&(this.singleExtensions=Array.from(t.result.singleExtensions.valueBlock.value,e=>new Vt({schema:e})))}toSchema(){const e=[];return e.push(this.certID.toSchema()),e.push(this.certStatus),e.push(new oe({valueDate:this.thisUpdate})),"nextUpdate"in this&&e.push(new oe({valueDate:this.nextUpdate})),"singleExtensions"in this&&e.push(new x({value:Array.from(this.singleExtensions,e=>e.toSchema())})),new x({value:e})}toJSON(){const e={certID:this.certID.toJSON(),certStatus:this.certStatus.toJSON(),thisUpdate:this.thisUpdate};return"nextUpdate"in this&&(e.nextUpdate=this.nextUpdate),"singleExtensions"in this&&(e.singleExtensions=Array.from(this.singleExtensions,e=>e.toJSON())),e}}class br{constructor(e={}){this.tbs=be(e,"tbs",br.defaultValues("tbs")),this.responderID=be(e,"responderID",br.defaultValues("responderID")),this.producedAt=be(e,"producedAt",br.defaultValues("producedAt")),this.responses=be(e,"responses",br.defaultValues("responses")),"responseExtensions"in e&&(this.responseExtensions=be(e,"responseExtensions",br.defaultValues("responseExtensions"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"responderID":return{};case"producedAt":return new Date(0,0,0);case"responses":case"responseExtensions":return[];default:throw new Error(`Invalid member name for ResponseData class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"tbs":return 0===t.byteLength;case"responderID":return 0===Object.keys(t).length;case"producedAt":return t===br.defaultValues(e);case"responses":case"responseExtensions":return 0===t.length;default:throw new Error(`Invalid member name for ResponseData class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"ResponseData",value:[new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new R({name:t.version||"ResponseData.version"})]}),new fe({value:[new I({name:t.responderID||"ResponseData.responderID",idBlock:{tagClass:3,tagNumber:1},value:[at.schema(t.ResponseDataByName||{names:{blockName:"ResponseData.byName"}})]}),new I({name:t.responderID||"ResponseData.responderID",idBlock:{tagClass:3,tagNumber:2},value:[new j({name:t.ResponseDataByKey||"ResponseData.byKey"})]})]}),new oe({name:t.producedAt||"ResponseData.producedAt"}),new x({value:[new ge({name:"ResponseData.responses",value:wr.schema(t.response||{})})]}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[Dt.schema(t.extensions||{names:{blockName:"ResponseData.responseExtensions"}})]})]})}fromSchema(e){const t=we(e,e,br.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ocsp.ResponseData");this.tbs=t.result.ResponseData.valueBeforeDecode,"ResponseData.version"in t.result&&(this.version=t.result["ResponseData.version"].valueBlock.valueDec),1===t.result["ResponseData.responderID"].idBlock.tagNumber?this.responderID=new at({schema:t.result["ResponseData.responderID"].valueBlock.value[0]}):this.responderID=t.result["ResponseData.responderID"].valueBlock.value[0],this.producedAt=t.result["ResponseData.producedAt"].toDate(),this.responses=Array.from(t.result["ResponseData.responses"],e=>new wr({schema:e})),"ResponseData.responseExtensions"in t.result&&(this.responseExtensions=Array.from(t.result["ResponseData.responseExtensions"].valueBlock.value,e=>new Vt({schema:e})))}toSchema(e=!1){let t;if(!1===e){if(0===this.tbs.length)return br.schema();t=ve(this.tbs).result}else{const e=[];"version"in this&&e.push(new I({idBlock:{tagClass:3,tagNumber:0},value:[new R({value:this.version})]})),this.responderID instanceof at?e.push(new I({idBlock:{tagClass:3,tagNumber:1},value:[this.responderID.toSchema()]})):e.push(new I({idBlock:{tagClass:3,tagNumber:2},value:[this.responderID]})),e.push(new oe({valueDate:this.producedAt})),e.push(new x({value:Array.from(this.responses,e=>e.toSchema())})),"responseExtensions"in this&&e.push(new x({value:Array.from(this.responseExtensions,e=>e.toSchema())})),t=new x({value:e})}return t}toJSON(){const e={};return"version"in this&&(e.version=this.version),"responderID"in this&&(e.responderID=this.responderID),"producedAt"in this&&(e.producedAt=this.producedAt),"responses"in this&&(e.responses=Array.from(this.responses,e=>e.toJSON())),"responseExtensions"in this&&(e.responseExtensions=Array.from(this.responseExtensions,e=>e.toJSON())),e}}class kr{constructor(e={}){this.trustedCerts=be(e,"trustedCerts",this.defaultValues("trustedCerts")),this.certs=be(e,"certs",this.defaultValues("certs")),this.crls=be(e,"crls",this.defaultValues("crls")),this.ocsps=be(e,"ocsps",this.defaultValues("ocsps")),this.checkDate=be(e,"checkDate",this.defaultValues("checkDate")),this.findOrigin=be(e,"findOrigin",this.defaultValues("findOrigin")),this.findIssuer=be(e,"findIssuer",this.defaultValues("findIssuer")),"schema"in e&&this.fromSchema(e.schema)}defaultFindOrigin(e,t){0===e.tbs.byteLength&&(e.tbs=e.encodeTBS());for(const t of this.certs)if(0===t.tbs.byteLength&&(t.tbs=t.encodeTBS()),Se(e.tbs,t.tbs))return"Intermediate Certificates";for(const t of this.trustedCerts)if(0===t.tbs.byteLength&&(t.tbs=t.encodeTBS()),Se(e.tbs,t.tbs))return"Trusted Certificates";return"Unknown"}async defaultFindIssuer(e,t){let r=[],s=null,a=null,n=null;if(e.subject.isEqual(e.issuer))try{if(!0===await e.verify())return[e]}catch(e){}if("extensions"in e)for(const t of e.extensions)if("2.5.29.35"===t.extnID){"keyIdentifier"in t.parsedValue?s=t.parsedValue.keyIdentifier:("authorityCertIssuer"in t.parsedValue&&(a=t.parsedValue.authorityCertIssuer),"authorityCertSerialNumber"in t.parsedValue&&(n=t.parsedValue.authorityCertSerialNumber));break}function i(t){if(null!==s&&"extensions"in t){let e=!1;for(const a of t.extensions)if("2.5.29.14"===a.extnID){e=!0,Se(a.parsedValue.valueBlock.valueHex,s.valueBlock.valueHex)&&r.push(t);break}if(e)return}let i=!1;null!==n&&(i=t.serialNumber.isEqual(n)),null!==a?t.subject.isEqual(a)&&i&&r.push(t):e.issuer.isEqual(t.subject)&&r.push(t)}for(const e of t.trustedCerts)i(e);for(const e of t.certs)i(e);for(let t=0;t<r.length;t++)try{!1===await e.verify(r[t])&&r.splice(t,1)}catch(e){r.splice(t,1)}return r}defaultValues(e){switch(e){case"trustedCerts":case"certs":case"crls":case"ocsps":return[];case"checkDate":return new Date;case"findOrigin":return this.defaultFindOrigin;case"findIssuer":return this.defaultFindIssuer;default:throw new Error(`Invalid member name for CertificateChainValidationEngine class: ${e}`)}}async sort(){const e=[],t=this;async function r(e){const s=[];function a(e){let t=!0;for(let r=0;r<e.length;r++){for(let s=0;s<e.length;s++)if(s!==r&&e[r]===e[s]){t=!1;break}if(!t)break}return t}const n=await t.findIssuer(e,t);if(0===n.length)throw new Error("No valid certificate paths found");for(let t=0;t<n.length;t++){if(Se(n[t].tbs,e.tbs)){s.push([n[t]]);continue}const i=await r(n[t]);for(let e=0;e<i.length;e++){const r=i[e].slice();r.splice(0,0,n[t]),a(r)?s.push(r):s.push(i[e])}}return s}async function s(r){const s=[],a=[],n=[];if(s.push(...e.filter(e=>r.issuer.isEqual(e.subject))),0===s.length)return{status:1,statusMessage:"No certificate's issuers"};if(a.push(...t.crls.filter(e=>e.issuer.isEqual(r.issuer))),0===a.length)return{status:1,statusMessage:"No CRLs for specific certificate issuer"};for(let e=0;e<a.length;e++)if(!(a[e].nextUpdate.value<t.checkDate))for(let t=0;t<s.length;t++)try{if(await a[e].verify({issuerCertificate:s[t]})){n.push({crl:a[e],certificate:s[t]});break}}catch(e){}return n.length?{status:0,statusMessage:"",result:n}:{status:1,statusMessage:"No valid CRLs found"}}async function a(e,r){const s=Xe(e.signatureAlgorithm.algorithmId);if("name"in s==!1)return 1;if("hash"in s==!1)return 1;for(let s=0;s<t.ocsps.length;s++){const a=await t.ocsps[s].getCertificateStatus(e,r);if(a.isForCertificate)return 0===a.status?0:1}return 2}async function n(e,t=!1){let r=!1,s=!1,a=!1,n=!1;if("extensions"in e){for(let t=0;t<e.extensions.length;t++){if(!0===e.extensions[t].critical&&"parsedValue"in e.extensions[t]==!1)return{result:!1,resultCode:6,resultMessage:`Unable to parse critical certificate extension: ${e.extensions[t].extnID}`};if("2.5.29.15"===e.extensions[t].extnID){a=!0;const r=new Uint8Array(e.extensions[t].parsedValue.valueBlock.valueHex);4==(4&r[0])&&(s=!0),2==(2&r[0])&&(n=!0)}"2.5.29.19"===e.extensions[t].extnID&&"cA"in e.extensions[t].parsedValue&&!0===e.extensions[t].parsedValue.cA&&(r=!0)}if(!0===s&&!1===r)return{result:!1,resultCode:3,resultMessage:'Unable to build certificate chain - using "keyCertSign" flag set without BasicConstaints'};if(!0===a&&!0===r&&!1===s)return{result:!1,resultCode:4,resultMessage:'Unable to build certificate chain - "keyCertSign" flag was not set'};if(!0===r&&!0===a&&t&&!1===n)return{result:!1,resultCode:5,resultMessage:'Unable to build certificate chain - intermediate certificate must have "cRLSign" key usage flag'}}return!1===r?{result:!1,resultCode:7,resultMessage:"Unable to build certificate chain - more than one possible end-user certificate"}:{result:!0,resultCode:0,resultMessage:""}}async function i(e,r){for(let t=0;t<e.length;t++)if(e[t].notBefore.value>r||e[t].notAfter.value<r)return{result:!1,resultCode:8,resultMessage:"Certificate validity period is out of checking date"};if(e.length<2)return{result:!1,resultCode:9,resultMessage:"Too short certificate path"};for(let t=e.length-2;t>=0;t--)if(!1===e[t].issuer.isEqual(e[t].subject)&&!1===e[t].issuer.isEqual(e[t+1].subject))return{result:!1,resultCode:10,resultMessage:"Incorrect name chaining"};if(0!==t.crls.length||0!==t.ocsps.length)for(let r=0;r<e.length-2;r++){let i,o;if(0!==t.ocsps.length)switch(i=await a(e[r],e[r+1])){case 0:continue;case 1:return{result:!1,resultCode:12,resultMessage:"One of certificates was revoked via OCSP response"}}if(0!==t.crls.length){if((o=await s(e[r])).status)throw{result:!1,resultCode:11,resultMessage:`No revocation values found for one of certificates: ${o.statusMessage}`};for(let t=0;t<o.result.length;t++){if(o.result[t].crl.isCertificateRevoked(e[r]))return{result:!1,resultCode:12,resultMessage:"One of certificates had been revoked"};if(!1===(await n(o.result[t].certificate,!0)).result)return{result:!1,resultCode:13,resultMessage:"CRL issuer certificate is not a CA certificate or does not have crlSign flag"}}}else if(2===i)return{result:!1,resultCode:11,resultMessage:"No revocation values found for one of certificates"}}for(let t=1;t<e.length;t++){if(!1===(await n(e[t])).result)return{result:!1,resultCode:14,resultMessage:"One of intermediate certificates is not a CA certificate"}}return{result:!0}}e.push(...t.trustedCerts),e.push(...t.certs);for(let t=0;t<e.length;t++)for(let r=0;r<e.length;r++)if(t!==r&&Se(e[t].tbs,e[r].tbs)){e.splice(r,1),t=0;break}let o;const l=[e[e.length-1]];if(0===(o=await r(e[e.length-1])).length)return{result:!1,resultCode:60,resultMessage:"Unable to find certificate path"};for(let e=0;e<o.length;e++){let r=!1;for(let s=0;s<o[e].length;s++){const a=o[e][s];for(let e=0;e<t.trustedCerts.length;e++)if(Se(a.tbs,t.trustedCerts[e].tbs)){r=!0;break}if(r)break}r||(o.splice(e,1),e=0)}if(0===o.length)throw{result:!1,resultCode:97,resultMessage:"No valid certificate paths found"};let c=o[0].length,u=0;for(let e=0;e<o.length;e++)o[e].length<c&&(c=o[e].length,u=e);for(let e=0;e<o[u].length;e++)l.push(o[u][e]);if(!1===(o=await i(l,t.checkDate)).result)throw o;return l}async verify(e={}){try{if(0===this.certs.length)throw"Empty certificate array";let i=[];i.push("2.5.29.32.0");let o=!1,l=!1,c=!1,u=[],h=[],m=[];"initialPolicySet"in e&&(i=e.initialPolicySet),"initialExplicitPolicy"in e&&(o=e.initialExplicitPolicy),"initialPolicyMappingInhibit"in e&&(l=e.initialPolicyMappingInhibit),"initialInhibitPolicy"in e&&(c=e.initialInhibitPolicy),"initialPermittedSubtreesSet"in e&&(u=e.initialPermittedSubtreesSet),"initialExcludedSubtreesSet"in e&&(h=e.initialExcludedSubtreesSet),"initialRequiredNameForms"in e&&(m=e.initialRequiredNameForms);let f=o,d=l,g=c;const p=new Array(3);p[0]=!1,p[1]=!1,p[2]=!1;let y=0,v=0,w=0,b=u,k=h;const A=m;let S=1;this.certs=await this.sort();const C=[];C.push("2.5.29.32.0");const I=[],B=new Array(this.certs.length-1);for(let e=0;e<this.certs.length-1;e++)B[e]=!0;I.push(B);const N=new Array(this.certs.length-1),P=new Array(this.certs.length-1);let E=f?this.certs.length-1:-1;for(let e=this.certs.length-2;e>=0;e--,S++)if("extensions"in this.certs[e]){for(let t=0;t<this.certs[e].extensions.length;t++){if("2.5.29.32"===this.certs[e].extensions[t].extnID){P[e]=this.certs[e].extensions[t].parsedValue;for(let t=0;t<C.length;t++)if("2.5.29.32.0"===C[t]){delete I[t][e];break}for(let r=0;r<this.certs[e].extensions[t].parsedValue.certificatePolicies.length;r++){let s=-1;for(let a=0;a<C.length;a++)if(this.certs[e].extensions[t].parsedValue.certificatePolicies[r].policyIdentifier===C[a]){s=a;break}if(-1===s){C.push(this.certs[e].extensions[t].parsedValue.certificatePolicies[r].policyIdentifier);const s=new Array(this.certs.length-1);s[e]=!0,I.push(s)}else I[s][e]=!0}}if("2.5.29.33"===this.certs[e].extensions[t].extnID){if(d)return{result:!1,resultCode:98,resultMessage:"Policy mapping prohibited"};N[e]=this.certs[e].extensions[t].parsedValue}"2.5.29.36"===this.certs[e].extensions[t].extnID&&!1===f&&(0===this.certs[e].extensions[t].parsedValue.requireExplicitPolicy?(f=!0,E=e):!1===p[0]?(p[0]=!0,y=this.certs[e].extensions[t].parsedValue.requireExplicitPolicy):y=y>this.certs[e].extensions[t].parsedValue.requireExplicitPolicy?this.certs[e].extensions[t].parsedValue.requireExplicitPolicy:y,0===this.certs[e].extensions[t].parsedValue.inhibitPolicyMapping?d=!0:!1===p[1]?(p[1]=!0,v=this.certs[e].extensions[t].parsedValue.inhibitPolicyMapping+1):v=v>this.certs[e].extensions[t].parsedValue.inhibitPolicyMapping+1?this.certs[e].extensions[t].parsedValue.inhibitPolicyMapping+1:v),"2.5.29.54"===this.certs[e].extensions[t].extnID&&!1===g&&(0===this.certs[e].extensions[t].parsedValue.valueBlock.valueDec?g=!0:!1===p[2]?(p[2]=!0,w=this.certs[e].extensions[t].parsedValue.valueBlock.valueDec):w=w>this.certs[e].extensions[t].parsedValue.valueBlock.valueDec?this.certs[e].extensions[t].parsedValue.valueBlock.valueDec:w)}if(!0===g){let t=-1;for(let e=0;e<C.length;e++)if("2.5.29.32.0"===C[e]){t=e;break}-1!==t&&delete I[0][e]}!1===f&&!0===p[0]&&0===--y&&(f=!0,E=e,p[0]=!1),!1===d&&!0===p[1]&&0===--v&&(d=!0,p[1]=!1),!1===g&&!0===p[2]&&0===--w&&(g=!0,p[2]=!1)}for(let e=0;e<this.certs.length-1;e++)if(e<this.certs.length-2&&void 0!==N[e+1])for(let t=0;t<N[e+1].mappings.length;t++){if("2.5.29.32.0"===N[e+1].mappings[t].issuerDomainPolicy||"2.5.29.32.0"===N[e+1].mappings[t].subjectDomainPolicy)return{result:!1,resultCode:99,resultMessage:'The "anyPolicy" should not be a part of policy mapping scheme'};let r=-1,s=-1;for(let a=0;a<C.length;a++)C[a]===N[e+1].mappings[t].issuerDomainPolicy&&(r=a),C[a]===N[e+1].mappings[t].subjectDomainPolicy&&(s=a);void 0!==I[r][e]&&delete I[r][e];for(let a=0;a<P[e].certificatePolicies.length;a++)if(N[e+1].mappings[t].subjectDomainPolicy===P[e].certificatePolicies[a].policyIdentifier&&-1!==r&&-1!==s)for(let t=0;t<=e;t++)void 0!==I[s][t]&&(I[r][t]=!0,delete I[s][t])}for(let e=0;e<C.length;e++)if("2.5.29.32.0"===C[e])for(let t=0;t<E;t++)delete I[e][t];const x=[];for(let e=0;e<I.length;e++){let t=!0;for(let r=0;r<this.certs.length-1;r++){let s=!1;if(r<E&&"2.5.29.32.0"===C[e]&&C.length>1){t=!1;break}if(void 0===I[e][r]){if(r>=E)for(let e=0;e<C.length;e++)if("2.5.29.32.0"===C[e]){!0===I[e][r]&&(s=!0);break}if(!s){t=!1;break}}}!0===t&&x.push(C[e])}let V=[];if(1===i.length&&"2.5.29.32.0"===i[0]&&!1===f)V=i;else if(1===x.length&&"2.5.29.32.0"===x[0])V=i;else for(let e=0;e<x.length;e++)for(let t=0;t<i.length;t++)if(i[t]===x[e]||"2.5.29.32.0"===i[t]){V.push(x[e]);break}const D={result:V.length>0,resultCode:0,resultMessage:V.length>0?"":'Zero "userConstrPolicies" array, no intersections with "authConstrPolicies"',authConstrPolicies:x,userConstrPolicies:V,explicitPolicyIndicator:f,policyMappings:N,certificatePath:this.certs};if(0===V.length)return D;function t(e,t){const r=Ze(e),s=Ze(t),a=r.split("."),n=s.split("."),i=a.length,o=n.length;if(0===i||0===o||i<o)return!1;for(let e=0;e<i;e++)if(0===a[e].length)return!1;for(let e=0;e<o;e++)if(0===n[e].length){if(0===e){if(1===o)return!1;continue}return!1}for(let e=0;e<o;e++)if(0!==n[o-1-e].length&&0!==a[i-1-e].localeCompare(n[o-1-e]))return!1;return!0}function r(e,r){const s=Ze(e),a=Ze(r),n=s.split("@"),i=a.split("@");if(0===n.length||0===i.length||n.length<i.length)return!1;if(1===i.length){if(t(n[1],i[0])){const e=n[1].split("."),t=i[0].split(".");return 0===t[0].length||e.length===t.length}return!1}return 0===s.localeCompare(a)}function s(e,r){let s=Ze(e);const a=Ze(r),n=s.split("/");if(a.split("/").length>1)return!1;if(n.length>1)for(let e=0;e<n.length;e++)if(n[e].length>0&&":"!==n[e].charAt(n[e].length-1)){s=n[e].split(":")[0];break}if(t(s,a)){const e=s.split("."),t=a.split(".");return 0===t[0].length||e.length===t.length}return!1}function a(e,t){const r=new Uint8Array(e.valueBlock.valueHex),s=new Uint8Array(t.valueBlock.valueHex);if(4===r.length&&8===s.length){for(let e=0;e<4;e++)if((r[e]^s[e])&s[e+4])return!1;return!0}if(16===r.length&&32===s.length){for(let e=0;e<16;e++)if((r[e]^s[e])&s[e+16])return!1;return!0}return!1}function n(e,t){if(0===e.typesAndValues.length||0===t.typesAndValues.length)return!0;if(e.typesAndValues.length<t.typesAndValues.length)return!1;let r=!0,s=0;for(let a=0;a<t.typesAndValues.length;a++){let n=!1;for(let i=s;i<e.typesAndValues.length;i++)if(n=e.typesAndValues[i].isEqual(t.typesAndValues[a]),e.typesAndValues[i].type===t.typesAndValues[a].type&&(r=r&&n),!0===n){if(0===s||s===i){s=i+1;break}return!1}if(!1===n)return!1}return 0!==s&&r}if(!1===D.result)return D;S=1;for(let e=this.certs.length-2;e>=0;e--,S++){let i=[],o=[],l=[];if("extensions"in this.certs[e])for(let t=0;t<this.certs[e].extensions.length;t++)"2.5.29.30"===this.certs[e].extensions[t].extnID&&("permittedSubtrees"in this.certs[e].extensions[t].parsedValue&&(o=o.concat(this.certs[e].extensions[t].parsedValue.permittedSubtrees)),"excludedSubtrees"in this.certs[e].extensions[t].parsedValue&&(l=l.concat(this.certs[e].extensions[t].parsedValue.excludedSubtrees))),"2.5.29.17"===this.certs[e].extensions[t].extnID&&(i=i.concat(this.certs[e].extensions[t].parsedValue.altNames));let c=A.length<=0;for(let t=0;t<A.length;t++)switch(A[t].base.type){case 4:if(A[t].base.value.typesAndValues.length!==this.certs[e].subject.typesAndValues.length)continue;c=!0;for(let r=0;r<this.certs[e].subject.typesAndValues.length;r++)if(this.certs[e].subject.typesAndValues[r].type!==A[t].base.value.typesAndValues[r].type){c=!1;break}if(!0===c)break}if(!1===c)throw D.result=!1,D.resultCode=21,D.resultMessage="No neccessary name form found",D;const u=[];u[0]=[],u[1]=[],u[2]=[],u[3]=[],u[4]=[];for(let e=0;e<b.length;e++)switch(b[e].base.type){case 1:u[0].push(b[e]);break;case 2:u[1].push(b[e]);break;case 4:u[2].push(b[e]);break;case 6:u[3].push(b[e]);break;case 7:u[4].push(b[e])}for(let o=0;o<5;o++){let l=!1,c=!1;const h=u[o];for(let u=0;u<h.length;u++){switch(o){case 0:if(i.length>0)for(let e=0;e<i.length;e++)1===i[e].type&&(c=!0,l=l||r(i[e].value,h[u].base.value));else for(let t=0;t<this.certs[e].subject.typesAndValues.length;t++)"1.2.840.113549.1.9.1"!==this.certs[e].subject.typesAndValues[t].type&&"0.9.2342.19200300.100.1.3"!==this.certs[e].subject.typesAndValues[t].type||(c=!0,l=l||r(this.certs[e].subject.typesAndValues[t].value.valueBlock.value,h[u].base.value));break;case 1:if(i.length>0)for(let e=0;e<i.length;e++)2===i[e].type&&(c=!0,l=l||t(i[e].value,h[u].base.value));break;case 2:c=!0,l=n(this.certs[e].subject,h[u].base.value);break;case 3:if(i.length>0)for(let e=0;e<i.length;e++)6===i[e].type&&(c=!0,l=l||s(i[e].value,h[u].base.value));break;case 4:if(i.length>0)for(let e=0;e<i.length;e++)7===i[e].type&&(c=!0,l=l||a(i[e].value,h[u].base.value))}if(l)break}if(!1===l&&h.length>0&&c)throw D.result=!1,D.resultCode=41,D.resultMessage='Failed to meet "permitted sub-trees" name constraint',D}let h=!1;for(let o=0;o<k.length;o++){switch(k[o].base.type){case 1:if(i.length>=0)for(let e=0;e<i.length;e++)1===i[e].type&&(h=h||r(i[e].value,k[o].base.value));else for(let e=0;e<this.subject.typesAndValues.length;e++)"1.2.840.113549.1.9.1"!==this.subject.typesAndValues[e].type&&"0.9.2342.19200300.100.1.3"!==this.subject.typesAndValues[e].type||(h=h||r(this.subject.typesAndValues[e].value.valueBlock.value,k[o].base.value));break;case 2:if(i.length>0)for(let e=0;e<i.length;e++)2===i[e].type&&(h=h||t(i[e].value,k[o].base.value));break;case 4:h=h||n(this.certs[e].subject,k[o].base.value);break;case 6:if(i.length>0)for(let e=0;e<i.length;e++)6===i[e].type&&(h=h||s(i[e].value,k[o].base.value));break;case 7:if(i.length>0)for(let e=0;e<i.length;e++)7===i[e].type&&(h=h||a(i[e].value,k[o].base.value))}if(h)break}if(!0===h)throw D.result=!1,D.resultCode=42,D.resultMessage='Failed to meet "excluded sub-trees" name constraint',D;b=b.concat(o),k=k.concat(l)}return D}catch(e){if(e instanceof Object){if("resultMessage"in e)return e;if("message"in e)return{result:!1,resultCode:-1,resultMessage:e.message}}return{result:!1,resultCode:-1,resultMessage:e}}}}class Ar{constructor(e={}){this.tbsResponseData=be(e,"tbsResponseData",Ar.defaultValues("tbsResponseData")),this.signatureAlgorithm=be(e,"signatureAlgorithm",Ar.defaultValues("signatureAlgorithm")),this.signature=be(e,"signature",Ar.defaultValues("signature")),"certs"in e&&(this.certs=be(e,"certs",Ar.defaultValues("certs"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"tbsResponseData":return new br;case"signatureAlgorithm":return new Ve;case"signature":return new K;case"certs":return[];default:throw new Error(`Invalid member name for BasicOCSPResponse class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"type":{let e=br.compareWithDefault("tbs",t.tbs)&&br.compareWithDefault("responderID",t.responderID)&&br.compareWithDefault("producedAt",t.producedAt)&&br.compareWithDefault("responses",t.responses);return"responseExtensions"in t&&(e=e&&br.compareWithDefault("responseExtensions",t.responseExtensions)),e}case"signatureAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"signature":return t.isEqual(Ar.defaultValues(e));case"certs":return 0===t.length;default:throw new Error(`Invalid member name for BasicOCSPResponse class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"BasicOCSPResponse",value:[br.schema(t.tbsResponseData||{names:{blockName:"BasicOCSPResponse.tbsResponseData"}}),Ve.schema(t.signatureAlgorithm||{names:{blockName:"BasicOCSPResponse.signatureAlgorithm"}}),new K({name:t.signature||"BasicOCSPResponse.signature"}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new x({value:[new ge({name:"BasicOCSPResponse.certs",value:Ot.schema(t.certs||{})})]})]})]})}fromSchema(e){const t=we(e,e,Ar.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OCSP_BASIC_RESPONSE");this.tbsResponseData=new br({schema:t.result["BasicOCSPResponse.tbsResponseData"]}),this.signatureAlgorithm=new Ve({schema:t.result["BasicOCSPResponse.signatureAlgorithm"]}),this.signature=t.result["BasicOCSPResponse.signature"],"BasicOCSPResponse.certs"in t.result&&(this.certs=Array.from(t.result["BasicOCSPResponse.certs"],e=>new Ot({schema:e})))}toSchema(){const e=[];return e.push(this.tbsResponseData.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),"certs"in this&&e.push(new I({idBlock:{tagClass:3,tagNumber:0},value:[new x({value:Array.from(this.certs,e=>e.toSchema())})]})),new x({value:e})}toJSON(){const e={tbsResponseData:this.tbsResponseData.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signature:this.signature.toJSON()};return"certs"in this&&(e.certs=Array.from(this.certs,e=>e.toJSON())),e}getCertificateStatus(e,t){let r=Promise.resolve();const s={isForCertificate:!1,status:2},a={},n=[],i=[];for(const r of this.tbsResponseData.responses){const s=Xe(r.certID.hashAlgorithm.algorithmId);if("name"in s==!1)return Promise.reject(`Wrong CertID hashing algorithm: ${r.certID.hashAlgorithm.algorithmId}`);if(s.name in a==!1){a[s.name]=1;const r=new vr;n.push(r),i.push(r.createForCertificate(e,{hashAlgorithm:s.name,issuerCertificate:t}))}}return r=(r=r.then(()=>Promise.all(i))).then(()=>{for(const e of this.tbsResponseData.responses)for(const t of n)if(e.certID.isEqual(t)){s.isForCertificate=!0;try{switch(e.certStatus.idBlock.isConstructed){case!0:1===e.certStatus.idBlock.tagNumber&&(s.status=1);break;case!1:switch(e.certStatus.idBlock.tagNumber){case 0:s.status=0;break;case 2:s.status=2}}}catch(e){}return s}return s})}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let r,s=Promise.resolve();const a=qe();return s=(s=(s=(s=(s=s.then(()=>a.subtle.getSignatureParameters(e,t))).then(e=>{r=e.parameters,this.signatureAlgorithm=e.signatureAlgorithm})).then(()=>{this.tbsResponseData.tbs=this.tbsResponseData.toSchema(!0).toBER(!1)})).then(()=>a.subtle.signWithPrivateKey(this.tbsResponseData.tbs,e,r))).then(e=>{this.signature=new K({valueHex:e})})}verify(e={}){if("certs"in this==!1)return Promise.reject("No certificates attached to the BasicOCSPResponce");let t=null;const r=new Uint8Array(this.tbsResponseData.tbs);let s=-1,a=Promise.resolve(),n="",i=[];"trustedCerts"in e&&(i=e.trustedCerts);const o=_e();if(void 0===o)return Promise.reject("Unable to create WebCrypto object");if(""===(n=et(this.signatureAlgorithm)))return Promise.reject(`Unsupported signature algorithm: ${this.signatureAlgorithm.algorithmId}`);let l=0,c={};if(this.tbsResponseData.responderID instanceof at)l=0,c=this.tbsResponseData.responderID;else{if(!(this.tbsResponseData.responderID instanceof j))return Promise.reject("Wrong value for responderID");l=1,c=this.tbsResponseData.responderID}function u(e){if(!0===e.issuer.isEqual(t.issuer)&&!0===e.serialNumber.isEqual(t.serialNumber))return null;let r=!1;for(const t of e.extensions)"2.5.29.19"===t.extnID&&"cA"in t.parsedValue&&!0===t.parsedValue.cA&&(r=!0);return r?e:null}return a=(a=(a=(a=0===l?a.then(()=>{for(const[e,t]of this.certs.entries())if(t.subject.isEqual(c)){s=e;break}}):a.then(()=>Promise.all(Array.from(this.certs,e=>o.digest({name:"sha-1"},new Uint8Array(e.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))).then(e=>{for(const[t,r]of this.certs.entries())if(Se(e[t],c.valueBlock.valueHex)){s=t;break}}))).then(()=>-1===s?Promise.reject("Correct certificate was not found in OCSP response"):(t=this.certs[s],Promise.all(Array.from(this.certs,e=>u(e))).then(e=>{const r=[];r.push(t);for(const t of e)null!==t&&r.push(t);return new kr({certs:r,trustedCerts:i}).verify().then(e=>!0===e.result?Promise.resolve():Promise.reject("Validation of signer's certificate failed"),e=>Promise.reject(`Validation of signer's certificate failed with error: ${e instanceof Object?e.resultMessage:e}`))},e=>Promise.reject(`Error during checking certificates for CA flag: ${e}`))))).then(()=>{let e;const t=Xe(e="1.2.840.113549.1.1.10"===this.certs[s].signatureAlgorithm.algorithmId?this.certs[s].signatureAlgorithm.algorithmId:this.certs[s].subjectPublicKeyInfo.algorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Unsupported public key algorithm: ${e}`);const r=t.name,a=ze(r,"importkey");if("hash"in a.algorithm&&(a.algorithm.hash.name=n),"ECDSA"===r){if(this.certs[s].subjectPublicKeyInfo.algorithm.algorithmParams instanceof $==!1)return Promise.reject("Incorrect type for ECDSA public key parameters");const e=Xe(this.certs[s].subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString());if("name"in e==!1)return Promise.reject(`Unsupported named curve algorithm: ${this.certs[s].subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);a.algorithm.namedCurve=e.name}const i=this.certs[s].subjectPublicKeyInfo.toSchema().toBER(!1),l=new Uint8Array(i);return o.importKey("spki",l,a.algorithm,!0,a.usages)})).then(e=>{const t=ze(e.algorithm.name,"verify");"hash"in t.algorithm&&(t.algorithm.hash.name=n);let s=this.signature.valueBlock.valueHex;if("ECDSA"===e.algorithm.name){s=Ye(ve(s).result)}if("RSA-PSS"===e.algorithm.name){let e;try{e=new Je({schema:this.signatureAlgorithm.algorithmParams})}catch(e){return Promise.reject(e)}t.algorithm.saltLength="saltLength"in e?e.saltLength:20;let r="SHA-1";if("hashAlgorithm"in e){const t=Xe(e.hashAlgorithm.algorithmId);if("name"in t==!1)return Promise.reject(`Unrecognized hash algorithm: ${e.hashAlgorithm.algorithmId}`);r=t.name}t.algorithm.hash.name=r}return o.verify(t.algorithm,e,new Uint8Array(s),r)})}}class Sr{constructor(e={}){this.digestAlgorithm=be(e,"digestAlgorithm",Sr.defaultValues("digestAlgorithm")),this.digest=be(e,"digest",Sr.defaultValues("digest")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"digestAlgorithm":return new Ve;case"digest":return new j;default:throw new Error(`Invalid member name for DigestInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"digestAlgorithm":return Ve.compareWithDefault("algorithmId",t.algorithmId)&&"algorithmParams"in t==!1;case"digest":return t.isEqual(this.constructor.defaultValues(e));default:throw new Error(`Invalid member name for DigestInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[Ve.schema(t.digestAlgorithm||{names:{blockName:"digestAlgorithm"}}),new j({name:t.digest||"digest"})]})}fromSchema(e){const t=we(e,e,Sr.schema({names:{digestAlgorithm:{names:{blockName:"digestAlgorithm"}},digest:"digest"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for DigestInfo");this.digestAlgorithm=new Ve({schema:t.result.digestAlgorithm}),this.digest=t.result.digest}toSchema(){return new x({value:[this.digestAlgorithm.toSchema(),this.digest]})}toJSON(){return{digestAlgorithm:this.digestAlgorithm.toJSON(),digest:this.digest.toJSON()}}}class Cr{constructor(e={}){if(this.eContentType=be(e,"eContentType",Cr.defaultValues("eContentType")),"eContent"in e&&(this.eContent=be(e,"eContent",Cr.defaultValues("eContent")),1===this.eContent.idBlock.tagClass&&4===this.eContent.idBlock.tagNumber&&!1===this.eContent.idBlock.isConstructed)){const e=new j({idBlock:{isConstructed:!0},isConstructed:!0});let t=0,r=this.eContent.valueBlock.valueHex.byteLength;for(;r>0;){const s=new Uint8Array(this.eContent.valueBlock.valueHex,t,t+65536>this.eContent.valueBlock.valueHex.byteLength?this.eContent.valueBlock.valueHex.byteLength-t:65536),a=new ArrayBuffer(s.length),n=new Uint8Array(a);for(let e=0;e<n.length;e++)n[e]=s[e];e.valueBlock.value.push(new j({valueHex:a})),r-=s.length,t+=s.length}this.eContent=e}"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"eContentType":return"";case"eContent":return new j;default:throw new Error(`Invalid member name for EncapsulatedContentInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"eContentType":return""===t;case"eContent":return 1===t.idBlock.tagClass&&4===t.idBlock.tagNumber&&t.isEqual(Cr.defaultValues("eContent"));default:throw new Error(`Invalid member name for EncapsulatedContentInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.eContentType||""}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new de({name:t.eContent||""})]})]})}fromSchema(e){const t=we(e,e,Cr.schema({names:{eContentType:"eContentType",eContent:"eContent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EncapsulatedContentInfo");this.eContentType=t.result.eContentType.valueBlock.toString(),"eContent"in t.result&&(this.eContent=t.result.eContent)}toSchema(){const e=[];return e.push(new $({value:this.eContentType})),"eContent"in this&&!1===Cr.compareWithDefault("eContent",this.eContent)&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.eContent]})),new x({value:e})}toJSON(){const e={eContentType:this.eContentType};return"eContent"in this&&!1===Cr.compareWithDefault("eContent",this.eContent)&&(e.eContent=this.eContent.toJSON()),e}}class Ir{constructor(e={}){this.mac=be(e,"mac",Ir.defaultValues("mac")),this.macSalt=be(e,"macSalt",Ir.defaultValues("macSalt")),"iterations"in e&&(this.iterations=be(e,"iterations",Ir.defaultValues("iterations"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"mac":return new Sr;case"macSalt":return new j;case"iterations":return 1;default:throw new Error(`Invalid member name for MacData class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"mac":return Sr.compareWithDefault("digestAlgorithm",t.digestAlgorithm)&&Sr.compareWithDefault("digest",t.digest);case"macSalt":return t.isEqual(Ir.defaultValues(e));case"iterations":return t===Ir.defaultValues(e);default:throw new Error(`Invalid member name for MacData class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",optional:t.optional||!0,value:[Sr.schema(t.mac||{names:{blockName:"mac"}}),new j({name:t.macSalt||"macSalt"}),new R({optional:!0,name:t.iterations||"iterations"})]})}fromSchema(e){const t=we(e,e,Ir.schema({names:{mac:{names:{blockName:"mac"}},macSalt:"macSalt",iterations:"iterations"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for MacData");this.mac=new Sr({schema:t.result.mac}),this.macSalt=t.result.macSalt,"iterations"in t.result&&(this.iterations=t.result.iterations.valueBlock.valueDec)}toSchema(){const e=[this.mac.toSchema(),this.macSalt];return"iterations"in this&&e.push(new R({value:this.iterations})),new x({value:e})}toJSON(){const e={mac:this.mac.toJSON(),macSalt:this.macSalt.toJSON()};return"iterations"in this&&(e.iterations=this.iterations.toJSON()),e}}class Br{constructor(e={}){this.hashAlgorithm=be(e,"hashAlgorithm",Br.defaultValues("hashAlgorithm")),this.hashedMessage=be(e,"hashedMessage",Br.defaultValues("hashedMessage")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new Ve;case"hashedMessage":return new j;default:throw new Error(`Invalid member name for MessageImprint class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"hashAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==!1;case"hashedMessage":return 0===t.isEqual(Br.defaultValues(e));default:throw new Error(`Invalid member name for MessageImprint class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[Ve.schema(t.hashAlgorithm||{}),new j({name:t.hashedMessage||""})]})}fromSchema(e){const t=we(e,e,Br.schema({names:{hashAlgorithm:{names:{blockName:"hashAlgorithm"}},hashedMessage:"hashedMessage"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for MessageImprint");this.hashAlgorithm=new Ve({schema:t.result.hashAlgorithm}),this.hashedMessage=t.result.hashedMessage}toSchema(){return new x({value:[this.hashAlgorithm.toSchema(),this.hashedMessage]})}toJSON(){return{hashAlgorithm:this.hashAlgorithm.toJSON(),hashedMessage:this.hashedMessage.toJSON()}}}class Nr{constructor(e={}){this.otherCertFormat=be(e,"otherCertFormat",Nr.defaultValues("otherCertFormat")),this.otherCert=be(e,"otherCert",Nr.defaultValues("otherCert")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"otherCertFormat":return"";case"otherCert":return new de;default:throw new Error(`Invalid member name for OtherCertificateFormat class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new $({name:t.otherCertFormat||"otherCertFormat"}),new de({name:t.otherCert||"otherCert"})]})}fromSchema(e){const t=we(e,e,Nr.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherCertificateFormat");this.otherCertFormat=t.result.otherCertFormat.valueBlock.toString(),this.otherCert=t.result.otherCert}toSchema(){return new x({value:[new $({value:this.otherCertFormat}),this.otherCert]})}toJSON(){const e={otherCertFormat:this.otherCertFormat};return this.otherCert instanceof de||(e.otherCert=this.otherCert.toJSON()),e}}class Pr{constructor(e={}){this.type=be(e,"type",Pr.defaultValues("type")),this.attributes=be(e,"attributes",Pr.defaultValues("attributes")),this.encodedValue=be(e,"encodedValue",Pr.defaultValues("encodedValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return-1;case"attributes":return[];case"encodedValue":return new ArrayBuffer(0);default:throw new Error(`Invalid member name for SignedAndUnsignedAttributes class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"type":return t===Pr.defaultValues("type");case"attributes":return 0===t.length;case"encodedValue":return 0===t.byteLength;default:throw new Error(`Invalid member name for SignedAndUnsignedAttributes class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new I({name:t.blockName||"",optional:!0,idBlock:{tagClass:3,tagNumber:t.tagNumber},value:[new ge({name:t.attributes||"",value:He.schema()})]})}fromSchema(e){const t=we(e,e,Pr.schema({names:{tagNumber:this.type,attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SignedUnsignedAttributes");this.type=t.result.idBlock.tagNumber,this.encodedValue=t.result.valueBeforeDecode;const r=new Uint8Array(this.encodedValue);if(r[0]=49,"attributes"in t.result!=!1)this.attributes=Array.from(t.result.attributes,e=>new He({schema:e}));else if(0===this.type)throw new Error("Wrong structure of SignedUnsignedAttributes")}toSchema(){if(Pr.compareWithDefault("type",this.type)||Pr.compareWithDefault("attributes",this.attributes))throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return new I({optional:!0,idBlock:{tagClass:3,tagNumber:this.type},value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){if(Pr.compareWithDefault("type",this.type)||Pr.compareWithDefault("attributes",this.attributes))throw new Error('Incorrectly initialized "SignedAndUnsignedAttributes" class');return{type:this.type,attributes:Array.from(this.attributes,e=>e.toJSON())}}}class Er{constructor(e={}){this.version=be(e,"version",Er.defaultValues("version")),this.sid=be(e,"sid",Er.defaultValues("sid")),this.digestAlgorithm=be(e,"digestAlgorithm",Er.defaultValues("digestAlgorithm")),"signedAttrs"in e&&(this.signedAttrs=be(e,"signedAttrs",Er.defaultValues("signedAttrs"))),this.signatureAlgorithm=be(e,"signatureAlgorithm",Er.defaultValues("signatureAlgorithm")),this.signature=be(e,"signature",Er.defaultValues("signature")),"unsignedAttrs"in e&&(this.unsignedAttrs=be(e,"unsignedAttrs",Er.defaultValues("unsignedAttrs"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"sid":return new de;case"digestAlgorithm":return new Ve;case"signedAttrs":return new Pr({type:0});case"signatureAlgorithm":return new Ve;case"signature":return new j;case"unsignedAttrs":return new Pr({type:1});default:throw new Error(`Invalid member name for SignerInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return Er.defaultValues("version")===t;case"sid":return t instanceof de;case"digestAlgorithm":return t instanceof Ve!=!1&&t.isEqual(Er.defaultValues("digestAlgorithm"));case"signedAttrs":return Pr.compareWithDefault("type",t.type)&&Pr.compareWithDefault("attributes",t.attributes)&&Pr.compareWithDefault("encodedValue",t.encodedValue);case"signatureAlgorithm":return t instanceof Ve!=!1&&t.isEqual(Er.defaultValues("signatureAlgorithm"));case"signature":case"unsignedAttrs":return Pr.compareWithDefault("type",t.type)&&Pr.compareWithDefault("attributes",t.attributes)&&Pr.compareWithDefault("encodedValue",t.encodedValue);default:throw new Error(`Invalid member name for SignerInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:"SignerInfo",value:[new R({name:t.version||"SignerInfo.version"}),new fe({value:[Yt.schema(t.sid||{names:{blockName:"SignerInfo.sid"}}),new I({optional:!0,name:t.sid||"SignerInfo.sid",idBlock:{tagClass:3,tagNumber:0},value:[new j]})]}),Ve.schema(t.digestAlgorithm||{names:{blockName:"SignerInfo.digestAlgorithm"}}),Pr.schema(t.signedAttrs||{names:{blockName:"SignerInfo.signedAttrs",tagNumber:0}}),Ve.schema(t.signatureAlgorithm||{names:{blockName:"SignerInfo.signatureAlgorithm"}}),new j({name:t.signature||"SignerInfo.signature"}),Pr.schema(t.unsignedAttrs||{names:{blockName:"SignerInfo.unsignedAttrs",tagNumber:1}})]})}fromSchema(e){const t=we(e,e,Er.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CMS_SIGNER_INFO");this.version=t.result["SignerInfo.version"].valueBlock.valueDec;const r=t.result["SignerInfo.sid"];1===r.idBlock.tagClass?this.sid=new Yt({schema:r}):this.sid=r,this.digestAlgorithm=new Ve({schema:t.result["SignerInfo.digestAlgorithm"]}),"SignerInfo.signedAttrs"in t.result&&(this.signedAttrs=new Pr({type:0,schema:t.result["SignerInfo.signedAttrs"]})),this.signatureAlgorithm=new Ve({schema:t.result["SignerInfo.signatureAlgorithm"]}),this.signature=t.result["SignerInfo.signature"],"SignerInfo.unsignedAttrs"in t.result&&(this.unsignedAttrs=new Pr({type:1,schema:t.result["SignerInfo.unsignedAttrs"]}))}toSchema(){if(Er.compareWithDefault("sid",this.sid))throw new Error('Incorrectly initialized "SignerInfo" class');const e=[];return e.push(new R({value:this.version})),this.sid instanceof Yt?e.push(this.sid.toSchema()):e.push(this.sid),e.push(this.digestAlgorithm.toSchema()),"signedAttrs"in this&&!1===Er.compareWithDefault("signedAttrs",this.signedAttrs)&&e.push(this.signedAttrs.toSchema()),e.push(this.signatureAlgorithm.toSchema()),e.push(this.signature),"unsignedAttrs"in this&&!1===Er.compareWithDefault("unsignedAttrs",this.unsignedAttrs)&&e.push(this.unsignedAttrs.toSchema()),new x({value:e})}toJSON(){if(Er.compareWithDefault("sid",this.sid))throw new Error('Incorrectly initialized "SignerInfo" class');const e={version:this.version};return this.sid instanceof de||(e.sid=this.sid.toJSON()),e.digestAlgorithm=this.digestAlgorithm.toJSON(),!1===Er.compareWithDefault("signedAttrs",this.signedAttrs)&&(e.signedAttrs=this.signedAttrs.toJSON()),e.signatureAlgorithm=this.signatureAlgorithm.toJSON(),e.signature=this.signature.toJSON(),!1===Er.compareWithDefault("unsignedAttrs",this.unsignedAttrs)&&(e.unsignedAttrs=this.unsignedAttrs.toJSON()),e}}class xr{constructor(e={}){this.version=be(e,"version",xr.defaultValues("version")),this.policy=be(e,"policy",xr.defaultValues("policy")),this.messageImprint=be(e,"messageImprint",xr.defaultValues("messageImprint")),this.serialNumber=be(e,"serialNumber",xr.defaultValues("serialNumber")),this.genTime=be(e,"genTime",xr.defaultValues("genTime")),"accuracy"in e&&(this.accuracy=be(e,"accuracy",xr.defaultValues("accuracy"))),"ordering"in e&&(this.ordering=be(e,"ordering",xr.defaultValues("ordering"))),"nonce"in e&&(this.nonce=be(e,"nonce",xr.defaultValues("nonce"))),"tsa"in e&&(this.tsa=be(e,"tsa",xr.defaultValues("tsa"))),"extensions"in e&&(this.extensions=be(e,"extensions",xr.defaultValues("extensions"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"policy":return"";case"messageImprint":return new Br;case"serialNumber":return new R;case"genTime":return new Date(0,0,0);case"accuracy":return new ot;case"ordering":return!1;case"nonce":return new R;case"tsa":return new nt;case"extensions":return[];default:throw new Error(`Invalid member name for TSTInfo class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":case"policy":case"genTime":case"ordering":return t===xr.defaultValues(e);case"messageImprint":return Br.compareWithDefault("hashAlgorithm",t.hashAlgorithm)&&Br.compareWithDefault("hashedMessage",t.hashedMessage);case"serialNumber":case"nonce":return t.isEqual(xr.defaultValues(e));case"accuracy":return ot.compareWithDefault("seconds",t.seconds)&&ot.compareWithDefault("millis",t.millis)&&ot.compareWithDefault("micros",t.micros);case"tsa":return nt.compareWithDefault("type",t.type)&&nt.compareWithDefault("value",t.value);case"extensions":return 0===t.length;default:throw new Error(`Invalid member name for TSTInfo class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"TSTInfo",value:[new R({name:t.version||"TSTInfo.version"}),new $({name:t.policy||"TSTInfo.policy"}),Br.schema(t.messageImprint||{names:{blockName:"TSTInfo.messageImprint"}}),new R({name:t.serialNumber||"TSTInfo.serialNumber"}),new oe({name:t.genTime||"TSTInfo.genTime"}),ot.schema(t.accuracy||{names:{blockName:"TSTInfo.accuracy"}}),new E({name:t.ordering||"TSTInfo.ordering",optional:!0}),new R({name:t.nonce||"TSTInfo.nonce",optional:!0}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[nt.schema(t.tsa||{names:{blockName:"TSTInfo.tsa"}})]}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new ge({name:t.extensions||"TSTInfo.extensions",value:Vt.schema(t.extension||{})})]})]})}fromSchema(e){const t=we(e,e,xr.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for TST_INFO");this.version=t.result["TSTInfo.version"].valueBlock.valueDec,this.policy=t.result["TSTInfo.policy"].valueBlock.toString(),this.messageImprint=new Br({schema:t.result["TSTInfo.messageImprint"]}),this.serialNumber=t.result["TSTInfo.serialNumber"],this.genTime=t.result["TSTInfo.genTime"].toDate(),"TSTInfo.accuracy"in t.result&&(this.accuracy=new ot({schema:t.result["TSTInfo.accuracy"]})),"TSTInfo.ordering"in t.result&&(this.ordering=t.result["TSTInfo.ordering"].valueBlock.value),"TSTInfo.nonce"in t.result&&(this.nonce=t.result["TSTInfo.nonce"]),"TSTInfo.tsa"in t.result&&(this.tsa=new nt({schema:t.result["TSTInfo.tsa"]})),"TSTInfo.extensions"in t.result&&(this.extensions=Array.from(t.result["TSTInfo.extensions"],e=>new Vt({schema:e})))}toSchema(){const e=[];return e.push(new R({value:this.version})),e.push(new $({value:this.policy})),e.push(this.messageImprint.toSchema()),e.push(this.serialNumber),e.push(new oe({valueDate:this.genTime})),"accuracy"in this&&e.push(this.accuracy.toSchema()),"ordering"in this&&e.push(new E({value:this.ordering})),"nonce"in this&&e.push(this.nonce),"tsa"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[this.tsa.toSchema()]})),"extensions"in this&&e.push(new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.extensions,e=>e.toSchema())})),new x({value:e})}toJSON(){const e={version:this.version,policy:this.policy,messageImprint:this.messageImprint.toJSON(),serialNumber:this.serialNumber.toJSON(),genTime:this.genTime};return"accuracy"in this&&(e.accuracy=this.accuracy.toJSON()),"ordering"in this&&(e.ordering=this.ordering),"nonce"in this&&(e.nonce=this.nonce.toJSON()),"tsa"in this&&(e.tsa=this.tsa.toJSON()),"extensions"in this&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}verify(e={}){let t,r,s,a=Promise.resolve();const n=_e();if(void 0===n)return Promise.reject("Unable to create WebCrypto object");if(!("data"in e))return Promise.reject('"data" is a mandatory attribute for TST_INFO verification');t=e.data,"notBefore"in e&&(r=e.notBefore),"notAfter"in e&&(s=e.notAfter);const i=Xe(this.messageImprint.hashAlgorithm.algorithmId);return"name"in i==!1?Promise.reject(`Unsupported signature algorithm: ${this.messageImprint.hashAlgorithm.algorithmId}`):a=a.then(()=>n.digest(i.name,new Uint8Array(t))).then(e=>Se(e,this.messageImprint.hashedMessage.valueBlock.valueHex))}}class Vr{constructor(e={}){this.version={},this.holder={},this.issuer={},this.signature={},this.serialNumber={},this.attrCertValidityPeriod={},this.attributes={},this.issuerUniqueID={},this.extensions={}}fromSchema(e){}toSchema(){return new de}toJSON(){return{}}}class Dr{constructor(e={}){this.version=be(e,"version",Dr.defaultValues("version")),this.digestAlgorithms=be(e,"digestAlgorithms",Dr.defaultValues("digestAlgorithms")),this.encapContentInfo=be(e,"encapContentInfo",Dr.defaultValues("encapContentInfo")),"certificates"in e&&(this.certificates=be(e,"certificates",Dr.defaultValues("certificates"))),"crls"in e&&(this.crls=be(e,"crls",Dr.defaultValues("crls"))),this.signerInfos=be(e,"signerInfos",Dr.defaultValues("signerInfos")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 0;case"digestAlgorithms":return[];case"encapContentInfo":return new Cr;case"certificates":case"crls":case"signerInfos":return[];default:throw new Error(`Invalid member name for SignedData class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return t===Dr.defaultValues("version");case"encapContentInfo":return new Cr;case"digestAlgorithms":case"certificates":case"crls":case"signerInfos":return 0===t.length;default:throw new Error(`Invalid member name for SignedData class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return"optional"in t==!1&&(t.optional=!1),new x({name:t.blockName||"SignedData",optional:t.optional,value:[new R({name:t.version||"SignedData.version"}),new V({value:[new ge({name:t.digestAlgorithms||"SignedData.digestAlgorithms",value:Ve.schema()})]}),Cr.schema(t.encapContentInfo||{names:{blockName:"SignedData.encapContentInfo"}}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Gt.schema(t.certificates||{names:{certificates:"SignedData.certificates"}}).valueBlock.value}),new I({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:zt.schema(t.crls||{names:{crls:"SignedData.crls"}}).valueBlock.value}),new V({value:[new ge({name:t.signerInfos||"SignedData.signerInfos",value:Er.schema()})]})]})}fromSchema(e){const t=we(e,e,Dr.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SignedData");this.version=t.result["SignedData.version"].valueBlock.valueDec,"SignedData.digestAlgorithms"in t.result&&(this.digestAlgorithms=Array.from(t.result["SignedData.digestAlgorithms"],e=>new Ve({schema:e}))),this.encapContentInfo=new Cr({schema:t.result["SignedData.encapContentInfo"]}),"SignedData.certificates"in t.result&&(this.certificates=Array.from(t.result["SignedData.certificates"],e=>{switch(e.idBlock.tagClass){case 1:return new Ot({schema:e});case 3:{const t=e.idBlock.tagNumber;switch(e.idBlock.tagClass=1,e.idBlock.tagNumber=16,t){case 0:break;case 1:return new Tt({schema:e});case 2:return new Vr({schema:e});case 3:return new Nr({schema:e});default:throw new Error("Object's schema was not verified against input data for SignedData")}}break;default:throw new Error("Object's schema was not verified against input data for SignedData")}return new Ot})),"SignedData.crls"in t.result&&(this.crls=Array.from(t.result["SignedData.crls"],e=>1===e.idBlock.tagClass?new Ft({schema:e}):(e.idBlock.tagClass=1,e.idBlock.tagNumber=16,new Qt({schema:e})))),"SignedData.signerInfos"in t.result&&(this.signerInfos=Array.from(t.result["SignedData.signerInfos"],e=>new Er({schema:e})))}toSchema(e=!1){const t=[];return t.push(new R({value:this.version})),t.push(new V({value:Array.from(this.digestAlgorithms,t=>t.toSchema(e))})),t.push(this.encapContentInfo.toSchema()),"certificates"in this&&t.push(new I({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.certificates,t=>{if(t instanceof Nr){const r=t.toSchema(e);return r.idBlock.tagClass=3,r.idBlock.tagNumber=3,r}return t.toSchema(e)})})),"crls"in this&&t.push(new I({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.crls,t=>{if(t instanceof Qt){const r=t.toSchema(e);return r.idBlock.tagClass=3,r.idBlock.tagNumber=1,r}return t.toSchema(e)})})),t.push(new V({value:Array.from(this.signerInfos,t=>t.toSchema(e))})),new x({value:t})}toJSON(){const e={version:this.version,digestAlgorithms:Array.from(this.digestAlgorithms,e=>e.toJSON()),encapContentInfo:this.encapContentInfo.toJSON()};return"certificates"in this&&(e.certificates=Array.from(this.certificates,e=>e.toJSON())),"crls"in this&&(e.crls=Array.from(this.crls,e=>e.toJSON())),e.signerInfos=Array.from(this.signerInfos,e=>e.toJSON()),e}verify({signer:e=-1,data:t=new ArrayBuffer(0),trustedCerts:r=[],checkDate:s=new Date,checkChain:a=!1,includeSignerCertificate:n=!1,extendedMode:i=!1}={}){let o,l=Promise.resolve(),c=new ArrayBuffer(0),u="",h={},m=null,f=[];const d=_e();if(void 0===d)return Promise.reject("Unable to create WebCrypto object");if(-1===e)return i?Promise.reject({date:s,code:1,message:"Unable to get signer index from input parameters",signatureVerified:null,signerCertificate:null,signerCertificateVerified:null}):Promise.reject("Unable to get signer index from input parameters");if("certificates"in this==!1)return i?Promise.reject({date:s,code:2,message:"No certificates attached to this signed data",signatureVerified:null,signerCertificate:null,signerCertificateVerified:null}):Promise.reject("No certificates attached to this signed data");l=(l=this.signerInfos[e].sid instanceof Yt?l.then(()=>{for(const t of this.certificates)if(t instanceof Ot!=!1&&t.issuer.isEqual(this.signerInfos[e].sid.issuer)&&t.serialNumber.isEqual(this.signerInfos[e].sid.serialNumber))return h=t,Promise.resolve();return i?Promise.reject({date:s,code:3,message:"Unable to find signer certificate",signatureVerified:null,signerCertificate:null,signerCertificateVerified:null}):Promise.reject("Unable to find signer certificate")}):l.then(()=>Promise.all(Array.from(this.certificates.filter(e=>e instanceof Ot),e=>d.digest({name:"sha-1"},new Uint8Array(e.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex)))).then(t=>{for(const[r,s]of this.certificates.entries())if(s instanceof Ot!=!1&&Se(t[r],this.signerInfos[e].sid.valueBlock.valueHex))return h=s,Promise.resolve();return i?Promise.reject({date:s,code:3,message:"Unable to find signer certificate",signatureVerified:null,signerCertificate:null,signerCertificateVerified:null}):Promise.reject("Unable to find signer certificate")},()=>i?Promise.reject({date:s,code:3,message:"Unable to find signer certificate",signatureVerified:null,signerCertificate:null,signerCertificateVerified:null}):Promise.reject("Unable to find signer certificate")))).then(()=>{if("1.2.840.113549.1.9.16.1.4"===this.encapContentInfo.eContentType){if("eContent"in this.encapContentInfo==!1)return!1;const e=ve(this.encapContentInfo.eContent.valueBlock.valueHex);let r;try{r=new xr({schema:e.result})}catch(e){return!1}return s=r.genTime,m=r.serialNumber.valueBlock.valueHex,0===t.byteLength?i?Promise.reject({date:s,code:4,message:"Missed detached data input array",signatureVerified:null,signerCertificate:h,signerCertificateVerified:null}):Promise.reject("Missed detached data input array"):r.verify({data:t})}return!0});function g(e){if(!0===e.issuer.isEqual(h.issuer)&&!0===e.serialNumber.isEqual(h.serialNumber))return null;let t=!1;if("extensions"in e)for(const r of e.extensions)"2.5.29.19"===r.extnID&&"cA"in r.parsedValue&&!0===r.parsedValue.cA&&(t=!0);return t?e:null}return a&&(l=l.then(e=>{if(!1===e)return!1;const t=Array.from(this.certificates.filter(e=>e instanceof Ot),e=>g(e)),a=new kr({checkDate:s,certs:Array.from(t.filter(e=>null!==e)),trustedCerts:r});if(a.certs.push(h),"crls"in this)for(const e of this.crls)e instanceof Ft?a.crls.push(e):"1.3.6.1.5.5.7.48.1.1"===e.otherRevInfoFormat&&a.ocsps.push(new Ar({schema:e.otherRevInfo}));return"ocsps"in this&&a.ocsps.push(...this.ocsps),a.verify().then(e=>("certificatePath"in e&&(f=e.certificatePath),!0===e.result?Promise.resolve(!0):i?Promise.reject({date:s,code:5,message:`Validation of signer's certificate failed: ${e.resultMessage}`,signatureVerified:null,signerCertificate:h,signerCertificateVerified:!1}):Promise.reject("Validation of signer's certificate failed")),e=>i?Promise.reject({date:s,code:5,message:`Validation of signer's certificate failed with error: ${e instanceof Object?e.resultMessage:e}`,signatureVerified:null,signerCertificate:h,signerCertificateVerified:!1}):Promise.reject(`Validation of signer's certificate failed with error: ${e instanceof Object?e.resultMessage:e}`))})),l=(l=(l=(l=(l=l.then(t=>{if(!1===t)return!1;const r=Xe(this.signerInfos[e].digestAlgorithm.algorithmId);return"name"in r==!1?i?Promise.reject({date:s,code:7,message:`Unsupported signature algorithm: ${this.signerInfos[e].digestAlgorithm.algorithmId}`,signatureVerified:null,signerCertificate:h,signerCertificateVerified:!0}):Promise.reject(`Unsupported signature algorithm: ${this.signerInfos[e].digestAlgorithm.algorithmId}`):(u=r.name,!0)})).then(r=>{if(!1===r)return!1;if("eContent"in this.encapContentInfo)if(1===this.encapContentInfo.eContent.idBlock.tagClass&&4===this.encapContentInfo.eContent.idBlock.tagNumber)if(!1===this.encapContentInfo.eContent.idBlock.isConstructed)t=this.encapContentInfo.eContent.valueBlock.valueHex;else for(const e of this.encapContentInfo.eContent.valueBlock.value)t=Ae(t,e.valueBlock.valueHex);else t=this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;else if(0===t.byteLength)return i?Promise.reject({date:s,code:8,message:"Missed detached data input array",signatureVerified:null,signerCertificate:h,signerCertificateVerified:!0}):Promise.reject("Missed detached data input array");if("signedAttrs"in this.signerInfos[e]){let t=!1,r=!1;for(const s of this.signerInfos[e].signedAttrs.attributes)if("1.2.840.113549.1.9.3"===s.type&&(t=!0),"1.2.840.113549.1.9.4"===s.type&&(r=!0,c=s.values[0].valueBlock.valueHex),t&&r)break;if(!1===t)return i?Promise.reject({date:s,code:9,message:'Attribute "content-type" is a mandatory attribute for "signed attributes"',signatureVerified:null,signerCertificate:h,signerCertificateVerified:!0}):Promise.reject('Attribute "content-type" is a mandatory attribute for "signed attributes"');if(!1===r)return i?Promise.reject({date:s,code:10,message:'Attribute "message-digest" is a mandatory attribute for "signed attributes"',signatureVerified:null,signerCertificate:h,signerCertificateVerified:!0}):Promise.reject('Attribute "message-digest" is a mandatory attribute for "signed attributes"')}return!0})).then(e=>{if(!1===e)return!1;let t;const r=Xe(t="1.2.840.113549.1.1.10"===h.signatureAlgorithm.algorithmId?h.signatureAlgorithm.algorithmId:h.subjectPublicKeyInfo.algorithm.algorithmId);if("name"in r==!1)return i?Promise.reject({date:s,code:11,message:`Unsupported public key algorithm: ${t}`,signatureVerified:null,signerCertificate:h,signerCertificateVerified:!0}):Promise.reject(`Unsupported public key algorithm: ${t}`);const a=ze(r.name,"importkey");if("hash"in a.algorithm&&(a.algorithm.hash.name=u),"ECDSA"===r.name){let e=!1;if("algorithmParams"in h.subjectPublicKeyInfo.algorithm==!0&&"idBlock"in h.subjectPublicKeyInfo.algorithm.algorithmParams&&1===h.subjectPublicKeyInfo.algorithm.algorithmParams.idBlock.tagClass&&6===h.subjectPublicKeyInfo.algorithm.algorithmParams.idBlock.tagNumber&&(e=!0),!1===e)return Promise.reject("Incorrect type for ECDSA public key parameters");const t=Xe(h.subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString());if("name"in t==!1)return Promise.reject(`Unsupported named curve algorithm: ${h.subjectPublicKeyInfo.algorithm.algorithmParams.valueBlock.toString()}`);a.algorithm.namedCurve=t.name}const n=h.subjectPublicKeyInfo.toSchema().toBER(!1),o=new Uint8Array(n);return d.importKey("spki",o,a.algorithm,!0,a.usages)})).then(r=>"boolean"!=typeof r&&(o=r,!("signedAttrs"in this.signerInfos[e])||d.digest(u,new Uint8Array(t)))).then(r=>!1!==r&&(!("signedAttrs"in this.signerInfos[e])||!!Se(r,c)&&(t=this.signerInfos[e].signedAttrs.encodedValue,!0))).then(r=>{if(!1===r)return!1;const a=ze(o.algorithm.name,"verify");if("hash"in a.algorithm&&(a.algorithm.hash.name=u),"RSA-PSS"===o.algorithm.name){let t;try{t=new Je({schema:this.signerInfos[e].signatureAlgorithm.algorithmParams})}catch(e){return i?Promise.reject({date:s,code:12,message:e,signatureVerified:null,signerCertificate:h,signerCertificateVerified:!0}):Promise.reject(e)}a.algorithm.saltLength="saltLength"in t?t.saltLength:20;let r="SHA-1";if("hashAlgorithm"in t){const e=Xe(t.hashAlgorithm.algorithmId);if("name"in e==!1)return i?Promise.reject({date:s,code:13,message:`Unrecognized hash algorithm: ${t.hashAlgorithm.algorithmId}`,signatureVerified:null,signerCertificate:h,signerCertificateVerified:!0}):Promise.reject(`Unrecognized hash algorithm: ${t.hashAlgorithm.algorithmId}`);r=e.name}a.algorithm.hash.name=r}let n=this.signerInfos[e].signature.valueBlock.valueHex;if("ECDSA"===o.algorithm.name){n=Ye(ve(n).result)}return d.verify(a.algorithm,o,new Uint8Array(n),new Uint8Array(t))})).then(e=>i?{date:s,code:14,message:"",signatureVerified:e,signerCertificate:h,timestampSerial:m,signerCertificateVerified:!0,certificatePath:f}:e,e=>i?"code"in e?Promise.reject(e):Promise.reject({date:s,code:15,message:`Error during verification: ${e.message}`,signatureVerified:null,signerCertificate:h,timestampSerial:m,signerCertificateVerified:!0}):Promise.reject(e))}sign(e,t,r="SHA-1",s=new ArrayBuffer(0)){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let a,n=Promise.resolve();const i=qe(),o=Qe({name:r});return""===o?Promise.reject(`Unsupported hash algorithm: ${r}`):(0===this.digestAlgorithms.filter(e=>e.algorithmId===o).length&&this.digestAlgorithms.push(new Ve({algorithmId:o,algorithmParams:new D})),this.signerInfos[t].digestAlgorithm=new Ve({algorithmId:o,algorithmParams:new D}),n=(n=(n=(n=(n=n.then(()=>i.subtle.getSignatureParameters(e,r))).then(e=>{a=e.parameters,this.signerInfos[t].signatureAlgorithm=e.signatureAlgorithm})).then(()=>{if("signedAttrs"in this.signerInfos[t])if(0!==this.signerInfos[t].signedAttrs.encodedValue.byteLength)s=this.signerInfos[t].signedAttrs.encodedValue;else{s=this.signerInfos[t].signedAttrs.toSchema(!0).toBER(!1);new Uint8Array(s)[0]=49}else if("eContent"in this.encapContentInfo)if(1===this.encapContentInfo.eContent.idBlock.tagClass&&4===this.encapContentInfo.eContent.idBlock.tagNumber)if(!1===this.encapContentInfo.eContent.idBlock.isConstructed)s=this.encapContentInfo.eContent.valueBlock.valueHex;else for(const e of this.encapContentInfo.eContent.valueBlock.value)s=Ae(s,e.valueBlock.valueHex);else s=this.encapContentInfo.eContent.valueBlock.valueBeforeDecode;else if(0===s.byteLength)return Promise.reject("Missed detached data input array");return Promise.resolve()})).then(()=>i.subtle.signWithPrivateKey(s,e,a))).then(e=>(this.signerInfos[t].signature=new j({valueHex:e}),e)))}}class Or{constructor(e={}){this.version=be(e,"version",Or.defaultValues("version")),this.authSafe=be(e,"authSafe",Or.defaultValues("authSafe")),"macData"in e&&(this.macData=be(e,"macData",Or.defaultValues("macData"))),"parsedValue"in e&&(this.parsedValue=be(e,"parsedValue",Or.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"version":return 3;case"authSafe":return new ct;case"macData":return new Ir;case"parsedValue":return{};default:throw new Error(`Invalid member name for PFX class: ${e}`)}}static compareWithDefault(e,t){switch(e){case"version":return t===Or.defaultValues(e);case"authSafe":return ct.compareWithDefault("contentType",t.contentType)&&ct.compareWithDefault("content",t.content);case"macData":return Ir.compareWithDefault("mac",t.mac)&&Ir.compareWithDefault("macSalt",t.macSalt)&&Ir.compareWithDefault("iterations",t.iterations);case"parsedValue":return t instanceof Object&&0===Object.keys(t).length;default:throw new Error(`Invalid member name for PFX class: ${e}`)}}static schema(e={}){const t=be(e,"names",{});return new x({name:t.blockName||"",value:[new R({name:t.version||"version"}),ct.schema(t.authSafe||{names:{blockName:"authSafe"}}),Ir.schema(t.macData||{names:{blockName:"macData",optional:!0}})]})}fromSchema(e){const t=we(e,e,Or.schema({names:{version:"version",authSafe:{names:{blockName:"authSafe"}},macData:{names:{blockName:"macData"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PFX");this.version=t.result.version.valueBlock.valueDec,this.authSafe=new ct({schema:t.result.authSafe}),"macData"in t.result&&(this.macData=new Ir({schema:t.result.macData}))}toSchema(){const e=[new R({value:this.version}),this.authSafe.toSchema()];return"macData"in this&&e.push(this.macData.toSchema()),new x({value:e})}toJSON(){const e={version:this.version,authSafe:this.authSafe.toJSON()};return"macData"in this&&(e.macData=this.macData.toJSON()),e}makeInternalValues(e={}){if(e instanceof Object==!1)return Promise.reject('The "parameters" must has "Object" type');if("parsedValue"in this==!1)return Promise.reject('Please call "parseValues" function first in order to make "parsedValue" data');if("integrityMode"in this.parsedValue==!1)return Promise.reject('Absent mandatory parameter "integrityMode" inside "parsedValue"');let t=Promise.resolve();const r=_e();if(void 0===r)return Promise.reject("Unable to create WebCrypto object");if("authenticatedSafe"in this.parsedValue==!1)return Promise.reject('Absent mandatory parameter "authenticatedSafe" in "parsedValue"');switch(this.parsedValue.integrityMode){case 0:{if("iterations"in e==!1)return Promise.reject('Absent mandatory parameter "iterations"');if("pbkdf2HashAlgorithm"in e==!1)return Promise.reject('Absent mandatory parameter "pbkdf2HashAlgorithm"');if("hmacHashAlgorithm"in e==!1)return Promise.reject('Absent mandatory parameter "hmacHashAlgorithm"');if("password"in e==!1)return Promise.reject('Absent mandatory parameter "password"');const r=new ArrayBuffer(64);Ge(new Uint8Array(r));const s=this.parsedValue.authenticatedSafe.toSchema().toBER(!1);this.authSafe=new ct({contentType:"1.2.840.113549.1.7.1",content:new j({valueHex:s})});const a=qe();if("stampDataWithPassword"in a.subtle==!1)return Promise.reject(`No support for "stampDataWithPassword" in current engine "${a.name}"`);t=(t=t.then(()=>a.subtle.stampDataWithPassword({password:e.password,hashAlgorithm:e.hmacHashAlgorithm,salt:r,iterationCount:e.iterations,contentToStamp:s}))).then(t=>{this.macData=new Ir({mac:new Sr({digestAlgorithm:new Ve({algorithmId:Qe({name:e.hmacHashAlgorithm})}),digest:new j({valueHex:t})}),macSalt:new j({valueHex:r}),iterations:e.iterations})},e=>Promise.reject(e))}break;case 1:{if("signingCertificate"in e==!1)return Promise.reject('Absent mandatory parameter "signingCertificate"');if("privateKey"in e==!1)return Promise.reject('Absent mandatory parameter "privateKey"');if("hashAlgorithm"in e==!1)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');const s=this.parsedValue.authenticatedSafe.toSchema().toBER(!1),a=new Dr({version:1,encapContentInfo:new Cr({eContentType:"1.2.840.113549.1.7.1",eContent:new j({valueHex:s})}),certificates:[e.signingCertificate]});t=(t=(t=(t=t.then(()=>r.digest({name:e.hashAlgorithm},new Uint8Array(s)))).then(t=>{const r=[];r.push(new He({type:"1.2.840.113549.1.9.3",values:[new $({value:"1.2.840.113549.1.7.1"})]})),r.push(new He({type:"1.2.840.113549.1.9.5",values:[new ie({valueDate:new Date})]})),r.push(new He({type:"1.2.840.113549.1.9.4",values:[new j({valueHex:t})]})),a.signerInfos.push(new Er({version:1,sid:new Yt({issuer:e.signingCertificate.issuer,serialNumber:e.signingCertificate.serialNumber}),signedAttrs:new Pr({type:0,attributes:r})}))},e=>Promise.reject(`Error during making digest for message: ${e}`))).then(()=>a.sign(e.privateKey,0,e.hashAlgorithm))).then(()=>{this.authSafe=new ct({contentType:"1.2.840.113549.1.7.2",content:a.toSchema(!0)})},e=>Promise.reject(`Error during making signature: ${e}`))}break;default:return Promise.reject(`Parameter "integrityMode" has unknown value: ${e.integrityMode}`)}return t}parseInternalValues(e){if(e instanceof Object==!1)return Promise.reject('The "parameters" must has "Object" type');"checkIntegrity"in e==!1&&(e.checkIntegrity=!0);let t=Promise.resolve();const r=_e();if(void 0===r)return Promise.reject("Unable to create WebCrypto object");switch(this.parsedValue={},this.authSafe.contentType){case"1.2.840.113549.1.7.1":{if("password"in e==!1)return Promise.reject('Absent mandatory parameter "password"');if(this.parsedValue.integrityMode=0,this.authSafe.content instanceof j==!1)return Promise.reject('Wrong type of "this.authSafe.content"');let r=new ArrayBuffer(0);if(this.authSafe.content.valueBlock.isConstructed)for(const e of this.authSafe.content.valueBlock.value)r=Ae(r,e.valueBlock.valueHex);else r=this.authSafe.content.valueBlock.valueHex;const s=ve(r);if(-1===s.offset)return Promise.reject('Error during parsing of ASN.1 data inside "this.authSafe.content"');if(this.parsedValue.authenticatedSafe=new yr({schema:s.result}),e.checkIntegrity){if("macData"in this==!1)return Promise.reject('Absent "macData" value, can not check PKCS#12 data integrity');const s=Xe(this.macData.mac.digestAlgorithm.algorithmId);if("name"in s==!1)return Promise.reject(`Unsupported digest algorithm: ${this.macData.mac.digestAlgorithm.algorithmId}`);const a=qe();t=(t=t.then(()=>a.subtle.verifyDataStampedWithPassword({password:e.password,hashAlgorithm:s.name,salt:this.macData.macSalt.valueBlock.valueHex,iterationCount:this.macData.iterations,contentToVerify:r,signatureToVerify:this.macData.mac.digest.valueBlock.valueHex}))).then(e=>{if(!1===e)return Promise.reject("Integrity for the PKCS#12 data is broken!")},e=>Promise.reject(e))}}break;case"1.2.840.113549.1.7.2":{this.parsedValue.integrityMode=1;const e=new Dr({schema:this.authSafe.content});if("eContent"in e.encapContentInfo==!1)return Promise.reject('Absent of attached data in "cmsSigned.encapContentInfo"');if(e.encapContentInfo.eContent instanceof j==!1)return Promise.reject('Wrong type of "cmsSigned.encapContentInfo.eContent"');let r=new ArrayBuffer(0);if(!1===e.encapContentInfo.eContent.idBlock.isConstructed)r=e.encapContentInfo.eContent.valueBlock.valueHex;else for(let t=0;t<e.encapContentInfo.eContent.valueBlock.value.length;t++)r=Ae(r,e.encapContentInfo.eContent.valueBlock.value[t].valueBlock.valueHex);const s=ve(r);if(-1===s.offset)return Promise.reject('Error during parsing of ASN.1 data inside "this.authSafe.content"');this.parsedValue.authenticatedSafe=new yr({schema:s.result}),t=t.then(()=>e.verify({signer:0,checkChain:!1})).then(e=>{if(!1===e)return Promise.reject("Integrity for the PKCS#12 data is broken!")},e=>Promise.reject(`Error during integrity verification: ${e}`))}break;default:return Promise.reject(`Incorrect value for "this.authSafe.contentType": ${this.authSafe.contentType}`)}return t.then(()=>this,e=>Promise.reject(`Error during parsing: ${e}`))}}function jr(e){document.body.removeChild(e.target)}function Hr(e,t,r){return Promise.resolve().then(function(){return function(e,t,r){var s=Promise.resolve(),a=ve(f(m(t))),n=new Le({schema:a.result}),i=[];i.push(new qt({bagId:"1.2.840.113549.1.12.10.1.1",bagValue:n})),e.forEach(function(e){a=ve(f(m(e)));var t=new Ot({schema:a.result});i.push(new qt({bagId:"1.2.840.113549.1.12.10.1.3",bagValue:new Jt({parsedValue:t})}))});var o=new Or({parsedValue:{integrityMode:0,authenticatedSafe:new yr({parsedValue:{safeContents:[{privacyMode:0,value:new _t({safeBags:i})}]}})}});return s=(s=(s=s.then(function(){return o.parsedValue.authenticatedSafe.makeInternalValues({safeContents:[{}]})})).then(function(){return o.makeInternalValues({password:f(r),iterations:1e5,pbkdf2HashAlgorithm:"SHA-256",hmacHashAlgorithm:"SHA-256"})})).then(function(){return o.toSchema().toBER(!1)})}(e,t,r)}).then(function(e){var t=new Blob([e],{type:"application/x-pkcs12"}),r=document.createElement("a");r.download="pkijs_pkcs12.p12",r.innerHTML="Download File",r.href=window.URL.createObjectURL(t),r.onclick=jr,r.style.display="none",document.body.appendChild(r),r.click()})}e.passwordBasedIntegrity=Hr,e.default=Hr,Object.defineProperty(e,"__esModule",{value:!0}),window.passwordBasedIntegrity=Hr});
